##  第一章 基础知识







## 第二章 寄存器

本章主要介绍了寄存器，寄存器主要起着存储操作码（指令）和数据的作用。

不同CPU的寄存器个数和结构是不一样的。

这一张主要讲了：

- 通用寄存器如何存储数据。可以将16通用寄存器差费为两个8位寄存器。

- 一个字由两个字节组成
- 一些汇编指令
- 8086CPU(16位CPU)如何寻址20位的地址
  - 将20位地址拆分为 段地址x16+偏移地址，段地址和偏移地址分别由两个寄存器保存并传输给地址加法器，形成20位物理地址
- 内存中段的概念：将连续的内存人为划分成不同的段区，一个段的起始地址就成为段地址。
- 段寄存器（以CS为例），指令指针寄存器（IP）
- 修改CS、IP的指令：jmp
- debug的使用

> - 汇编不区分大小写
> - 数据和指令没有本质区别，都是二进制数，区别在于你怎样解释它。8086CPU只认被CS:IP指向的内存单元中的内容为指令
> - 将一个16位寄存器拆分成两个8位寄存器用时，低8位寄存器溢出的数据并不会存在高8位中，而是存在另一个单独的寄存器中。
> - 只有位数相等的寄存器才能相互加减或移动数据
> - 同一个物理地址可以由不同的段地址x16+偏移地址构成
> - CPU会根据CS:IP的地址读取内存中的指令/数据，每读取一条完整的指令，IP就会自动增加以读取下一条指令



## 第三章 寄存器（内存访问）



### 字单元

内存中的单元是以字节为单位，存放一个字则需要两个连续的内存单元。

以哪一个地址为起始地址的字单元就称为几地址单元，例如：

一个以地址1为起始地址的字单元，它占用了1、2两个字节单元，我们称它为1地址字单元



### DS和[address]

DS是另一个段寄存器，与CS不同的是，CS是代码段寄存器（指向要运行的指令的段地址），DS通常用来存放要访问数据的段地址。



8086并不支持将数据直接送入段寄存器（貌似是所有段寄存器），只能通过另一个寄存器/内存单元进行中转。

设置了段寄存器DS的值之后，就可以使用方括号`[]`来表示偏移地址了，这样就可以访问内存数据了，例如：

```assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```

前面两条指令先将ds设置为1000，然后用方括号表达式将1000:0地址处的数据移动到al中。



### 字的传送

如果在mov中给出的是16位寄存器的名字，一次就能传送16位数据了

```assembly
mov ax,1000H
mov ds,ax
mov bx,[0]
```

最后一句就是将1000:0和1000:1这两个字节单元的数据复制到bx中，bx的高8位存放1000:1的数据，低8位存放1000:0的数据，其他情况可类比。



### 3.4 mov、add、sub指令

add、sub指令不能对段寄存器操作，即`add ds,ax`是错误的。但是可以对内存单元和通用寄存器操作。

### 3.5 数据段

数据段的长度是认为规定的，同时是可以变化的，关键在你怎么看。

### 3.6 栈

- 两个基本操作：入栈、出栈
- 特点LIFO（Last In First Out）



### 3.7 CPU提供的栈机制

- 两个基本操作：入栈——push、出栈——pop
- 两个地址寄存器：SS——段寄存器、SP——偏移地址寄存器
  - 任意时刻，SS:SP指向栈顶元素



> - 8086CPU的入栈和出栈操作都是以字为单位进行的，且数据的高8位总是对应高地址，低8位对应低地址
>
> - 8086CPU中栈是从高地址向低地址移动的（不知道其他CPU是不是一样）,所以SP=SP-2就是指向栈顶上面的一个新的字单元
>
> - 8086CPU的入栈和出栈操作都分为两步
>
>   Push：
>
>   1. SP=SP-2
>   2. 将输入送入SS:SP指向的字单元
>
>   Pop：
>
>   1. 将SS:SP指向的内存单元送出到某一个寄存器
>   2. SP=SP+2

#### 问题3.6

栈为空时，SS:SP指向的是栈底地址的SP+2，原理还是上面所说的，SS:SP是随着数据的入栈，由高地址移向低地址的。

> 数据出栈之后并不会被删除，仍然存在，但是下一次有数据入栈就会把他覆盖掉，这也就解释了为什么C++中的vector，pop之后再次将下标指向原来的那个，数据仍然存在且没有变化的现象。



### 3.8 栈顶超界的问题

入栈和出栈都存在越界的危险，且这种情况很可能覆盖掉栈外的其他程序的代码或数据，导致一系列错误，所以这是极度危险的。

但是8086CPU中并没有防止栈越界的机制，所以只能靠我们编程的时候注意了。



### 3.9 push、pop指令



### 3.10 栈段

- 栈段也是我们编程时认为确定的，自己知道就好，计算机CPU并不会帮你设置一个栈段的标志，我们需要做的就是将SS:SP指向我们定义的栈段

- 8086CPU一个栈段最大容量为64KB，因为偏移地址只有16位，SP减小到0000H就会循环回到FFFFH



### 段的综述

段可以分为三种：

- 数据段——用来存放数据
- 代码段——用来存放代码
- 栈段——当做栈



计算机怎么区分这三种段呢？

就是通过不同的段寄存器所指向的位置来区分：

- DS指向数据段的段地址，通过方括号`[]`来表示偏移地址
- CS指向代码段的段地址，IP用于表示偏移地址
- SS指向栈段的段地址，SP用于表示偏移地址

> neicundanyuan寄存器中的二进制机器码本身既可以表示指令，又可以表示数据，关键在于怎么解释，而计算机就是通过上面这几个段寄存器和偏移地址寄存器来对二进制机器码进行解释的。



### 实验2 用机器指令和汇编指令编程

- **Debug的t命令在执行修改寄存器SS——栈的段寄存器之后，下一条指令会紧接着被执行，并不会暂停。**这一点与**中断机制**有关，会在后半部分研究。



## 第四章 第一个程序



编写一个完整的汇编语言程序的流程是：

1. 编写汇编程序代码文件，即源程序
2. 对源程序进行编译连接，生成可执行文件



### 源程序

汇编语言的最简单的框架如下：

```assembly
assume cs:codesg

codesg segment
	
	mov ax,0123h
	mov bx,0456h
	add ax,bx
	add ax,ax
	
	mov ax,4c00h
	int 21h
	
codesg ends

end
```



其中

- assume XX:XXX

- XXX segment

  XXX ends

- end

都是伪指令，由编译器执行。



顾名思义，segment的作用就是定义一个段，例子中的段名称是codesg（这种人为定义的名称称为标号，这个标号最终会被编译、连接程序处理成一个段的段地址），assume用来指明某一个寄存器与哪一个段相关联，ends和end都是结束标志。



真正被翻译为机器码的是其中的汇编指令，也就是segment部分里的代码。

### 编译、连接

在dos系统中，用masm程序把源程序编译，生成包含机器码的目标文件，然后用连接程序link连接目标程序，声称可执行文件。

### 运行可执行文件

在DOS系统中，一个程序P2要被运行，它必须被一个正在运行的程序P1加载入内存，然后把CPU的控制权交给P2运行过程中，P1暂停运行，P2运行完毕后，P1重新获得CPU的控制权。



首先我们要知道在系统中是哪个程序（P1）将P2载入内存的。

- 如果是直接在命令行执行可执行程序，那么这个P1就是命令行程序——command.com，称为命令行解释器，也是DOS系统的shell程序。
- 如果是通过其他程序执行的，例如`debug 1.exe`，那么P1就是debug程序。

（那么问题来了！是哪个程序把command.com装入内存的呢？操作系统吗？那么操作系统是如何被装载入内存的呢？这个问题可以自行查找）

P2运行到最后的时候，怎么判断程序是否结束呢？

这时候就要有一个标志返回的代码，上面的例子中`mov ax,4c00h`和`int 21h`，就是用来实现返回的，我们这里不过多地讨论原理，只要知道这两句代码的意义就行。

> debug调试一个程序时最后的int 21h指令要用p命令执行



#### P2被加载到内存中的过程

1. 找到一段偏移地址为0的地址，`SA:0000`。
2. 从这个地址开始，创建一个称为程序段前缀（PSP）的数据区，大小为256字节（16进制表示就是100h），DOS会利用这个PSP来和被加载的程序进行通信。
3. 从`SA+10h：0`地址处开始加载程序
4. 将SA的值赋给DS寄存器（数据段寄存器），将SA+10h:0赋值给CS:IP这两个寄存器。



## 第五章 [BX]和loop指令

### [BX]

在debug程序中，我们可以直接使用：`mov ax,[0]`，将DS:0地址处的数据送入ax寄存器中，但是我们在编写源程序时，若也写成上述形式，则会被编译器解释为`mov ax,0`，若要想达到同样的目的，有几种方法可以实现：

- 我们可以使用一个寄存器bx来保存偏移地址，然后`mov ax,[bx]`，这样编译后就没问题了，相当于是把bx当做一个变量。
- `mov ax,ds:[0]`，这样也能正确的被编译器理解。
- `mov ax,ds:[bx]`，同上。



### loop

loop就是循环，基本框架如下：

```assembly
  	mov cx,3
  s:add ax,ax
  	loop s
```

其中s是一个标号，在汇编语言中，标号就代表了一个地址，这里的s代表的是存放`add ax,ax`这个指令的地址。

汇编语言中循环次数通过寄存器cx的值来控制，每次执行`loop s`这个语句的时候，会先将cx的值减一，然后判断cx是否为0，若cx的值为0，就停止循环，执行loop之后的指令，若不为零，则跳到s所标志的地址处。



### 两个“新的”DEBUG命令

- g命令

  `g 偏移地址`，这个指令会自动执行程序指导ip指向目标的偏移地址。在我们不想单步运行，想直接快速运行到一个语句的时候就可以用这个命令。

- p命令

  在遇到loop指令的时候，可以用这个指令直接一次运行到loop结束的时候，在循环次数比较多的时候可以使用。



### loop和[bx]联合应用

这里就是把bx当做一个循环里的变量，每循环一次bx会改变，以指向不同的地址，学过一些高级语言（例如c语言）的同学应该很好理解这个。



### 段前缀

除了直接`mov ax,[bx]`，这样会默认把ds的值当做段地址，我们还可以显示地写出，例如：`mov ax,cs:[bx]`

这是把寄存器cs中的值当做段地址。

利用这个特性，我们可以方便的操作一些跨度比较大的地址了——通过改变段前缀的值。

### 一段安全的空间

一般来说，**直接向一段未知的内存空间写入内容是很危险的**，因为其中可能存放着重要的系统数据或代码。

例如，向`0000:0026h`写入数据会引起程序崩溃和死机。

DOS系统中，系统和其他合法程序一般都不会使用`0:200~0:2ff`这段256字节的空间，所以，我们使用这段空间是安全的。



### 实验4

- **cx寄存器存放的是程序的字节多少**，不包含最后的`mov ax,4c00h`和`int 21h`两句。



## 第六章 包含多个段的程序

### 程序获取内存空间有两种方法：

1. 在加载程序的时候为程序分配
2. 在执行的过程中向系统申请

这里我们只讨论第一种。

### 定义数据

我们可以在一个段中定义一些“常量数据”，用`dw`关键字来定义字类型数据，例如：`dw 0123h,0456h,0789h`。

如果我们把这句话写在只包含一个段的源程序的开头，例如：

```assembly
assume ...

code segment
	dw 0123h,0456h,0789h
	...
code ends
```

那么在该代码段的开头的三个字大小的空间，也就是我们所定义的三个字类型的数据，会被解释为该机器码对应的汇编指令，我们在debug程序中用u指令可以看到这些机器码对应一些“奇怪的汇编指令”。

为了使只被当做数据区域，我们需要定义一个标号，来告诉编译器真正的汇编指令开始的地址在哪，然后最后的end后要加上该标号的名字以对应，例如：

```assembly
assume ...
code segment
	dw ...
start: ...
	
code ends

end start
```

其中的start就是那个标号。编译之后，CS:IP就会指向start所指的地址了，从该处开始执行汇编指令。

### 在段中使用栈

我们还可以在段中使用栈，方法就是用dw定义一些0数据，以达到申请内存空间的目的：`dw 0,0,0,0,0`。然后可以通过将SS:SP指向最后一个0后面的一个字的地址（如果忘了为什么是这样，请回顾第三章的栈部分）来把这段空间当做栈使用。

### 使用多个栈

目前我们这样还只是把数据和栈还有汇编指令都放在一个段中，这样做可能会给以后造成麻烦，结构不清晰。我们可以使用多个段来分别存储数据、代码和栈，一个例子如下：

```assembly
assume cs:code,ds:data,ss:stack

data segment
	dw ...
data ends

stack segment
	dw 0,0,0,...
stack ends

code segment
start:...
code ends

end start
```

声明多个段的方法很好理解（如上）。

值得注意的是，如果我们将代码部分的段不是放在第一个，例如上面是放在最后一个。那么end后就必须要加上start来指明程序的入口，如果不加的话，CS:IP就会默认指向第一个段的起始地址，这就会把数据，或者其他段的机器码解释为汇编指令从而造成错误。如果代码部分的段是放在第一个，那么最后的end后的标号可以去掉，不过还是建议写上以获得更清晰的逻辑。



## 第七章 更灵活的定位内存地址的方法



### and、or指令和定义字符数据

这两个指令分别是按位与和按位或。按位与可以用来把特定的某一位变成0，按位或可以把特定的某一位变成1。这个特性可以方便地实现一些操作，比如大小写字母转换的操作，因为由观察可以得到，对应的大小写字母的二进制码只有第五位（以第零位开头）是不一样的，大写字母是0，小写字母是1，这样就可以利用按位与和按位或来实现转换了，并且不用判断原来的字母是大写还是小写。

用法：

```assembly
assume ...
datasg segment
	db 'd'
datasg ends

code segment
start: mov ax,datasg
	   mov ds,ax
	   mov bx,0
	   mov al,[bx]
	   and al,11011111B
	   mov [bx],al
	   
	   mov ax,4c00h
	   int 21h
code ends
end start
```

上述的代码就是把字母d转换成大写字母，`db '...'`就是定义字符数据（也就是一个字节）的命令（用任意字符替代...），`and al,11011111B`就是按位与的语法，按位或是`or ...,...`。



### 更灵活的寻址方式

1. `[idata]`，用一个常量来表示偏移地址
2. `[bx]`，用一个变量来表示偏移地址
3. `[bx+idata]`，用一个变量和一个常量来表示偏移地址
4. `[bx+si]`，用两个变量来表示偏移地址
5. `[bx+si+idata]`，用两个变量加一个常量来表示偏移地址

其中si是一个和bx作用差不多的寄存器，另外还有一个是di，也能如此利用。

第3种方法还有其他形式的写法：`[idata+bx]`、`idata[bx]`、`[bx].200`，其中第二个形式与一些高级语言（例如C语言）中的数组形式类似，idata可类比为数组名。



- 利用变量来表示偏移+常量地址，我们可以更方便地干更多的事了，例如要处理一些“二维数组”的问题。



在这一章中，作者还沁出了二重循环的问题，由于loop循环默认只能使用cx作为循环计数器，所以存在内外两层循环重复使用的问题，会造成一些逻辑bug，这时我们就要想办法了。

1. 可以将外部的cx值先保存在一个寄存器中，待内部循环完成后将寄存器中的值重新取出

   这个方法可能在更复杂的编程中会遇到寄存器不够用的问题

2. 我们还能单独申请一个内存空间用于存放cx的值

   这样我们需要记住在哪个内存单元中存放的是哪个循环的cx值

3. 最后我们可以申请一个栈段的空间来专门保存暂存值

   这样就比较清晰地将数据和暂存数据分开，并且操作方便了

具体例子请看书上P155-158



## 第八章 数据处理的两个基本问题

### 1. 处理的数据在哪？

第一个问题的答案就是地址，前面的章节中介绍的各种寻址方式就可以用来确定数据所在的地址。

这里还介绍了一个新的寄存器**bp**，用处于bx相同，不能与bp同时使用，但可以用来替换bx，例如：`[bp+si+idata]`

指令在执行前，所要处理的数据可以在三个地方：1. CPU内部——即寄存器、2. 内存、3. 端口（后面介绍）

### 2. 要处理的数据有多长？

第二个问题的答案，汇编语言中有三种方法来确定（8086CPU中能处理两种长度的数据：字节byte和字word）：

1. 通过寄存器名来确定

因为汇编语言指令所处理的数据必须等长，因此只要处理的数据中出现了某一个寄存器名，那么该指令处理的数据长度就是该寄存器的长度，例如：`mov ax,1`，这里ax是一个16位寄存器，因此后面的1也是一个16位的数据；`mov ax,ds:[0]`，同样，这里处理的ds:[0]是处理ds:[0]和ds:[1]这两个字节的数据；`mov al,1`，这里al是一个8位寄存器，那么1代表的就是一个8位数。



2. 在没有寄存器的情况下，用操作符X ptr指明内存单元的长度（X代表内存长度）

X ptr能定义两种长度：byte和word，例如：

`mov word ptr ds:[0],1 `

`mov byte ptr ds:[0],1`

在上面两个就是分别指明了word和byte长度。

3. 默认

有一些指令有默认的处理长度，例如`push [1000h]`就不用指明是字单元还是字节单元，因为push指令只进行字操作。



### div指令

div是除法指令。语法：`div reg`或`div 内存单元`

div后面紧跟的是除数，被除数默认放在AX或AX和DX中，如果除数为8位，则被除数位16位，默认放在AX中，如果除数为16位，被除数为32位，默认存放在DX和AX中，DX存放高16位，AX存放低16位。

如果除数为8位，执行div指令后，AL的内容位为除法操作的商，AH的内容位除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。

### 伪指令dd

dd类似db和dw，dd是define double word的缩写，即定义双字型数据。

### dup

dup（duplicate）用来配合db、dw、dd等伪指令来实现数据的重复定义，例如：

`db 3 dup (0)`，定义3个字节，值都为0，相当于db 0,0,0

`db 3 dup (0,1,2)`，定义了9个字节，相当于db 0,1,2,0,1,2,0,1,2



## 第九章 转移指令的原理

**可以修改IP，或者同时修改CS和IP的指令统称为转移指令**



### 操作符offset

offset在汇编语言中是由便一起处理的符号，他的功能是取得标号的偏移地址，例如：

```assembly
assume cs:codesg
codesg segment

start: mov ax,offset start	;这里就是取得start的偏移地址，也就是0，送入ax中
	s: mov ax,offset s		;这里是取得s的偏移地址3送入ax中
	
codesg ends
end start
```



### jmp指令

jmp是无条件转移指令，可以只修改ip，也能同时修改cs和ip。

根据jmp指令的原理来分类，可以分为两种：

1. 指令中存在的是相对位移的jmp指令
2. 指令中存在的是绝对地址的jmp指令



#### 1. 依据位移进行转移的jmp指令

这中根据相对偏移地址来转移的jmp指令有两种形式：

1. `jmp short 标号`
2. `jmp near ptr 标号`

他们之间的不同是存放相对位移的位数不同，short用8位补码来存放位移，因此所表示的范围是-128~127，

near是用16位补码来存放位移，所表示的范围是-32768~32767。

> 值得注意的是，这里的相对偏移地址是指在CPU读取jmp指令后，(IP)=(IP)+所读取的指令长度后，(IP)与标号所表示的偏移地址的差，由于依据位移进行转移的jmp指令长度为2字节，因此上述公式一般为(IP)=(IP)+2。
>
> 同时，这个相对位移是在程序编译的时候算出来的

#### 2. 依据绝对地址转移的jmp指令

依据绝对地址进行转移的jmp指令又分为3种

1. 根据标号所在的绝对地址来修改CS:IP
2. 转移地址在寄存器中的jmp指令
3. 转移地址在内存中的jmp指令



##### 第一种指令的格式：`jmp far ptr 标号`

其中“far ptr”就指明了用标号所在的段地址和偏移地址修改CS:IP。转换成机器码之后，占用了5个字节，后面四个字节中，低字节所存储的是标号的偏移地址，高字节存储的段地址。



##### 第二种指令的格式：`jmp 16位reg`

这个指令就是直接将一个16位寄存器中的值赋给IP，例如：`jmp ax`就相当于`mov ip,ax`。

这个指令在第二章中讲到过

##### 第三种指令的格式：`jmp X ptr 内存单元地址`

这里的X可以换成word或dword，内存单元地址可以用之前所讲的任何一种形式表示。下面以实例讲解：

```assembly
mov ax,0123h
mov ds:[0],ax
jmp word ptr ds:[0]
```

这些指令就是将ds:[0]的值赋给IP，达到跳转的目的。



```assembly
mov ax,0123h
mov ds:[0],ax
mov word ptr ds:[2],0
jmp dword ptr ds:[0]
```

`jmp dword ptr ds:[0]`就是将起始地址为ds:[0]的两个字的数值分别赋值给CS和IP，高地址的字赋给CS，低地址的赋给IP，也就是(CS)=(ds:[2])，(IP)=(ds:[0]) 



### jcxz指令

jcxz指令是一个条件转移指令，**所有的条件转移指令都是短转移，同时对应的机器码中只有位移，而不是绝对地址**，也就是只有8位用来存储位移，表示范围为-128~127。

格式：`jcxz 标号 `。

功能：如果(cx)==0，则执行转移，否则什么也不做，用高级语言来表示的话，如下：

`if((cx)==0) jmp short 标号;`



### loop指令

loop一般称为循环指令，但实质上也是一种条件转移指令，不过loop在判断cx的值之前要将cx的值减一，同时与jcxz的判断条件相反：如果(cx)==0，则什么也不做，否则转移至标号。

用高级语言来描述则是：

```c
(cx)--;
if((cx)!=0)
    jmp short 标号;
```



### 根据位移进行转移的意义

前面所讲的：

1. jmp short 标号
2. jmp near ptr 标号
3. jcxz 标号
4. loop 标号

都是根据位移进行转移的，这种根据相对地址来转移的好处在于不用关心每次运行程序时，程序具体被装在在哪段内存地址。



### 转移位移超界

编译器会对依据位移进行转移的指令进行检测，如果位移的范围超过了其能表示的范围，那么编译器就会报错。

```assembly
assume cs:code
code segment
	start:jmp short s
		  db 128 dup (0)
		s:mov ax,0ffffh
code ends
end start
```

上面这段程序在编译的时候就会报错，因为转移的位移超过了127，如果将short改成near ptr就没有问题了。



## 第十章 CALL和RET指令

​		**这一章所讲的内容是非常重要的，它对理解高级语言中的函数调用有着重要的意义！**

### 1. “调用”和“返回”

我们首先来介绍一下调用子程序中最重要的两个指令：**CALL**和**RET**。

#### CALL

call在英语中有调用的意思，所以也就不难猜到它的作用了，就是“调用”，但是它的基本原理还是转移指令。总体来说执行call指令相当于进行两步操作：

1）将当前的IP或CS和IP压入栈中；

2）转移

与上一章的转移指令一样，它也有多种形式：

1. `call 标号`

当执行这个命令的时候，CPU进行了两步操作：

​	1）将当前的IP压入栈中；

​	1）依据16位位移转移至标号的偏移地址处

相当于执行了以下两句指令：

```assembly
push IP
jmp near ptr 标号
```

2. `call far ptr 标号`

这个指令实现的是段间转移，总体操作还是那两个步骤，下面直接用学过的汇编语句来解释更为清晰：

```assembly
push CS
push IP
jmp far ptr 标号
```

3. `call 16位reg`

相当于：

```assembly
push IP
jmp 16位reg	;也就是mov IP,reg
```

4. `call X ptr 内存单元地址`

X可替换为word和dword。

`call word ptr 内存单元地址`相当于：

```assembly
push IP
jmp word ptr 内存单元地址
```

`call dword ptr 内存单元地址`相当于：

```assembly
push CS
push IP
jmp dword ptr 内存单元地址
```



#### RET

ret可以理解为return的缩写，它有两种形式，一个是ret，一个是retf（相当于ret far？）

执行ret指令时，相当于进行`pop IP`，执行retf指令时，相当于先进行`pop IP` 然后`pop CS`。



### 2. mul指令

这里我们插入一个mul指令，为以后些更复杂的程序做准备。

mul是multiply的缩写，指令后面跟的参数只有1个：`mul reg`或`mul 内存单元`

如果后面的reg或内存单元是8位的，那么另一个乘数默认存放在al中，计算的结果默认存放在ax中；如果是16位，另一个乘数默认存放在ax中，计算结果的高16位存放在dx中，低16位存放在ax中。

一个小例子：

```assembly
;计算100*10
mov al,100
mov bl,10
mul 10
```



### 3. 子程序框架

学习了CALL和IP后，我们就可以知道写一个子程序并调用的框架是什么了：

```assembly
assume cs:code
code segment
main: ...
	  call sub1
	  ...
	  mov ax,4c00h
	  int 21h

sub1: ...
	  call sub2
	  ...
	  ret
	  
sub2: ...
	  ...
	  ret
code ends
end main
```



### 4. 参数和结果的传递

在高级语言中调用函数我们有参数和结果的传递，那么在底层是如何实现的呢？



1）可以通过把参数和结果存放在寄存器中来传递参数。但这种方法只适用于参数和结果比较少的情况，因为CPU内寄存器数量有限。

2）当需要传递的参数和结果很多的时候，我们可以将参数放到内存中，然后传输这组参数的首地址，就能通过定位内存地址的方法来处理所传参数了，这对传入参数和返回结果都适用。



### 5. 寄存器冲突问题

当主程序和子程序中都用到同一个寄存器（例如cx）时，那么运行时就会存在一些“意想不到”的问题。

之前在多重循环中解决类似问题的方法是将cx压入栈，再取出来，我们这里也能借鉴这种方法。

这里我们设计了一个更好的、更保险的方法：在子程序开始之前将子程序中所用到的所有寄存器的内容都保存在栈中，在子程序返回之前再恢复（这刚好应证了我前几天在《算法竞赛入门经典》中看到的函数调用栈部分）。

一个子程序的例子：

```assembly
sub1: 	push cx
	  	push si	;假设在子程序中只要用到cx和si这两个寄存器
	  
change: ...
		...
		jcxz ok
		...
		...
		
	ok: pop si
		pop cx	;注意入栈和出栈的顺序
		ret
```

 

### 做实验10遇到的坑（犯的2）！！！

#### 1.显示字符串

我把初始化di（列位移）放在了change内部导致最终结果只显示最后一个字符。

#### 2.除法溢出

没大问题，理清思路就行

#### 3.数值显示

我写这个子程序时一开始是用的8位除法，结果没有考虑到317AH（12666）除以AH（10）的结果16进制超过了2位（4F2H），导致div cl溢出，然后出现中断iret，但是我一开始并没有意识到这是中断......然后按照网上的改成了16位的除数，没有在每次除法过后清零dx，仍然是溢出的问题.....最后对比网上的代码终于发现漏了`mov dx,0`这一句......心累/(ㄒoㄒ)/~~



## 第十一章 标志寄存器

标志寄存器是一种比较特殊的寄存器，它有三种作用：

1. 用来存储相关指令的某些执行结果（这些相关指令大多是运算指令，例如：add、sub、mul、div、inc、or、and等，但这些指令也不是对所有的标志位都有影响，而mov、push、pop等传送指令则对标志寄存器没有影响）
2. 用来为CPU执行相关指令提供行为依据
3. 用来控制CPU的相关工作方式

8086CPU中的标志寄存器是flag，flag的一些位在8086中没有用，不具有任何含义（具体见书P213页）。下面简要说明一下那些有意义的寄存器的作用：

1. ZF（Zero Flag）标志——flag的第6位，零标志位。它记录相关指令执行后，其结果是否为0，如果为零，则ZF=1，否则ZF=0。

2. PF标志——flag的第2位，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数，如果为偶数，PF=1，否则PF=0
3. SF（Sign Flag）标志——flag的第7位，符号标志位。它记录在进行**有符号数**的相关运算后，其结果是否为负，如果为负，SF=1，否则SF=0
4. CF（Carry Flag）标志——flag的第0位，进位标志位。它记录在进行**无符号数**运算的时候，运算结果的最高有效位向更高位的进位值，或从更高位的借位值
5. OF（Overflow Flag）标志——flag的第11位，溢出标志位。它记录**有符号数**运算的结果是否发生溢出

> 值得注意的是，3、4、5中所说的有符号数和无符号数，都是在判断的时候将所操作的二进制数据解释为有符号或无符号，二进制数本身并不代表有符号或者无符号。

