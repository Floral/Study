# 程序员的自我修养

## 第二章

从源代码到可执行程序的整个过程，可以分为四步，分别是：**预编译，编译，汇编，链接**。

### 预编译

预编译主要是处理代码中的预编译指令，预编译指令都是以`#`开头的，形如`#define`、`#include`、`#ifdef`**等**，其中`#define`是直接文本替换；`#include`则是把include的文件直接复制到改行所在的位置；`#ifdef`是用来对部分代码是否需要编译进行控制的。长得像预编译指令的`#param`则会保留，因为这是给传递给编译器的指令。

PS：注释在预编译阶段会被全部删除。

### 编译

狭义的编译就是将源代码翻译为汇编代码的过程，至于为什么说狭义，因为我们平常说的编译，一般包括了后面的汇编和链接过程。

### 汇编

汇编就是把汇编语言转换为机器语言，这本质上是一个**查字典**的过程，因为每一条汇编语句都对应着唯一的机器码（不同ISA的CPU有着不同的字典）。

### 链接

在以前的单文件、小软件时代，由于符号（函数或变量）的定义和对它们的引用都是在同一个文件中，其地址很方便分配与确定，但是随着软件的大型化、模块化发展，一个软件的源代码文件有几十上百个（甚至上千上万），它们生成的目标文件也有几十上百个。在它们之间，符号定义和其引用关系很复杂，一个文件中定义的符号很可能被其他文件所引用，且文件之间存在相互引用，于是导致不能在编译阶段确定符号的地址，只能采用临时地址来暂时替代最终的实际地址。

具体的符号的地址在最后一步——链接过程完成，链接细致一点又可以分为**地址和空间的分配，符号决议，重定位**，这三个步骤。其中第一个过程看名字就很好理解；第二个过程则是链接器检查所有的目标文件中每一个符号的引用，确保它们有且仅有有唯一的定义；第三个过程则是对目标文件中不能确定的临时地址的修正，将其修改为分配完地址后的地址。



### 编译器的流程

现代编译器通常集成了上述四个功能。我们现在以编译一个单一源代码文件的流程来进一步分析编译的背后流程，主要分为6个步骤：词法分析，语法分析，语义分析，中间语言生成，目标代码生成，目标代码优化。

#### 词法分析

词法分析是将源代码输入到一个扫描器中，得到的结果是对代码中各种符号的识别分类，这里的符号包括：关键字，标识符，字面常量运算符等。为后续的语法分析奠定基础。

#### 语法分析

语法分析是检查你所写的代码是否符合语言的语法￼规定。

它利用词法分析得到的记号来生成语法树。语法树就是你此法分析中得到的各种为节点的、按照你所写的代码的表达式来组织的一种树状数据结构。这里的语义分析并**没有确定**各种记号的**具体**类别，例如变量a的类型到底是int还是float，只知道它是一个变量，假如有一句`b=array[a];`，**即使a实际是float类型，但是在语法分析阶段还是不会报错**，因为这一句满足变量作为下标这一个语法，这里检查出来有错误是下一步——语义分析的工作。

一个语法树的例子，以下是表达式`a=(b+4)*c;`的语法树：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20210120204442258.png" alt="image-20210120204442258" style="zoom:25%;" />

#### 语义分析

语义分析是检查你所写的代码表达式是否是具有正确的意义，例如你把一个浮点数用作数组的下标，这在语法上是正确的，因为满足下表示一个标识符这个语法，但是这种写法并没有正确的含义，因为数组的下标是不能用浮点数表示的。

#### 中间语言生成

中间语言生成是将源代码转换为一种，便于优化的表现形式（中间语言），一般有可以转为三地址码，P-代码等。并在这个过程中对代码进行一次优化。由于是从源码转换过来的，所以又称源码级优化。

#### 目标代码生成与优化

中间语言生成之后就进入到了**编译器后端**流程。其就是将中间语言代码转换为最终目标机器平台的机器语言代码（也就是0、1组成的bit流），同时进行优化。其实这个过程就包括了之前所说的汇编过程。





## 第三章 目标文件里有什么



目标文件就是源代码经过编译后的，链接之前的文件，经过链接就变成了可执行文件，它也是一种二进制文件。

目标文件的格式其实与最终的可执行文件的格式是一致的，只是没有经过符号的链接过程。

在Windows环境下，可执行文件的格式是PE（Portable Executable），在Linux环境下，可执行文件的格式叫ELF（Executable Linkable Format），这两种格式差别不大，都是源自于COFF（Common File Format）格式的。

### ELF文件

下面主要介绍一下ELF文件格式。

ELF文件下又可以分为4种类型：

- **可重定位文件（Relocatable File）**，包含代码和数据，一般是指静态链接库文件。
- **可执行文件（Executable File）**
- **共享目标文件（Shared Object File）**，也是一种可重定位文件，但是它可以被用于动态链接。
- **核心转储文件（Core Dump File）**，进程意外终止的时候，系统把进程地址空间的内容和一些其他信息存放到核心转储文件中，可以用于排除BUG。



一个目标文件/可执行文件的基本组成部分都是段（Segment/Section），段就是把一个程序的不同部分分类存放，形成不同的段，一个目标文件最基本的段包括：

- **代码段（程序段）`.text`**，代码段就是存放程序的逻辑代码部分。
- **数据段`.data`**，用于存放变量数据，但是这里存放的是**已初始化**的全局/静态变量。
- **BSS（Block Started by Symbol）`.bss`**，BSS段则是为**未初始化**的全局变量和局部的静态变量，为他们预留位置，BSS段的起源是一个历史原因，同时也可以节省目标文件占用的空间。



那么有人会问，那局部变量存放在哪呢？**局部变量**是存放在进程地址空间中的**栈**里，因为局部变量的生命周期是临时的一个函数调用期，而全局变量/静态变量的生命周期是整个程序运行期间，所以我们将全局/静态变量放在进程中单独的一个段里。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20210122183320332.png" alt="image-20210122183320332" style="zoom: 25%;" />

<center>目标文件的3个基础段</center>

> PS：段名都是以小数点`.`开头的。
>
> PPS：有的编译器不会直接把未初始化的全局变量放在bss段中（即在bss段中分配确定大小的空间），而是会将其标记为一个COMMON符号，等到最后链接成可执行文件后才确定大小，在bss段中分配空间。例如这个程序的bss段大小就为4个字节，而不是8个字节，因为`global_uninit_var`并没有直接在bss段中分配空间，具体原因涉及到后面的弱符号和COMMON块。

同时，目标文件的最开始包含一个ELF文件头（ELF Header），它用来说明整个ELF文件各种信息，包括：是否可执行，是静态链接还是动态链接，入口地址（如果是可执行文件），目标硬件，以及**段表（Section Header Table）**的位置（文件位置偏移）等。这里的段表是一个重要的部分，它本质是一个数组，用来描述ELF文件中各个段的信息（名字、偏移and其他信息）。

目标文件中除了有各种“段”，还有各种“表”，上面说的段表就是一个，除此之外还有重定位表（Relocation Table）、字符串表（String Table）、符号表（Symbol Table）等等。每一个表也是通过段的形式存储在目标文件中的。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20210122181949194.png" alt="image-20210122181949194" style="zoom:25%;" />

<center>ELF文件结构</center>

每一个需要重定位的段（例如代码段、数据段），都会有一个对应的重定位表，用来描述该段中需要重定位的引用的信息。

字符串表是将程序中所用到的变量名、段名等字符串集中起来放在一个段里，通过偏移量来表示字符串的。

符号表就是用来存放代码中用到的各种符号（函数名或变量名）的信息。符号一般分为全局符号、局部符号、段名、行号等。这里的全局符号（全局变量、非static函数）不仅包括定义在本文件中的全局符号，也包括引用其他文件中定义的全局符号，局部符号则是仅本文件内部可见的符号（主要是局部变量，还有static的变量和函数）。**链接过程处理的就是全局符号**。

### 符号

#### 符号修饰问题

> 一个讲的比较好的blog：https://www.cnblogs.com/wfwenchao/articles/4140388.html

在“远古时代”，编译后目标文件中的符号名与源代码中的符号名是一致的，随着软件工程的发展，就出现了一个问题：一个软件可能由多个人共同开发完成，如果他们没有对各自负责的模块中的变量、函数命名进行沟通及规范的话，很可能会造成符号重复的问题，即，不同模块中不同功能的函数名（或全局变量名）可能是一样的，或者是开发者写的函数名与所用到的库中的某一个函数撞名了，那么链接器在符号决议过程中就会冲突报错。

为了解决这个问题，现在的编译器一般会把源代码中的符号，经过一种修饰的规则修饰之后放入目标文件中，称为**符号修饰（Name Decoration）或符号改编（Name Mangling）**，不同的C++编译器对符号的修饰规则是不一样的（例如GNU的g++和微软的Visual C++编译器）。

有了符号修饰这个机制，就能很好地实现函数重载这类机制了，因为修饰机制一般会区分开同名函数的不同参数列表。同时，命名空间也是为了解决符号冲突而引入的一种机制。

一个函数对应一个唯一的**函数签名（Function Signature）**，函数签名包括了确定一个函数需要的所有信息，例如：函数名、参数列表、命名空间等。一个函数签名对应一个修饰后的符号名称（Decorated Name）。

由于C和C++的修饰规则并不一样，所以为了在C++程序中使用C的修饰规则，我们可以使用`extern "C"`这个关键字来声明符号，例如：`extern "C" double a;`，那么编译器就会对变量a使用C语言的修饰规则。



#### 强符号or弱符号、强引用or弱引用

> 一个讲的比较好的blog：https://www.cnblogs.com/downey-blog/p/10470674.html

##### 强符号和弱符号

强符号和弱符号是针对定义来说的，在C/C++语言中，已初始化的全局变量是一种强符号，未初始化的则是弱符号。在符号决议的过程中如果发现了多个同名的强符号**定义**，那么就会报错；如果有一个强符号定义以及一些弱符号定义，则不会报错，且强符号定义会覆盖弱符号定义；如果没有强符号定义，只有弱符号定义，那么会选择占用空间最大的那个（例如double类型比int型占用的字节大）。

我们也可以手动定义一个初始化的强符号，只需使用`__attribute__((weak))`关键字，例如：`__attribute__((weak)) int weak2 = 2;`，不过这样手动定义的弱符号不能和强符号共存。

**弱符号的一个用处是：在库中的定义是弱符号，用户可以重新定义一个自己使用的同名强符号，使得其覆盖库中版本，使用用户自定义版本的库函数的作用。**

##### 强引用和弱引用

一般没有特殊声明的**引用**都是强引用，如果一个强引用在链接的符号决议过程中没有找到定义，链接器会报符号未定义的错误。而弱引用在没有找到定义时则不会报错，链接器会用0或者一个特殊的值代替。

将一个符号的引用声明为弱引用需要用到`__attribute__((weakref))`这个关键字，例如：`__attribute__((weakref)) foo()`，就是声明了一个名为foo的弱引用函数。当然，为了避免弱引用没有定义就使用，在使用前最好用if判断一下foo是否是0。

**弱引用一个重要的作用就是，使得程序的不同功能模块更容易地裁剪和组合。**



## 第四章 静态链接

所谓静态链接，就是在链接阶段把所有参与链接的目标文件合并到一个最终的可执行文件中。有静态就有动态，后面会讲的动态链接就是链接过程中只是指明了主程序在运行时需要哪些动态链接库（模块），最终链接得到的可执行文件并没有包含所有模块的代码，而是在运行过程中会动态地加载那些模块。



### 静态链接的过程

从目标文件到最终的可执行文件，主要分为两步：

1. **空间与地址分配**，这里的空间指的是目标文件的段在可执行文件中的空间位置，地址指的是每一条指令的虚拟地址，此步骤完成后就能确定目标文件中全局符号在可执行文件中的实际位置（虚拟地址），为第2步做准备。
2. **符号解析与重定位**，即根据重定位表的信息和第1步得到的全局符号地址对引用位置的地址进行更新。

#### 空间与地址分配

从前面的章节可以知道，每一个目标文件都是许多段组成的，要把许多目标文件这么多不同的段合并到最终的可执行文件里，一个很自然的想法就是把不同文件中的同一种段（.text或.data或其他的）合并成一个段，实际采用的就是这种方案。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/4-1%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" alt="4-1空间分配策略" style="zoom: 33%;" />

<center>这里插张图.jpg</center>

在合并的过程中，链接器会把所有的目标文件的符号表收集起来，组成一个新的全局符号表，为后续的符号解析和重定位做准备。

将段合并之后，就可以得到各个符号在可执行文件的段中的位置（偏移）与分配的虚拟地址（VMA）了。

> 这里讲一下虚拟地址（VMA）和加载地址（LMA）。
>
> 对于每一个进程，在操作系统（OS）中都有一个独立的假想的地址空间，我们称之为虚拟地址空间，虚拟地址空间可以起到隔离不同进程的作用。
>
> 现代的可执行文件中，使用的都是虚拟地址空间中的地址，在加载到物理内存的过程中，还需要经过一个地址转换的硬件模块（MMU），将虚拟地址转换为物理地址。
>
> PS：如果没有MMU的支持，那么目标文件中的虚拟地址就等于物理地址。
>
> 加载地址，对于普通的PC机，即是把程序从硬盘中加载到内存中之后的地址，一般来说加载地址与虚拟地址是相同的（即加载到哪就在哪运行），除了嵌入式的特例（自行百度）。



#### 符号解析与重定位

所谓符号解析，就是查找合并后文件中的段中引用的全局符号的定义（即找到定义的虚拟地址），这个步骤依赖的是全局符号表。

重定位就是修正指令中引用符号的地址，利用的是重定位表，重定位表的每一项对应一个需要修正的位置的偏移（每一个需要重定位的地方叫做**重定位入口**），同时包含修正方法的类型以及该符号在符号表中的地址。

修正方法的类型总的可以分为**绝对地址修正**和**相对地址修正**两类。

以下是每个重定位入口对应的包含重定位需要的信息的数据结构：

```c
typedef struct{
    int offset;  	// 需要被修改的引用的段偏移(重定位入口地址)
    int symbol:24, 	// 被修改的引用应指向的符号 
        type:8;   	// 修改方式
}ELF32_REL;
```

重定位段（表）的内容就是一个该数据结构的数组。

### 静态库链接

静态库就是一系列编译好的还未链接的目标文件的集合（通过ar打包），一般是一个库函数对应一个目标文件，因为这样可以实现用到什么函数就链接什么函数，不会附带把不需要的函数链接到可执行文件中，从而节省了空间。

这里也有张图.jpg

### 链接过程控制

链接控制过程有两种方式：

1. 命令行参数式
2. 链接脚本式

链接脚本的方式灵活性很强，甚至可以自定义段名。在进行嵌入式或无操作系统的平台开始时，通常会用这种方式来控制可执行文件的段的分布，以满足硬件的要求。

### COMMON块

在链接之前的目标文件中，未初始化的全局变量会被标记为COMMON类型，且不会直接在`.bss`段中分配空间，为什么呢？

本质原因是链接器不能区分符号的类型，无法判断若符号的类型是否一致，导致弱符号的占用空间在链接前不能确定（强符号和弱符号那一节中讲过）。



### C++相关问题

主要有两个问题：

1. 重复代码消除
2. 全局对象的构造和析构

#### 重复代码消除

这里要消除的代码主要是由C++的模板机制、外部内联函数、虚函数表等造成的冗余。以模板为例，如果在不同的源代码文件（编译单元）中可能对同一个模板`add<T>()`进行了实例化，且实例化参数相同`add<int>()`，那么就会在不同目标文件中生成相同的实例化代码，如果直接合并的话，就会造成冗余。

解决的方法是对每一个实例化后的模板，将其单独存在在目标文件中的一个段中，这个段的名字是该实例化模板修饰后的名称（例如：`.temp.add<int>`），保证了唯一性，于是不同目标文件中的同一种实例化模板就能被检查出来，在合并的时候只需保留一个段就行。

**函数级链接**

函数级别链接，就是把每一个函数都单独地放到一个段里，链接器检测到用到了哪个函数就链接相应的段，没有用到的不会被链接到最终的文件里，与前面的静态库链接差不多。其目的也是为了减小最终的文件大小。

#### 全局对象的构造和析构

在最终的可执行文件中，真正的程序入口是`_start`（Linux系统下），在这个函数中进行进程初始化工作，然后在其中调用`main`函数，进入到用户定义的主程序。全局类的构造就是在进入`main`之前这一段过程完成的，同样，其他基本类型的全局变量也是在这一段过程中完成初始化的。在`main`函数结束之后，会返回到`_start`中，进行一些清理工作（例如全局类的析构），然后再结束进程。

对此，ELF文件中有两个特殊的段：`.init`和`.fini`。在`.init`段中的代码，会在`main`函数之前执行，而在`.fini`段中的代码，会在`main`函数之后执行。

#### ABI（Application Binary Interface）

API（Application Programming Interface）是源码级别的接口，而ABI是二进制级别的接口。

与ABI相关的东西有很多，具体包括：**符号修饰标准，变量内存布局，函数调用方式等跟可执行文件二进制兼容性相关的内容。**同时，机器的硬件平台、编程语言、编译器、链接器、操作系统等都会影响到ABI，所以，ABI的标准化一直是一个大问题。不同目标文件的ABI不同的话，就不能相互链接起来。



#### BFD库

BFD全称Binary File Descriptor library，是GNU的一个项目，目的是为了处理不同的目标文件格式。

