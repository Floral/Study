# 程序员的自我修养

## 第二章

从源代码到可执行程序的整个过程，可以分为四步，分别是：**预编译，编译，汇编，链接**。

### 预编译

预编译主要是处理代码中的预编译指令，预编译指令都是以`#`开头的，形如`#define`、`#include`、`#ifdef`**等**，其中`#define`是直接文本替换；`#include`则是把include的文件直接复制到改行所在的位置；`#ifdef`是用来对部分代码是否需要编译进行控制的。长得像预编译指令的`#param`则会保留，因为这是给传递给编译器的指令。

PS：注释在预编译阶段会被全部删除。

### 编译

狭义的编译就是将源代码翻译为汇编代码的过程，至于为什么说狭义，因为我们平常说的编译，一般包括了后面的汇编和链接过程。

### 汇编

汇编就是把汇编语言转换为机器语言，这本质上是一个**查字典**的过程，因为每一条汇编语句都对应着唯一的机器码（不同ISA的CPU有着不同的字典）。

### 链接

在以前的单文件、小软件时代，由于符号（函数或变量）的定义和对它们的引用都是在同一个文件中，其地址很方便分配与确定，但是随着软件的大型化、模块化发展，一个软件的源代码文件有几十上百个（甚至上千上万），它们生成的目标文件也有几十上百个。在它们之间，符号定义和其引用关系很复杂，一个文件中定义的符号很可能被其他文件所引用，且文件之间存在相互引用，于是导致不能在编译阶段确定符号的地址，只能采用临时地址来暂时替代最终的实际地址。

具体的符号的地址在最后一步——链接过程完成，链接细致一点又可以分为**地址和空间的分配，符号决议，重定位**，这三个步骤。其中第一个过程看名字就很好理解；第二个过程则是链接器检查所有的目标文件中每一个符号的引用，确保它们有且仅有有唯一的定义；第三个过程则是对目标文件中不能确定的临时地址的修正，将其修改为分配完地址后的地址。



### 编译器的流程

现代编译器通常集成了上述四个功能。我们现在以编译一个单一源代码文件的流程来进一步分析编译的背后流程，主要分为6个步骤：词法分析，语法分析，语义分析，中间语言生成，目标代码生成，目标代码优化。

#### 词法分析

词法分析是将源代码输入到一个扫描器中，得到的结果是对代码中各种符号的识别分类，这里的符号包括：关键字，标识符，字面常量运算符等。为后续的语法分析奠定基础。

#### 语法分析

语法分析是检查你所写的代码是否符合语言的语法￼规定。

它利用词法分析得到的记号来生成语法树。语法树就是你此法分析中得到的各种为节点的、按照你所写的代码的表达式来组织的一种树状数据结构。这里的语义分析并**没有确定**各种记号的**具体**类别，例如变量a的类型到底是int还是float，只知道它是一个变量，假如有一句`b=array[a];`，**即使a实际是float类型，但是在语法分析阶段还是不会报错**，因为这一句满足变量作为下标这一个语法，这里检查出来有错误是下一步——语义分析的工作。

一个语法树的例子，以下是表达式`a=(b+4)*c;`的语法树：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20210120204442258.png" alt="image-20210120204442258" style="zoom:25%;" />

#### 语义分析

语义分析是检查你所写的代码表达式是否是具有正确的意义，例如你把一个浮点数用作数组的下标，这在语法上是正确的，因为满足下表示一个标识符这个语法，但是这种写法并没有正确的含义，因为数组的下标是不能用浮点数表示的。

#### 中间语言生成

中间语言生成是将源代码转换为一种，便于优化的表现形式（中间语言），一般有可以转为三地址码，P-代码等。并在这个过程中对代码进行一次优化。由于是从源码转换过来的，所以又称源码级优化。

#### 目标代码生成与优化

中间语言生成之后就进入到了**编译器后端**流程。其就是将中间语言代码转换为最终目标机器平台的机器语言代码（也就是0、1组成的bit流），同时进行优化。其实这个过程就包括了之前所说的汇编过程。





## 第三章 目标文件里有什么



目标文件就是源代码经过编译后的，链接之前的文件，经过链接就变成了可执行文件，它也是一种二进制文件。

目标文件的格式其实与最终的可执行文件的格式是一致的，只是没有经过符号的链接过程。

在Windows环境下，可执行文件的格式是PE（Portable Executable），在Linux环境下，可执行文件的格式叫ELF（Executable Linkable Format），这两种格式差别不大，都是源自于COFF（Common File Format）格式的。

### ELF文件

下面主要介绍一下ELF文件格式。

ELF文件下又可以分为4种类型：

- **可重定位文件（Relocatable File）**，包含代码和数据，一般是指静态链接库文件。
- **可执行文件（Executable File）**
- **共享目标文件（Shared Object File）**，也是一种可重定位文件，但是它可以被用于动态链接。
- **核心转储文件（Core Dump File）**，进程意外终止的时候，系统把进程地址空间的内容和一些其他信息存放到核心转储文件中，可以用于排除BUG。



一个目标文件/可执行文件的基本组成部分都是段（Segment/Section），段就是把一个程序的不同部分分类存放，形成不同的段，一个目标文件最基本的段包括：

- **代码段（程序段）`.text`**，代码段就是存放程序的逻辑代码部分。
- **数据段`.data`**，用于存放变量数据，但是这里存放的是**已初始化**的全局/静态变量。
- **BSS（Block Started by Symbol）`.bss`**，BSS段则是为**未初始化**的全局变量和局部的静态变量，为他们预留位置，BSS段的起源是一个历史原因，同时也可以节省目标文件占用的空间。



那么有人会问，那局部变量存放在哪呢？**局部变量**是存放在进程地址空间中的**栈**里，因为局部变量的生命周期是临时的一个函数调用期，而全局变量/静态变量的生命周期是整个程序运行期间，所以我们将全局/静态变量放在进程中单独的一个段里。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20210122183320332.png" alt="image-20210122183320332" style="zoom: 25%;" />

<center>目标文件的3个基础段</center>

> PS：段名都是以小数点`.`开头的。
>
> PPS：有的编译器不会直接把未初始化的全局变量放在bss段中（即在bss段中分配确定大小的空间），而是会将其标记为一个COMMON符号，等到最后链接成可执行文件后才确定大小，在bss段中分配空间。例如这个程序的bss段大小就为4个字节，而不是8个字节，因为`global_uninit_var`并没有直接在bss段中分配空间，具体原因涉及到后面的弱符号和COMMON块。

同时，目标文件的最开始包含一个ELF文件头（ELF Header），它用来说明整个ELF文件各种信息，包括：是否可执行，是静态链接还是动态链接，入口地址（如果是可执行文件），目标硬件，以及**段表（Section Header Table）**的位置（文件位置偏移）等。这里的段表是一个重要的部分，它本质是一个数组，用来描述ELF文件中各个段的信息（名字、偏移and其他信息）。

目标文件中除了有各种“段”，还有各种“表”，上面说的段表就是一个，除此之外还有重定位表（Relocation Table）、字符串表（String Table）、符号表（Symbol Table）等等。每一个表也是通过段的形式存储在目标文件中的。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20210122181949194.png" alt="image-20210122181949194" style="zoom:25%;" />

<center>ELF文件结构</center>

每一个需要重定位的段（例如代码段、数据段），都会有一个对应的重定位表，用来描述该段中需要重定位的引用的信息。

字符串表是将程序中所用到的变量名、段名等字符串集中起来放在一个段里，通过偏移量来表示字符串的。

符号表就是用来存放代码中用到的各种符号（函数名或变量名）的信息。符号一般分为全局符号、局部符号、段名、行号等。这里的全局符号（全局变量、非static函数）不仅包括定义在本文件中的全局符号，也包括引用其他文件中定义的全局符号，局部符号则是仅本文件内部可见的符号（主要是局部变量，还有static的变量和函数）。**链接过程处理的就是全局符号**。

### 符号

#### 符号修饰问题

> 一个讲的比较好的blog：https://www.cnblogs.com/wfwenchao/articles/4140388.html

在“远古时代”，编译后目标文件中的符号名与源代码中的符号名是一致的，随着软件工程的发展，就出现了一个问题：一个软件可能由多个人共同开发完成，如果他们没有对各自负责的模块中的变量、函数命名进行沟通及规范的话，很可能会造成符号重复的问题，即，不同模块中不同功能的函数名（或全局变量名）可能是一样的，或者是开发者写的函数名与所用到的库中的某一个函数撞名了，那么链接器在符号决议过程中就会冲突报错。

为了解决这个问题，现在的编译器一般会把源代码中的符号，经过一种修饰的规则修饰之后放入目标文件中，称为**符号修饰（Name Decoration）或符号改编（Name Mangling）**，不同的C++编译器对符号的修饰规则是不一样的（例如GNU的g++和微软的Visual C++编译器）。

有了符号修饰这个机制，就能很好地实现函数重载这类机制了，因为修饰机制一般会区分开同名函数的不同参数列表。同时，命名空间也是为了解决符号冲突而引入的一种机制。

一个函数对应一个唯一的**函数签名（Function Signature）**，函数签名包括了确定一个函数需要的所有信息，例如：函数名、参数列表、命名空间等。一个函数签名对应一个修饰后的符号名称（Decorated Name）。

由于C和C++的修饰规则并不一样，所以为了在C++程序中使用C的修饰规则，我们可以使用`extern "C"`这个关键字来声明符号，例如：`extern "C" double a;`，那么编译器就会对变量a使用C语言的修饰规则。



#### 强符号or弱符号、强引用or弱引用

> 一个讲的比较好的blog：https://www.cnblogs.com/downey-blog/p/10470674.html

##### 强符号和弱符号

强符号和弱符号是针对定义来说的，在C/C++语言中，已初始化的全局变量是一种强符号，未初始化的则是弱符号。在符号决议的过程中如果发现了多个同名的强符号**定义**，那么就会报错；如果有一个强符号定义以及一些弱符号定义，则不会报错，且强符号定义会覆盖弱符号定义；如果没有强符号定义，只有弱符号定义，那么会选择占用空间最大的那个（例如double类型比int型占用的字节大）。

我们也可以手动定义一个初始化的强符号，只需使用`__attribute__((weak))`关键字，例如：`__attribute__((weak)) int weak2 = 2;`，不过这样手动定义的弱符号不能和强符号共存。

**弱符号的一个用处是：在库中的定义是弱符号，用户可以重新定义一个自己使用的同名强符号，使得其覆盖库中版本，使用用户自定义版本的库函数的作用。**

##### 强引用和弱引用

一般没有特殊声明的**引用**都是强引用，如果一个强引用在链接的符号决议过程中没有找到定义，链接器会报符号未定义的错误。而弱引用在没有找到定义时则不会报错，链接器会用0或者一个特殊的值代替。

将一个符号的引用声明为弱引用需要用到`__attribute__((weakref))`这个关键字，例如：`__attribute__((weakref)) foo()`，就是声明了一个名为foo的弱引用函数。当然，为了避免弱引用没有定义就使用，在使用前最好用if判断一下foo是否是0。

**弱引用一个重要的作用就是，使得程序的不同功能模块更容易地裁剪和组合。**



## 第四章 静态链接

所谓静态链接，就是在链接阶段把所有参与链接的目标文件合并到一个最终的可执行文件中。有静态就有动态，后面会讲的动态链接就是链接过程中只是指明了主程序在运行时需要哪些动态链接库（模块），最终链接得到的可执行文件并没有包含所有模块的代码，而是在运行过程中会动态地加载那些模块。



### 静态链接的过程

从目标文件到最终的可执行文件，主要分为两步：

1. **空间与地址分配**，这里的空间指的是目标文件的段在可执行文件中的空间位置，地址指的是每一条指令的虚拟地址，此步骤完成后就能确定目标文件中全局符号在可执行文件中的实际位置（虚拟地址），为第2步做准备。
2. **符号解析与重定位**，即根据重定位表的信息和第1步得到的全局符号地址对引用位置的地址进行更新。

#### 空间与地址分配

从前面的章节可以知道，每一个目标文件都是许多段组成的，要把许多目标文件这么多不同的段合并到最终的可执行文件里，一个很自然的想法就是把不同文件中的同一种段（.text或.data或其他的）合并成一个段，实际采用的就是这种方案。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/4-1%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" alt="4-1空间分配策略" style="zoom: 33%;" />

<center>图4-1 实际的空间分配策略</center>

在合并的过程中，链接器会把所有的目标文件的符号表收集起来，组成一个新的全局符号表，为后续的符号解析和重定位做准备。

将段合并之后，就可以得到各个符号在可执行文件的段中的位置（偏移）与分配的虚拟地址（VMA）了。

> 这里讲一下虚拟地址（VMA）和加载地址（LMA）。
>
> 对于每一个进程，在操作系统（OS）中都有一个独立的假想的地址空间，我们称之为虚拟地址空间，虚拟地址空间可以起到隔离不同进程的作用。
>
> 现代的可执行文件中，使用的都是虚拟地址空间中的地址，在加载到物理内存的过程中，还需要经过一个地址转换的硬件模块（MMU），将虚拟地址转换为物理地址。
>
> PS：如果没有MMU的支持，那么目标文件中的虚拟地址就等于物理地址。
>
> 加载地址，对于普通的PC机，即是把程序从硬盘中加载到内存中之后的地址，一般来说加载地址与虚拟地址是相同的（即加载到哪就在哪运行），除了嵌入式的特例（自行百度）。



#### 符号解析与重定位

所谓符号解析，就是查找合并后文件中的段中引用的全局符号的定义（即找到定义的虚拟地址），这个步骤依赖的是全局符号表。

重定位就是修正指令中引用符号的地址，利用的是重定位表，重定位表的每一项对应一个需要修正的位置的偏移（每一个需要重定位的地方叫做**重定位入口**），同时包含修正方法的类型以及该符号在符号表中的地址。

修正方法的类型总的可以分为**绝对地址修正**和**相对地址修正**两类。

以下是每个重定位入口对应的包含重定位需要的信息的数据结构：

```c
typedef struct{
    int offset;  	// 需要被修改的引用的段偏移(重定位入口地址)
    int symbol:24, 	// 重定位入口的符号在符号表中的下标
        type:8;   	// 修改方式
}ELF32_REL;
```

重定位段（表）的内容就是一个该数据结构的数组。

### 静态库链接

静态库就是一系列编译好的还未链接的目标文件的集合（通过ar打包），一般是一个库函数对应一个目标文件，因为这样可以实现用到什么函数就链接什么函数，不会附带把不需要的函数链接到可执行文件中，从而节省了空间。

这里也有张图.jpg

### 链接过程控制

链接控制过程有两种方式：

1. 命令行参数式
2. 链接脚本式

链接脚本的方式灵活性很强，甚至可以自定义段名。在进行嵌入式或无操作系统的平台开始时，通常会用这种方式来控制可执行文件的段的分布，以满足硬件的要求。

### COMMON块

在链接之前的目标文件中，未初始化的全局变量会被标记为COMMON类型，且不会直接在`.bss`段中分配空间，为什么呢？

本质原因是链接器不能区分符号的类型，无法判断若符号的类型是否一致，导致弱符号的占用空间在链接前不能确定（强符号和弱符号那一节中讲过）。



### C++相关问题

主要有两个问题：

1. 重复代码消除
2. 全局对象的构造和析构

#### 重复代码消除

这里要消除的代码主要是由C++的模板机制、外部内联函数、虚函数表等造成的冗余。以模板为例，如果在不同的源代码文件（编译单元）中可能对同一个模板`add<T>()`进行了实例化，且实例化参数相同`add<int>()`，那么就会在不同目标文件中生成相同的实例化代码，如果直接合并的话，就会造成冗余。

解决的方法是对每一个实例化后的模板，将其单独存在在目标文件中的一个段中，这个段的名字是该实例化模板修饰后的名称（例如：`.temp.add<int>`），保证了唯一性，于是不同目标文件中的同一种实例化模板就能被检查出来，在合并的时候只需保留一个段就行。

**函数级链接**

函数级别链接，就是把每一个函数都单独地放到一个段里，链接器检测到用到了哪个函数就链接相应的段，没有用到的不会被链接到最终的文件里，与前面的静态库链接差不多。其目的也是为了减小最终的文件大小。

#### 全局对象的构造和析构

在最终的可执行文件中，真正的程序入口是`_start`（Linux系统下），在这个函数中进行进程初始化工作，然后在其中调用`main`函数，进入到用户定义的主程序。全局类的构造就是在进入`main`之前这一段过程完成的，同样，其他基本类型的全局变量也是在这一段过程中完成初始化的。在`main`函数结束之后，会返回到`_start`中，进行一些清理工作（例如全局类的析构），然后再结束进程。

对此，ELF文件中有两个特殊的段：`.init`和`.fini`。在`.init`段中的代码，会在`main`函数之前执行，而在`.fini`段中的代码，会在`main`函数之后执行。

### ABI（Application Binary Interface）

API（Application Programming Interface）是源码级别的接口，而ABI是二进制级别的接口。

与ABI相关的东西有很多，具体包括：**符号修饰标准，变量内存布局，函数调用方式等跟可执行文件二进制兼容性相关的内容。**同时，机器的硬件平台、编程语言、编译器、链接器、操作系统等都会影响到ABI，所以，ABI的标准化一直是一个大问题。不同目标文件的ABI不同的话，就不能相互链接起来。



### BFD库

BFD全称Binary File Descriptor library，是GNU的一个项目，目的是为了处理不同的目标文件格式。





## 第五章 Windows PE/COFF

Windows下的可执行文件格式为PE（Portable Executable），与ELF格式同根同源，都是COFF（Common Object File Format）格式的一种扩展。所以它们之间基本结构相同，下文主要说明它两之间的差异。

我们可以用dumpbin查看obj文件的信息，输入`/ALL`参数可以查看所有相关信息：

`dumpbin /ALL SimpleSection.obj > SimpleSection.txt`

### PE的前身COFF文件



<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/5.2-COFF%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="5.2-COFF目标文件格式" style="zoom: 33%;" />

<center>图5-1 COFF目标文件格式</center>

COFF与之前介绍的ELF文件的一个主要不同就是，COFF的头文件包括两部分，一个是映像头（Image Header），类比ELF中的文件头，描述文件的总体结构和属性；第二个是段表（Section Table），而在ELF中，段表不是紧挨着文件头的。这个结构是一个数组结构，数组大小等于段的数量。

> 映像（Image）：因为PE文件在装载时被直接映射到进程的虚拟空间中运行，它是进程的虚拟空间的映像。所以PE可执行文件也被称为**映像文件（Image File）**

COFF文件的映像头对应的数据结构是`_IMAGE_FILE_HEADER`，书上说定义在`VC\PlatformSDK\include\WinNT.h`中，不过这应该是在作者那个年代的VC版本，我在自己电脑上的Visual Studio 2019 community的目录找了一下，并没有找到。该文件在win10下的目录应该是`C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\um\`（版本号可能有所不同），前提是你安装了Windows SDK，文件名为`winnt.h`，数据结构定义如下：

```c++
typedef struct _IMAGE_FILE_HEADER {
    WORD Machine;
    WORD NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD SizeOfOptionalHeader;
    WORD Characteristics;
} IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;
```

这些字段的含义看命名应该很容易理解，知道有这些东西就行，具体需要用到的时候再百度。

同时，段表对应的数据结构定义为`_IMAGE_SECTION_HEADER`，也位于`winnt.h`文件中。

```c++
typedef struct _IMAGE_SECTION_HEADER {
    BYTE Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
    } Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;
```

字段含义就不说了，理由同上，不过有一个点需要说一下，就是`SizeOfRawData`字段指的是该段在文件中的大小，而`VirtualSize`则是该段被加载到内存后的实际大小，这两个大小可能会不一样，且往往是前者比后者小。例如，bss段的`SizeOfRawData`为0，而`VirtualSize`则为bss段所含数据的大小。

### 链接指示信息

> COFF中`.drectve`段的内容是编译器传递给链接器的指令（Directive），即编译器希望告诉连接器该怎样链接这个目标文件。



### 调试信息

COFF中所有以`.debug`开头的段都包含着调试信息，例如`.debug$S`包含的是符号（Symbol）相关的调试信息；`.debug$P`包含的是预编译头文件（Precompile）相关的调试信息；`.debug$T`包含的是类型（Type）相关的调试信息。



### 符号表

dumpbin输出的最后一部分是COFF的符号表，总共有6列，从左到右依次是：符号编号、符号所表示的对象所占空间、符号所在位置、符号类型、符号可见范围、符号名（修饰后和修饰前）。

```
COFF SYMBOL TABLE
000 010471B7 ABS    notype       Static       | @comp.id
001 80000191 ABS    notype       Static       | @feat.00
002 00000000 SECT1  notype       Static       | .drectve
    Section length   18, #relocs    0, #linenums    0, checksum        0
004 00000000 SECT2  notype       Static       | .debug$S
    Section length   B8, #relocs    0, #linenums    0, checksum        0
006 00000000 SECT3  notype       Static       | .data
    Section length    C, #relocs    0, #linenums    0, checksum AC5AB941
008 00000000 SECT3  notype       External     | _global_init_var
009 00000004 UNDEF  notype       External     | _global_uninit_var
00A 00000000 SECT4  notype       Static       | .text$mn
    Section length   4E, #relocs    5, #linenums    0, checksum CC61DB94
00C 00000000 UNDEF  notype ()    External     | _printf
00D 00000000 SECT4  notype ()    External     | _func1
00E 00000020 SECT4  notype ()    External     | _main
00F 00000004 SECT3  notype       Static       | $SG6034
010 00000008 SECT3  notype       Static       | ?static_var@?1??main@@9@9 (`main'::`2'::static_var)
011 00000000 SECT5  notype       Static       | .bss
    Section length    4, #relocs    0, #linenums    0, checksum        0
013 00000000 SECT5  notype       Static       | ?static_var2@?1??main@@9@9 (`main'::`2'::static_var2)
014 00000000 SECT6  notype       Static       | .chks64
    Section length   30, #relocs    0, #linenums    0, checksum        0
```

第三列的ABS表示对象所占空间，SECTx表示对象定义在第x个段，UNDEF表示符号在本文件中未定义，被定义在其他文件。

第四列的notype表示变量和其他符号类型，notype()则表示函数类型。

第五列的Static表示符号是局部变量，仅在本目标文件内可见，External则是全局可见的，可被其他目标文件引用。



### Windows下的ELF——PE

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/5.6-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="5.6-PE文件格式" style="zoom:33%;" />

<center>图5-2 PE文件格式</center>

PE文件在COFF的格式基础上，又有一些变化：

首先文件开头添加了DOS MZ可执行文件格式的文件头和桩代码（DOS MZ File Header and Stub）；第二，COFF的`IMAEG_FILE_HEADER`扩展为了`IMAGE_NT_HEADER`，其中添加了`IMAGE_OPTIONAL_HEADER32`部分。

之所以要添加DOS MZ相关的头文件和桩代码，是为了使为Windows编写的程序能“兼容”原有的DOS系统，以至于在DOS系统下不会被执行而导致错误。

其中`IMAGE_DOS_HEADER`的定义如下：

```c++
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```

其中`e_magic`这个字段是“魔数”，简单来说就是用来区分不同文件类型的，详细可以看：https://zh.wikipedia.org/wiki/%E9%AD%94%E8%A1%93%E6%95%B8%E5%AD%97_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)，PE的该字段包括“MZ”这两个字母的ASCII码。

其他字段中最重要的就是`e_cs`和`e_ip`这两个了，这两个字段的值指向程序的入口地址。

在DOS系统下运行PE文件，会因为魔数而检测到PE文件是一个“MZ”格式的文件，然后开始读取`e_cs`和`e_ip`的值准备执行，但其本质还是PE文件，且PE文件中这两个字段指向的并不是真正的程序入口地址，而是指向`DOS Stub`的起始位置，`DOS Stub`是可以在DOS下运行的一小段代码，这段代码唯一的作用是向终端输出一行字符串：“This program cannot be run in DOS”，然后就退出程序，这样就防止了在DOS下执行PE可能导致的错误。

`IMAGE_OPTIONAL_HEADER32`字面上是可选的，但实际上对于PE来说，是必须的，因为其中包含了很多对于PE执行来说重要的信息，比如`DataDirectory`。但是我们不必熟知，用到的时候再查即可，具体结构就不展示了。

### PE 数据目录

数据目录是一个数据结构——`_IMAGE_DATA_DIRECTORY`，定义为：

```c++
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
```

这个数据结构描述了PE文件中其他数据结构（如导入表、导出表、资源表、重定位表等）的虚拟地址和大小。

上一节最后的可选头文件中就包含了一个数据目录的数组，每一个元素对应一个表，以让系统很方便的找到所要用的表。





## 第六章 可执行文件的装载与进程

在讲装载之前，我们首先要了解程序和进程的区别，我用一种不严谨的说法来一句话解释：硬盘中的程序被装载到内存中就变成了进程。

> 程序（狭义上是可执行文件）是一个静态概念，它是一些预先编译好的指令和数据的集合的一个文件；进程则是一个动态的概念，它是程序运行时的一个过程，或者讲，一个正在运行的程序。很多时候把动态库叫做运行时（Runtime）就有这种含义。
>
> 有一个很形象的比喻就是，程序是一个大厨做菜时的菜谱，计算机的CPU相当于这个大厨，相关的厨具就是计算机的其他硬件，整个做菜的过程就是一个进程。

所谓装载，就是把存储在硬盘等介质内的程序（指令和数据），加载到内存中的某个位置，然后才能由CPU执行。这是由传统的冯·诺伊曼结构的所决定的（学过计组的都懂）。

### 6.1 进程虚拟地址空间

现代计算机系统的内存中，可以同时存在许多进程，为了防止这些进程在运行的过程中相互干扰，同时也可以防止恶意程序（病毒）对其他进程的破坏，操作系统（OS）中的每个进程都有自己独立的**虚拟地址空间（Virtual Address Space）**。虚拟地址空间的大小由CPU的地址总线的位数决定，32位的为4G，64位就有很多很多了（多到目前为止可以看作是无限的）。

本书的讨论都是在32位的环境下。

无论是Windows还是Linux下，一个进程的4G虚拟地址空间的主要分为两部分：操作系统部分和用户进程部分。为什么操作系统也要在用户进程的虚拟地址空间中占用一部分空间？我的想法是，因为要保证用户进程在操作系统的监控之下运行，因为不同进程间的虚拟地址空间是相互独立的，如果OS（OS是一个特殊的进程）独立于用户进程，那么OS就没法对该进程进行监控了，该用户进程也不能调用OS的系统调用了（以上来自于一个没有系统学过OS的人的“猜想”）。

Linux默认占用1G的虚拟地址空间，Windows默认占用2G，不过可以通过修改`Boot.ini`文件来修改Windows占用的空间。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6.1-Linux%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83.png" alt="6.1-Linux进程虚拟空间分布" style="zoom: 33%;" />

<center>图6-1 Linux进程虚拟空间分布</center>



#### PAE

在32位时代，为了扩大可用的内存空间，有些厂商把CPU的地址总线位数进行了扩展（使之超过CPU数据总线的位数），例如：Intel 1995年的Pentium Pro CPU开始采用了36位的物理地址，但它本身是一个32位的CPU。

那么如何利用这些高于32位地址空间的内存呢？Intel是通过修改页映射的方式来实现的，这种地址扩展方式就成为**PAE（Physical Address Extension）**，因为是物理上扩展了地址空间。

> 一个常见的实现就是OS提供一个窗口映射的方法，把额外的内存映射到进程地址空间来。应用程序可以跟据需要来选择申请和映射，比如一个应用程序中的`0x10000000~0x20000000`这一段256MB的虚拟地址空间作为**窗口**，程序可以从高于4GB的物理空间中申请多个大小为256MB的物理空间，并依次编号，如：A、B、C。然后可以根据需要将窗口映射到不同的空间去，例如需要用到A块中的内容是，就把窗口对应的地址映射到A的实际物理地址，然后就可以通过访问窗口范围的地址来访问A块中的地址了，同理，需要用到B中的内容是，可以将窗口映射到B块。在Windows下，这种操作方式叫做**AWE（Address Windowing Extensions）**。

### 6.2 装载的方式

最简单的装载就是一次性把程序的所有内容都装载到内存中，可是内存空间是极为珍贵的，很多时候并不能满足程序的要求。同时，跟据程序运行的局部性原理，我们可以只把程序的一部分留在内存中，其他部分放在硬盘中，等用到的时候再装入内存，这就是**动态装载**的基本原理。

动态装载的常用方法有两种：**覆盖装入（Overlay）**和**页映射（Paging）**。

#### 覆盖装入

覆盖装入在虚拟存储发明之前使用得比较广泛，现在几乎被淘汰了，因为它比较的使用很麻烦，需要由程序员自己写一个**覆盖管理器（Overlay Manager）**，来管理程序不同部分（模块）的装载。

> 在多个模块的情况下，需要程序员手动将模块按照他们之间的调用关系组织成树状结构（如图）。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6-2%20%E8%A6%86%E7%9B%96%E8%A3%85%E5%85%A5%E8%B0%83%E7%94%A8%E6%A0%91%E7%8A%B6%E5%9B%BE.png" alt="6-2 覆盖装入调用树状图" style="zoom: 33%;" />

<center> 6-2 覆盖装入调用树状图</center>

图中，同一高度代表同一内存地址，所以有重叠的模块是不能同时存在的。树中的子节点（模块）是依赖于父节点的，也就是说子节点存在于内存中的时候，父节点也要存在。

这也就引出了这种方法所需要注意的两个问题：

1. 一个模块的调用路径（也就是从树根main模块，到这模块上的所有途经模块所构成的路径）都必须在内存中，才能保证程序的依赖关系
2. 跨树间的调用是被禁止的。因为跨树会导致模块的内存重叠冲突，不同的路径不能同时存在于内存中。



#### 页映射

页映射是虚拟存储机制的一部分。它的原理就是把可执行文件和内存空间都分为许多大小一致的“页”（Intel IA32的页是4KB），当进程运行到某一部分的代码不存在于内存中时，就发生“缺页中断”，把需要的页加载到内存中。同时，如果内存的页都被占满了，这时我们需要选择一个页被替换掉，选择的方法有许多，例如：FIFO、LUR等页替换算法。

在这种方法中，OS就充当着覆盖管理器的角色，更具体的说，是OS的存储管理器。



### 6.3 从操作系统的角度看可执行文件的装载

从操作系统的角度来看，可执行文件的装载主要包含两个大的操作：

1. 进程的建立
2. 页错误

#### 6.3.1 进程的建立

创建一个进程分为三步：

1. 创建一个独立的虚拟地址空间
2. 读取可执行文件头，并建立虚拟空间与可执行文件的映射关系
3. 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行

> **创建虚拟地址空间** 一个虚拟空间由一组页映射函数**将虚拟空间的各个页映射至相应的物理空间**，那么创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。
>
> **读取可执行文件头，并建立虚拟空间与可执行文件的映射关系** 第一步完成的是虚拟空间到物理空间的映射关系，而这一步完成的是虚拟空间与可执行文件之间的映射。是装载过程中最重要的一步。
>
> Linux中把虚拟进程空间中的一个连续的地址空间叫做**虚拟内存区域（VMA，Virtual Memory Area）**，Windows中叫做虚拟段（Virtual Section）。一般一个VMA一半对应一个段（一个或多个页）。
>
> https://baike.baidu.com/item/VMA/9839255
>
> **将CPU的指令寄存器设置成可执行文件的入口地址，启动运行** 这一步是最简单的一步，它将CPU的控制权由OS转交给进程，由此进程开始执行。



#### 6.3.2 页错误

完成上面的步骤，程序其实还没有被装载到内存中，因为只是建立了映射关系，并没有真正映射。

当CPU执行到程序的入口地址（以0x8048000这个虚拟地址为例），发现这个页并没有被加载到物理内存中（通过一个数据结构可得到这个信息），于是就产生一个“页错误（Page Fault）”，引发缺页中断，CPU的控制权转交给OS，由OS分配一个物理页，建立映射关系，将缺少的页加载到该物理页中，然后将CPU的控制权交还给进程，继续执行。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6.3-%E9%A1%B5%E9%94%99%E8%AF%AF.png" alt="6.3-页错误" style="zoom:33%;" />

<center>图6-3 页错误发生后</center>



### 6.4 进程虚存空间分布

#### 6.4.1 ELF文件链接视图和执行视图

现代OS的装载过程实际采用的是页映射的方式，也就是以页为单位装载指令和数据的，所以存在一个页地址对齐的问题。也就是不同段（Section）映射到虚拟内存空间或实际物理空间的时候，占用的空间必须是页大小的整数倍（起始地址也是）。

但是随着可执行文件中段的数量不断增多（特别是ELF，一个ELF往往有十几个段），就会产生内存碎片的问题，有许多段本身或者末尾实际仅仅使用了一个页的一小部分，造成了极大的浪费。

解决的方案就是，尽可能合并这些段（合并后的称为Segment），然后**将合并后的Segment作为一个整体映射到虚拟内存空间和实际物理空间，并且一个Segment对应一个VMA（Virtual Memory Area）**。这里的Segment翻译过来其实也称为段，只不过是在装载过程中的段，在讨论装载的情况下，段这个字一般都指的是Segment。

那按照什么来合并呢？总不能一股脑儿地把所有段都合并了吧，这样不利于程序内部的结构划分。

ELF采用的方案是**把具有相同权限（读、写、执行）的段合并成一个Segment**，ELF中主要的段的权限组合不多，主要有3种：

> - 以代码段为代表的权限为可读可执行的段
> - 以数据段和BSS段为代表的权限为可读可写的段
> - 以只读数据段为代表的权限为只读的段

ELF中描述Segment的结构叫做**程序头（Program Header）**，很容易与之前说过的段表（Section Header Table）弄混。

我们用readelf查看如下程序的程序头，得到如下结果：

```sh
doa@LAPTOP-DOA:~/Document$ readelf -l SectionMapping.elf
Elf file type is EXEC (Executable file)
Entry point 0x401bc0
There are 10 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000518 0x0000000000000518  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x00000000000935dd 0x00000000000935dd  R E    0x1000
  LOAD           0x0000000000095000 0x0000000000495000 0x0000000000495000
                 0x00000000000265f5 0x00000000000265f5  R      0x1000
  LOAD           0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000005170 0x00000000000068c0  RW     0x1000
  NOTE           0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000020 0x0000000000000020  R      0x8
  NOTE           0x0000000000000290 0x0000000000400290 0x0000000000400290
                 0x0000000000000044 0x0000000000000044  R      0x4
  TLS            0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000000020 0x0000000000000060  R      0x8
  GNU_PROPERTY   0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000020 0x0000000000000020  R      0x8
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000002f40 0x0000000000002f40  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt
   01     .init .plt .text __libc_freeres_fn .fini
   02     .rodata .stapsdt.base .eh_frame .gcc_except_table
   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs
   04     .note.gnu.property
   05     .note.gnu.build-id .note.ABI-tag
   06     .tdata .tbss
   07     .note.gnu.property
   08
   09     .tdata .init_array .fini_array .data.rel.ro .got
```

> 所以总的来说，“Segment”和“Section”是从不同角度来划分同一个ELF文件，这个在ELF中被称为不同的**视图（View）**，从“Section”的角度来看ELF文件就是**链接视图（Linking View）**，从“Segment”的角度来看就是**执行视图（Execution View）**。

#### 6.4.2 堆和栈

在OS中，VMA除了被用来映射可执行文件中的各个Segment，OS还通过使用VMA来对进程的地址空间进行管理。例如进程在运行时还需用到的**堆（Heap）**和**栈（Stack）**等空间，他们在虚拟内存空间中的表现形式也是VMA。

在linux下，可以通过查看`/proc`来查看进程的虚拟空间分布：

```shell
doa@LAPTOP-DOA:~/Document$ cat /proc/184/maps
00400000-00401000 r--p 00000000 00:00 963148                     /home/doa/Document/SectionMapping.elf
00401000-00494000 r-xp 00001000 00:00 963148                     /home/doa/Document/SectionMapping.elf
00494000-00495000 r-xp 00094000 00:00 963148                     /home/doa/Document/SectionMapping.elf
00495000-004bb000 r--p 00095000 00:00 963148                     /home/doa/Document/SectionMapping.elf
004bb000-004bc000 r--p 000bb000 00:00 963148                     /home/doa/Document/SectionMapping.elf
004bd000-004c0000 r--p 000bc000 00:00 963148                     /home/doa/Document/SectionMapping.elf
004c0000-004c3000 rw-p 000bf000 00:00 963148                     /home/doa/Document/SectionMapping.elf
004c3000-004c4000 rw-p 00000000 00:00 0
006ed000-00710000 rw-p 00000000 00:00 0                          [heap]
7fffe2ba2000-7fffe33a2000 rw-p 00000000 00:00 0                  [stack]
7fffe33da000-7fffe33db000 r-xp 00000000 00:00 0                  [vdso]
```

其中最后两列分别指映像文件的节点号和路径。

向堆和栈这种没有指定特定的映像文件的VMA通常称为**匿名虚拟内存区域（Anonymous Virtual Memory Area）**。每个线程都有自己的堆和栈，C语言中使用malloc()内存分配函数就是分配堆中的内存。
可以看到其中还有一个非常特殊的VMA叫做`[vsdo]`，实际上它是OS内核的一个模块，进程可以通过访问这个VMA来跟内核进行通信。

> 进程虚拟地址空间的概念：操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的，有相同映像文件的映射成一个VMA，一个进程基本上可以分为如下几种VMA区域：
>
> - 代码VMA，权限只读、可执行；有映像文件
> - 数据VMA，权限可读写、可执行；有映像文件
> - 堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展
> - 栈VMA，权限可读写、不可知性；无映像文件，匿名，可向下扩展

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6.4-ELF%E4%B8%8ELinux%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" alt="6.4-ELF与Linux进程虚拟空间映射关系" style="zoom: 33%;" />

<center> 图6-4 ELF与Linux进程虚拟空间映射关系</center>



#### 6.4.3 堆的最大申请数量

略

#### 6.4.4 段地址对齐

前面我们说到为了节省由于页对齐产生的内存碎片，而想出和并为Segment的方法。但这并不能满足人类贪婪的欲望，即使是只剩三个Segment了，还是有很大可能多浪费了两个页，为了节省这两个页，我们需要进一步“合并”Segment，**但这种合并与之前的合并为Segment并不一样！！！合并为Segment是在虚拟地址空间和物理空间两个地方都进行合并，而将Segment合并仅仅是在物理空间合并，在虚拟地址空间中的操作是将两个Segment交接处所在的页映射两次。**这么说可能有些抽象，上图：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6.5-ELF%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6%E6%83%85%E5%86%B5.png" alt="6.5-ELF文件合并情况" style="zoom: 33%;" />

<center>图6-5 ELF文件段合并情况</center>

至于为什么虚拟地址空间中不直接合并，我个人的猜想是因为OS层面访问的都是虚拟地址，OS需要区分不同的Segment以判断权限（因为内存权限的最小粒度是页），所以不同Segment在虚拟地址空间中不能在一个页中有交集，否则虚拟地址空间中的同一个页的权限会有冲突。

如果按照正常的映射方式，3个段（SEG0、SEG1、SEG2）应该分别占用1、3、1个Page（物理内存中），总共占用5个，如下图：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6.6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%AE%B5%E6%9C%AA%E5%90%88%E5%B9%B6%E6%83%85%E5%86%B5.png" alt="6.6-可执行段未合并情况" style="zoom: 33%;" />

<center>图6-6 可执行文件段未合并情况</center>

### 6.5 Linux内核装在ELF过程简介

> 在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定的ELF文件，是原先的bash进程继续返回等待各个启动的新进程结束，然后继续等待用户输入命令。

剩下的用到再查（狗头

### 6.6 Windows PE的装载

> PE与ELF不一样，PE可执行文件的段的数量一般很少，这是因为链接器在产生可执行文件的时候就尽可能地把段合并，最后一般只剩下代码段、数据段、只读数据段和BSS等为数不多的几个段。
>
> PE中有一个很常见的术语叫做RVA（Relative Virtual Address），其实就是相当于文件中的偏移量。它是相对于PE文件的装载机地址的偏移地址。比如一个PE文件被装载到虚拟地址（VA）0x00400000，那么一个RVA为0x1000的地址就是0x00401000。
>
> 每个PE文件在装载**目标地址（Target Address）**，这个地址就是**基地址（Base Address）**。因为PE文件可以被装载到任何地址，所以这个及地址不是固定的，每次装载时都会变化。
>
> 装在一个PE可执行文件的过程：
>
> - 读取文件的第一个页，在这个页中包含了DOS头、PE文件头和段表
> - 检查进程虚拟地址空间中，目标地址是否可用，如果不可用，则选另外一个装在地址。这个问题对于可执行文件来说基本不存在，因为它往往是进程第一个装载的模块，所以目标地址不太可能被占用。这里主要是针对DLL文件的装载而言的，后面还有“Rebasing”这一节会具体介绍这个问题。
> - 使用段表中提供的信息，将PE文件中所有的段一一映射到地址空间中的相应位置。
> - 如果装载地址不是目标地址，则进行Rebasing。
> - 装载所有PE文件所需要的DLL文件
> - 对PE文件中的所有导入符号进行解析
> - 跟据PE头中指定的参数，建立初始化栈和堆。
> - 建立主线程并启动进程。

PE文件中，与装载有关的主要信息都包含在PE扩展头（PE Optional Header）和段表中了。





## 第七章 动态链接

### 7.1 为什么要动态链接

首先，要明确一个问题：**为什么要用动态链接？静态链接这么简单好用，不香吗？**

主要出于以下两个原因：

- 静态链接会造成硬盘与内存的空间浪费
- 静态链接程序的更新困难



第一个问题：

因为，静态链接是在链接的时候就把程序依赖的所有目标文件都合并到最终的可执行程序里，而一个程序往往会用到许多公共的目标文件（库），例如C语言标准库（`stdio.h`、`stdlib.h`等）。如果计算机中的每个程序都包含C语言标准库的目标文件，那么以当今计算机中程序的数量来看，你的硬盘空间是大概率不够的。同时，静态链接的程序是被整体加载到内存中的，因此，当多个程序都被加载到内存中，它们所包含的标准库部分也会被重复加载许多次，这就造成了内存空间的极大浪费，以今计算机操作系统中运行的程序数量来看，你有限的内存大小也是顶不住的。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/7.1-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E6%97%B6%E6%96%87%E4%BB%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%89%AF%E6%9C%AC.png" alt="7.1-静态链接时文件在内存中的副本" style="zoom: 25%;" />

<center>图7.1 静态链接时文件在内存中的副本</center>

第二个问题：

如果一个程序（假设是`Program1`）使用的一个第三方公共目标文件（假设是`Lib.o`）进行了更新，那么`Program1`需要进行重新链接，再发布给用户，用户需要重新下载整个程序，如果这个程序用了100个模块（目标文件、库），每个假设是1MB，整个程序100MB，那么即使每次只改动了某个模块的一个地方，那么也要重新链接整个程序，用户也要重新下载，对用户非常不友好。



<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/7.2-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%97%B6%E6%96%87%E4%BB%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%89%AF%E6%9C%AC.png" alt="7.2-动态链接时文件在内存中的副本" style="zoom:24%;" />

<center>图7.2 动态链接时文件在内存中的副本</center>



**动态链接**

动态链接的原理就是把程序的模块分割开来，使之成为一个个相互独立的文件，**并一直保持这种状态，直到程序被加载到内存中运行**。当点击该程序运行时，该程序所依赖的所有模块（文件）都被加载到内存，然后由动态链接器进行链接操作，链接操作基本与静态链接一致。

这种把链接过程推迟到运行时进行的思想就是动态链接的基本原理。

第一，动态链接所加载的部分模块（公共模块）是可以被多个程序共用的，这就大大减少了内存浪费；第二，倘若程序中的某个模块更新了，理论上我们只需要覆盖掉老版本的模块目标文件就行（不过实际还要考虑得多一点，比如新旧接口兼容问题）。

**程序可扩展性和兼容性**

动态链接还带来一个特点，就是程序可以在运行时动态地选择加载各种程序模块，这种机制可以被用来制作**插件（Plug-in）**。

> 比如某个公司开发完成了某个产品，它按照一定的规则制定好程序的接口，其他公司或开发者可以按照这种接口来编写符合要求的动态链接文件。该产品程序可以动态地载入各种由第三方开发的模块，在程序运行时动态地链接，实现程序功能的扩展。



> 动态连接还加强了程序在不同平台/机器的兼容性，比如一个程序在不同平台运行时可以动态地链接到由操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统之间增加了一个中间层，从而消除了程序对不同平台依赖的差异性。
>
> 有一句话说得好，“在计算机领域，没有什么是不能通过添加一层中间层解决的”（狗头
>
> 比如操作系统A和操作系统B对于`printf()`的实现机制不同，如果我们的程序是静态链接的，那么程序就需要在A、B两个平台分别编译链接；如果用的是动态链接，那么程序只需要有一个版本，就可以在两个操作系统上运行，动态地选择`printf()`的实现版本（不过这仅仅是理想情况下，实际还要考虑其他东西，例如接口版本）。

动态链接也带来了一些问题，最常见的一个问题是，当程序所依赖的某个模块更新了，更新前后的接口并不兼容，那么就导致主程序不能运行。于是我们需要一种管理机制来管理动态链接库的版本。

**动态连接的基本实现**

动态链接的基本原理前面已经说过了，现在考虑一个事，我们能直接将静态链接用到的目标文件当作动态链接所用的模块文件吗？答案是不行。实际的动态链接文件与目标文件有一些区别（大体上一致），后面会介绍。

动态链接需要操作系统的支持，Linux下的动态链接文件称作**动态共享对象（Dynamic Shared Object）**，简称共享对象，一般以`.so`为后缀；Windows下的动态链接文件称作**动态链接库（Dynamic Linking Library）**，后缀一般为`.dll`。



### 7.2 简单的动态链接例子

```c
/* Program1.c */
#include"Lib.h"

int main()
{
        foobar(1);
        return 0;
}
```



```c
/* Program2.c */
#include"Lib.h"

int main()
{
        foobar(2);
        return 0;
}
```



```c
/* Lib.h */
#ifndef LIB_H
#define LIB_H

void foobar(int i);

#endif
```



```c
/* Lib.c */
#include"stdio.h"

void foobar(int i)
{
        printf("Printing from Lib.so %d\n", i);
        sleep(-1);
}
```

编译链接过程：

```shell
gcc -fPIC -shared -o Lib.so Lib.c
gcc -o Program1 Program1.c ./Lib.so
gcc -o Program2 Program2.c ./Lib.so
```

注意产生Lib.so的两个关键参数：`-fPIC` 和`-shared` 。`-shared`是必须的参数，`-fPIC`则是下文所要介绍的PIC技术。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/7.3-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.png" alt="7.3-动态连接过程" style="zoom:33%;" />

<center> 图7.3 动态连接过程</center>

为什么在生成可执行文件的时候仍要Lib.so“参与链接工作”呢？其实这里的链接并不是真正的链接，而是为了让Program1知道其中引用的`foobar` 函数是一个动态链接的符号，从而不进行重定位，而是把这个过程留到装载时再进行。同时，如果Lib.so“不参与链接”，那么生成可执行文件的过程可能会产生找不到符号定义的问题。

然后运行其中一个可执行文件（以Program1为例），并查看它的虚拟地址空间映射，如下：

```bash
doa@LAPTOP-DOA:~/Document/Ch7$ ./Program1 &
[1] 75
doa@LAPTOP-DOA:~/Document/Ch7$ Printing from Lib.so 1
^C
doa@LAPTOP-DOA:~/Document/Ch7$ cat /proc/75/maps
7fffba250000-7fffba253000 rw-p 00000000 00:00 0
7fffba260000-7fffba285000 r--p 00000000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so
7fffba285000-7fffba3fd000 r-xp 00025000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so
7fffba3fd000-7fffba447000 r--p 0019d000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so
7fffba447000-7fffba448000 ---p 001e7000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so
7fffba448000-7fffba44b000 r--p 001e7000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so
7fffba44b000-7fffba44e000 rw-p 001ea000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so
7fffba44e000-7fffba452000 rw-p 00000000 00:00 0
7fffba460000-7fffba461000 r--p 00000000 00:00 23019              /home/doa/Document/Ch7/Lib.so
7fffba461000-7fffba462000 r-xp 00001000 00:00 23019              /home/doa/Document/Ch7/Lib.so
7fffba462000-7fffba463000 r--p 00002000 00:00 23019              /home/doa/Document/Ch7/Lib.so
7fffba463000-7fffba464000 r--p 00002000 00:00 23019              /home/doa/Document/Ch7/Lib.so
7fffba464000-7fffba465000 rw-p 00003000 00:00 23019              /home/doa/Document/Ch7/Lib.so
7fffba470000-7fffba472000 rw-p 00000000 00:00 0
7fffba480000-7fffba481000 r--p 00000000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so
7fffba481000-7fffba4a3000 r-xp 00001000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so
7fffba4a3000-7fffba4a4000 r-xp 00023000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so
7fffba4a4000-7fffba4ab000 r--p 00024000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so
7fffba4ab000-7fffba4ac000 r--p 0002b000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so
7fffba4ad000-7fffba4ae000 r--p 0002c000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so
7fffba4ae000-7fffba4af000 rw-p 0002d000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so
7fffba4af000-7fffba4b0000 rw-p 00000000 00:00 0
7fffba4b0000-7fffba4b1000 r--p 00000000 00:00 23152              /home/doa/Document/Ch7/Program1
7fffba4b1000-7fffba4b2000 r-xp 00001000 00:00 23152              /home/doa/Document/Ch7/Program1
7fffba4b2000-7fffba4b3000 r--p 00002000 00:00 23152              /home/doa/Document/Ch7/Program1
7fffba4b3000-7fffba4b4000 r--p 00002000 00:00 23152              /home/doa/Document/Ch7/Program1
7fffba4b4000-7fffba4b5000 rw-p 00003000 00:00 23152              /home/doa/Document/Ch7/Program1
7fffbc820000-7fffbc841000 rw-p 00000000 00:00 0                  [heap]
7fffc4172000-7fffc4972000 rw-p 00000000 00:00 0                  [stack]
7fffc4bab000-7fffc4bac000 r-xp 00000000 00:00 0                  [vdso]
doa@LAPTOP-DOA:~/Document/Ch7$ 
```

可以看到其中不止有Program1的映射，还有`libc-2.31.so` 、`Lib.so` 、`ld-2.31.so` 等共享对象，其中`libc-2.31.so`是动态链接的C语言运行库 ，`ld-2.31.so`是Linux下的**动态链接器**。再开始执行Program1之前，系统会把控制权交给动态链接器，并由它完成所有的动态链接工作，然后再把控制权交还给Program1，开始执行。

### 7.3 地址无关代码

动态链接需要在开始执行程序之前对各个模块中对数据和引用的地址进行确定，也就是静态链接时的重定位。动态链接实现重定位的方式有两种：

- 装载时重定位
- **地址无关代码（Position-Independent Code, PIC）**

装载时重定位很简单，就是在模块装载时先确定装载地址（目标地址/基地址），然后依据这个装载地址修改其中的绝对地址引用进行重定位（因为模块是按照一个整体被装载的，所以代码和数据之间的相对位置是不会改变的）

**这种方式的缺点就是，一个共享对象的指令部分不能被多个进程所共享**，仍然起不到节省内存空间的作用。因为指令部分中的引用在装载时被修改后就与进程相关了，取决于这个共享对象在该进程虚拟空间中被分配的地址，是一个固定值，而对于不同的进程，该共享对象的虚拟地址都是不一样的，所以一份指令不能被多个进程所共享。

解决这个问题的方法就是地址无关代码技术，一开始听起来很nb，其实就是在指令部分和被引用的地址之间增加了一层，这一层称为**全局偏移表（Global Offset Table，GOT）**，在共享对象文件中是名为`.got`的段。

我们在上一节中生成`Lib.so`的时候就使用了`-fPIC`参数，从而产生使用了`PIC`技术的动态共享库。

**我们的使用这种技术的目的是希望共享模块的指令部分与装载地址无关，从而能被多个进程共享。**于是，一个自然的想法就是把指令中那些需要修改的部分分离出来，放在数据部分，因为每个进程都有单独的一个数据部分的副本，从而可以满足我们的需求。`PIC`主要是针对，共享模块中对模块外部数据or函数的访问or调用（后简写访问），因为内部数据和函数的访问都可以使用相对跳转来实现，而外部数据和函数则不能（因为相对位置会变化）。

于是我们请出GOT，我们并不直接访问外部数据和函数，而是将指令中对外部数据和函数的直接访问改为访问一个GOT表中的固定位置的指针（这些指针是固定放在数据部分的某个位置的，且排序也固定，所以GOT本质上是一个指针数组）。



<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/7.4-%E6%A8%A1%E5%9D%97%E9%97%B4%E6%95%B0%E6%8D%AEand%E5%87%BD%E6%95%B0%E8%AE%BF%E9%97%AE.png" alt="7.4-模块间数据and函数访问" style="zoom: 33%;" />

<center>图7.4 模块间数据and函数访问</center>

每个指针在GOT中的位置是固定的，所以指令部分的地址也就是固定的了，是不是很巧妙？

代码中对函数和数据的访问大致可以分为以下四种：

```c
static int a;	//注意这里是静态全局变量
extern int b;
extern void ext();

void bar()
{
    a = 1;	//类型2 模块内部数据访问
    b = 2;	//类型4 模块外部数据访问
}

void foo()
{
    bar();	//类型1 模块内部函数调用
    ext();	//类型3 模块外部函数调用
}
```

<center> 表7.1 不同类型的函数、数据访问方式</center>

|          | 指令跳转、调用             | 数据访问             |
| -------- | -------------------------- | -------------------- |
| 模块内部 | （1）相对跳转和调用        | （2）相对地址访问    |
| 模块外部 | （3）间接跳转和调用（GOT） | （4）直接访问（GOT） |

**注意！**对于模块内部的静态全局变量来说，是可以直接用相对寻址的方式访问的，而**对于模块内部的非静态全局变量来说**，却不能，因为编译器无法确定对全局变量的引用是跨模块的还是模块内部的。因此，**无论是模块内部还是外部的全局变量，都只能使用GOT的方式来访问**。可执行文件在生成代码的过程中，在链接过程中就要确定地址，这时，链接器会在`.bss`段创建一个该全局变量的副本，在之后的动态连接过程中，其他模块的GOT都会指向该副本，从而不会导致冲突。



#### 7.3.5 数据段地址无关

我们之前讨论的都是指令（代码）部分的地址无关性，其实数据段里面也有绝对地址的引用问题，例如一个指针变量p指向一个全局/静态变量a，a的地址会随着不同进程的装载而不同，解决这个问题的方法是**利用重定位表**，其中包含a的重定位信息，在动态装载的时候就会被重定位。



**装载时重定位和地址无关代码的优缺**

|      | 装载时重定位          | 地址无关代码                                                 |
| ---- | --------------------- | ------------------------------------------------------------ |
| 优点 | 运行速度较PIC方案要快 | 代码部分能被共享                                             |
| 缺点 | 代码部分不能被共享    | 比装载时重定位的方法运行时多了计算当前地址以及间接寻址的过程 |

 

> 对于动态连接的可执行文件，GCC默认会使用PIC的方法产生可执行文件的代码段部分。



### 7.4 延迟绑定（PLT）

由前可知，GOT相比静态链接，增加了灵活性，但是降低了运行的速度（因为多了运行时重定位的过程）。同时，因为要在真正运行程序前将程序引用到的所有函数都进行动态链接，这个过程很耗时，导致用户在点击运行程序后需要等待的时间变长，影响用户体验（用户就是上帝！）。

同时，考虑到一个事实，那就是：在我们实用程序的时候，并不是所有在程序中被引用的函数都真正被调用了（比如if判断就会导致有些函数不会被调用）。于是考虑，能不能在函数第一次被调用的时候才对函数进行链接，这样也能将原本的时间（一次性链接所有函数）平摊到每次调用函数的时候——一个函数第一次链接所需要的时间很少，使得用户体验得到明显提升。

这种方案称作**延迟绑定（Lazy Binding）**，基本思想就是在**函数第一次被用到的时候才进行绑定**（符号查找、重定位等），这样可以大幅提高程序的启动速度。

ELF具体使用的是**PLT（Procedure Linkage Table）**方法，在ELF文件中表现为段名中包含`plt`的段，其本质就是在指令和GOT之间又增加了一层跳转的过程，在第一次调用的时候，调用一个“绑定函数”来完成函数的绑定过程（填充GOT表中的项），在之后的调用时，直接调用GOT表中的项。每一个函数都在`plt`中有一个对应的项。

动态链接器绑定过程具体调用的方法是`_dl_runtime_resolve()`，它需要的两个参数：

1. 这个函数绑定发生在哪个模块（module）
2. 需要绑定的是哪个函数（function）



#### 一个例子

我们在`liba.so`模块中调用了`bar()`函数，则会调用`.plt`段中的bar项，具体表示为（`bar@plt`）：

```assembly
bar@plt:
jmp *(bar@GOT)	; bar@GOT表示bar在GOT中的项的地址
push n			; n是bar这个符号在.rel.plt段中的下标，用以查询符号名
push moduleID	; moduleID是调用bar的模块的ID
jump _dl_runtime_resolve	; 最后三句是函数调用过程
```

需要注意的是，第二行的`*(bar@GOT)`在未初始化时（第一次调用bar之前），指向的是第三行的地址（也就是`push n`），当执行了`_dl_runtime_resolve_`之后，`*(bar@GOT)`的值就被修改为`bar`真正的地址了。后续再调用`bar`函数的时候，就不会执行后面三句了，同时`bar`函数的返回地址也是堆栈中EIP保存的函数调用者的地址了，而不是`push n`。



实际的ELF中，GOT被拆成了`.got`和`.got.plt`两个段，前者是用来保存**全局变量**引用的地址，后者是用来保存**函数引用**的地址。

为了减少`.plt`中代码的重复，该段把每一项（上面的例子）中最后两句单独提取出来，同时把所需要的值（`moduleID`和`_dl_runtime_resolve_`）放在了`.got.plt`段的开头，代码如下：

```assembly
PLT0:
push *(GOT+4)	; 这里的GOT其实指的是.got.plt的起始地址
push *(GOT+8)
...
...
bar@plt:
jmp *(bar@GOT)	; 这里的GOT同理是.got.plt中的bar项的地址
push n
jump PLT0
```

`.got.plt`的内容如图（`.plt`未画出）：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/7.5-GOT%E4%B8%ADPLT%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="7.5-GOT中PLT的数据结构" style="zoom: 33%;" />

<center>图7-5 GOT中PLT的数据结构</center>

> PS：`.got.plt`的第一项是`.dynamic`段的地址，这个段描述了本模块动态连接的相关信息。后面的小节会讲一下这个段。
>
> PPS：实际的ELF中还有`.plt`、`.plt.got`这两个段，与上面提到的`.got`、`.got.plt`很容易弄混，这四个段的区别的作用可以看一个Blog：[计算机系统篇之链接（14）：.plt、.plt.got、.got 和 .got.plt section 之间的区别 - 代码先锋网 (codeleading.com)](https://www.codeleading.com/article/37234101170/)，感觉写得不错。



### 7.5 动态链接相关结构

动态链接的简要流程是：1. OS加载可执行文件头，读取Segment的属性，将它们映射到进程的虚拟地址空间中；2. OS将CPU的控制权交给**动态链接器（Dynamic Linker）**，由其完成程序的动态链接过程；3. 完成动态链接工作之后，将控制权交给可执行文件的入口地址。

#### 7.5.1 “.interp”段

这个段的内容是一个字符串，保存的是可执行文件用到的动态链接器的路径。

用`objdump -s xxx`即可查看xxx的不同段的内容，如果xxx是动态链接的可执行程序，那么就能找到`.interp`段的内容：

```shell
Contents of section .interp:
 0318 2f6c6962 36342f6c 642d6c69 6e75782d  /lib64/ld-linux-
 0328 7838362d 36342e73 6f2e3200           x86-64.so.2.
```

#### 7.5.2 “.dynamic”段

“.dynamic”段是ELF动态链接中最重要的结构了，它保存了动态链接器完成动态链接（中的重定位）所需要的基本信息，包括但不限于：依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。这个段是一个结构体数组，该结构体的定义（定义在`elf.h`中）为：

```c
typedef struct {
    Elf32_Sword d_tag;
    union {
        Elf32_Word_d_val;
        Elf32_Addr_d_ptr;
    } d_un;
} Elf32_Dyn;
```

其中`d_tag`指代的是一项的类型，`d_un`是一项的值。这里的类型就包括了上面所说的那些信息，比如`d_tag`为`DT_SYMTAB`，则`d_un`的值就是的信息是动态链接符号表的地址。还有其他的类型，请看书P205或搜索。



> Linux中有一个`ldd`命令，可以查看一个可执行程序/共享对象依赖的共享库



#### 7.5.3 动态符号表

动态链接中，一个模块`A`引用了模块`B`的函数`foobar`，那么称`foobar`为模块`A`的**导入函数（Import Function）**，为模块`B`的**导出函数（Export Function）**。导入/导出函数可以分别看作函数的引用和定义。

采用了动态连接的可执行文件/库，除了包含前面静态链接中提到过的符号表“.symtab”，还包含了针对动态连接的模块之间的符号导入导出关系的**动态符号表（Dynamic Symbol Table）**，名为`.dynstr`的段。

用`readelf -s`可以查看程序的`.symtab`和`.dynstr`。

#### 7.5.4 动态链接重定位表

与静态链接中的重定位表类似，动态链接也有相应的重定位表——`.rel.dyn`和`.rel.plt`，前者是对数据的修正，后者是对函数引用的修正。

> 即使是PIC编译的共享对象，也需要重定位，只不过代码部分不用重定位，但是数据部分仍然需要（如GOT表）。



#### 7.5.5 动态链接时进程堆栈初始化信息

在动态链接器接手CPU的控制权之后，为了进行动态链接，它需要知道该文件的基本信息，包括：有几个段（Segment）、每个段（Segment）的属性、程序的入口地址等，以装载可执行文件/共享对象。由前文6.4节可知，这些信息来源于文件的执行视图，可通过**程序头（Program Header）**获取。

进程初始化的堆栈里面就包含了程序头以及可执行文件的信息，这些信息构成了**辅助信息数组（Auxiliary Vector）**，如：可执行文件的文件句柄、程序头的地址、程序头中入口（Entry）的数量和每个的大小、可执行文件的入口地址等等。这个数组的元素的数据结构定义如下：

```c
typedef struct
{
    uint32_t a_type;	//该项的类型
    union
    {
        uint32_t a_val;	//该项对应的值
    }a_un;
}Elf32_auxv_t;
```

也是键值对的形式（为什么有一个union是历史遗留的原因）。

这个数组具体的位置是在环境变量指针的后面（环境变量指针在程序输入参数的后面，也就是argc以及argv所指向的内容的后面。

> 这一小节的示例代码（P213）在我的机器上并不能正常运行，需要经过修改，修改的时候对底层的原理有些疑问，等有空了再写一篇Blog详细解释一下

### 7.6 动态链接的步骤和实现

动态链接主要分为3步：启动动态链接器本身、装载所有依赖的共享对象、重定位和初始化。

#### 7.6.1 动态链接器自举

由于动态链接器本身就是为了给其他可执行文件or共享对象提供动态连接的功能，所以它不能自己动态链接自己，这是一个鸡生蛋、蛋生鸡的问题。虽然动态链接器本身是静态链接的（可以用`ldd`命令查看），但是其中的全局变量和静态变量仍然需要重定位，可能因为是绝对寻址的，所以需要跟据装载地址调整地址，这个过程叫做动态链接器的**自举（Bootstrap）**，在这个过程中，执行的代码不能用到全局变量和静态变量，也不能调用函数。完成自举之后，就能随意使用了。

#### 7.6.2 装载共享对象

当一个新的共享对象被装载到内存中时，它的符号表会被合并到**全局符号表（Global Symbol Table）**中（包括动态链接器和可执行文件的符号表），对共享对象的依赖关系可以看作一个图的数据结构，所以装入顺序分为深度优先和广度优先，一般采用的是广度优先的方法。

这里存在一个可能的问题，就是不同的共享对象中的符号可能存在重复的情况，处理的方式是，哪一个符号最先被加载，哪一个就有效，其余的符号都会被解析为第一个被加载的同名符号（C语言出现同名的概率要大一些，C++的命名空间机制namespace大大减少了同名符号的可能性）。这种处理方式表明了**符号的优先级**。

#### 7.6.3 重定位和初始化

这个阶段，动态链接器开始遍历可执行程序以及每个对象的重定位表，对GOT/PLT等结构中需要重定位的地方进行重定位。

然后就是执行不同共享对象的初始化代码（如果有的话），初始化代码位于`.init`段中。值得注意的是，可执行程序的`.init`代码并不是由链接器执行的，而是由程序初始化部分代码负责（后面的章节会讲）。

#### 7.6.4 Linux动态链接器实现

Linux动态链接器既是一个共享对象，也是一个可执行程序。

> 共享库和可执行文件实际上没有什么区别，除了头文件的标志位和扩展名有所不同之外，其他都是一样的。
>
> - 动态链接器本身是静态链接的，且不依赖于其他共享对象。
> - 动态链接器一般是PIC的，为了代码段能够共享。
> - `ld.so`的文件中标明的装载地址是`0x00000000`。这是一个无效地址，在装载的时候OS会为其选择一个合适的装载地址。



### 7.7 显示运行时链接

以上讲的都是动态链接时动态链接器对共享对象的自动装载，还有一种更灵活的方法是由程序员决定的“手动装载”，就是在代码中显示地调用系统提供的API来加载一个共享对象，这个被加载的共享对象也称作**动态装载库（Dynamic Loading Library）**，只是看待的角度不同。

这种机制可以用来实现**插件**的效果。当用到某个模块的时候，才将该模块装载到内存中，不需要的时候也可以调用API进行卸载，可以很好的利用有限的内存空间。

书中主要介绍了由动态链接器提供的4个API：打开动态库（dlopen）、查找符号（dlsym）、错误处理（dlerror）、关闭动态库（dlclose）。这些API位于`dlfcn.h`头文件中（Linux下）。Windows也提供了`rundll`这个程序用来实现动态装载的功能。7.7.5小节还写了一个演示程序，值得看一看。

> PS：如果直接在你自己的电脑上运行的话，很大可能会报错，因为书上的代码是十多年前的版本了，还是32位，现在早已经是64位的天下了，且API早已更新了很多版（待我有时间的时候写一版目前可运行的版本。



## 第七章外传——关于第7章7.6.2小节符号优先级示例的编译运行问题

首先，按照书上写的命令一顿敲：

```shell
$ gcc -fPIC -shared a1.c -o a1.so
$ gcc -fPIC -shared a2.c -o a2.so
$ gcc -fPIC -shared b1.so a1.so -o b1.so
$ gcc -fPIC -shared b2.so a2.so -o b2.so
$ gcc main.c b1.so b2.so -o main -Xlinker -rpath ./ 
```

开开心心地运行：`./main`，然后，就出现了这一行：

`./main: error while loading shared libraries: a1.so: cannot open shared object file: No such file or directory`

顿时懵逼。

书上不是说加了`-Xlinker -rpath ./`就不会报错嘛？（这个三个参数是在编译时通知链接器  额外的共享库的搜索路径，以至于在编译以及运行时不会出现找不到共享库的问题）

但，为什么还是出了问题呢？可能是由于OS、GCC以及动态链接器版本不同问题？毕竟书的年代有些久远。

> PS：我的OS是Ubuntu 20.04.1 LTS on Windows 10 x86_64，GCC版本为9.3.0，ld为2.34

经过我对前文不断尝试，终于理解了gcc编译链接共享库以及运行时查找共享库的机制。

我们一行命令一行命令来看，首先前两行是没有问题的，因为`a1.so`和`a2.so`没有依赖其他的共享库。问题出在第3、4行。

执行完第3、4行命令之后，通过`ldd`命令查看`b1.so`和`b2.so`的共享库依赖情况。

```shell
$ ldd b1.so
linux-vdso.so.1 (0x00007ffff08e5000)
        a1.so => not found
$ ldd b2.so
linux-vdso.so.1 (0x00007ffde39a0000)
        a2.so => not found
```

因为`ldd`是调用标准的动态链接器（`ld.so`）来查找共享库依赖的，所以用ldd查看的结果就代表你运行时的查找结果，所以这个`not found`就说明了问题，正好对应上面运行`./main`报的错。

更进一步，用`readelf -d`查看`b1.so`和`b2.so`的`.dynamic`段，结果如下：

```shell
$ readelf -d ./b1.so

Dynamic section at offset 0x2e50 contains 21 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [a1.so]
 0x000000000000000c (INIT)               0x1000
 0x000000000000000d (FINI)               0x1130
...	//后面的省略
 
 $ readelf -d ./b2.so
 Dynamic section at offset 0x2e50 contains 21 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [a2.so]
 0x000000000000000c (INIT)               0x1000
 0x000000000000000d (FINI)               0x1130
...	//后面的省略
```

这里只说明了依赖的共享库的名字，并没有指明路径，所以在运行的时候`ld.so`只会按照系统的路径搜索，其并不会搜索当前路径。查看`main`的`.dynamic`段，结果如下：

```shell
$ readelf -d ./main
Dynamic section at offset 0x2d90 contains 30 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [b1.so]
 0x0000000000000001 (NEEDED)             Shared library: [b2.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000001d (RUNPATH)            Library runpath: [./]
 0x000000000000000c (INIT)               0x1000
 0x000000000000000d (FINI)               0x1208
...	//后面的省略
```

一个重要的区别，就是第7行的`Library runpath: [./]`，这里指示了运行时的共享库搜索路径，但是为什么还是找不到`a1.so`（和`a2.so`）呢？因为`main`中的`.dynamic`段只显示依赖了`b1.so`和`b2.so`，在加载了`b1.so`和`b2.so`之后，需要继续搜索`a1.so`和`a2.so`，这时只会按照`b1.so`和`b2.so`中`.dynamic`段的信息来搜索，而其中并没有指示额外的运行时搜索路径`runpath`，所以就出现了找不到`a1.so`的报错。

要解决这个问题，就是要通知`ld.so `  `b1.so`和`b2.so`运行时依赖的共享库的搜索路径。

因为Linux下运行时查找共享库的路径是有固定位置和顺序的（位置可以手动修改），这个在第8章中会讲到，系统默认的位置是不包括当前目录`./`的，所以你要手动告诉`ld.so`共享库的搜索路径包括当前路径`./`，告诉的方法有很多种（在第8章中会详细说明），这里只讲一种简单的，就是像编译`main`的时候一样，在结尾添加`-Xlinker -rpath ./`参数（或者用`-Wl`参数也行，请自行百度）。

> PS：这个示例用的都是相对地址，这样得到的可执行程序（例如`main`）只能在编译的路径下运行，假如将这个程序复制到其他路径运行，那么仍然会报找不到共享库的错，所以在写做一个工程项目的时候，都是将共享库安装到一个专门的路径下，然后使用绝对路径来搜索（其他方法在第8章中会讲到）。

## 第八章 Linux共享库的组织

本章开始，记录的方式将变得越来越简要（以节省时间，提升更新速度），起到一个要点记录的作用。

> 虽然这一章最终还是又臭又长。
>
> ​															——来自写完后的我

本章主要讲的是Linux下共享库的管理、安装、查找机制以及符号版本机制。

### 8.1 共享库版本



产生共享库需要组织的根本原因就是，不同版本的共享库的**ABI（Application Binary Interface）**不一样。API是源代码层面的接口，而ABI是二进制层面的接口，ABI就是API经过编译器编译后之后形成的二进制文件中的接口，由于不同版本的代码经过编译后的二进制库文件的不同，可能会改变某些ABI，进而导致不同版本的库不兼容，所以必须对不同版本的库进行管理。

> 按照书上的话说，ABI包括一些诸如：函数调用的堆栈结构、符号命名、参数规则、数据结构的内存分布等方面的规则。

库函数的更新分为可兼容和不可兼容两种：

**兼容更新：**在原先版本的共享库的基础上添加一些东西，并不改变原有的接口。

**不兼容更新：**改变了原先版本的共享库的某些接口。

C语言的库函数不同更改的兼容性如下：



编译器和系统库的不同（甚至版本不同）都可能会影响ABI。



> C++的ABI兼容问题很严重，因为C++对其ABI并没有作出规定，所以不同的编译器甚至同一个编译器的不同版本对C++的一些特性都有着不同的方案，而且互不兼容，比如虚函数表、模板实例化、多重继承等。

代码、编译器、操作系统等因素的影响，不同的环境下，同一份源代码编译后的ABI也可能不同。

#### 8.1.2 共享库版本命名

Linux的共享库命名规则如下：

`libname.so.x.y.z`

其中，`so`是共共享库后缀，`x`是主版本号，`y`是次版本号，`z`是发布版本号。

主版本号是重大升级，不同主版本之间是不兼容的

次版本号是增量升级，只增加了一些新的接口符号，在主版本号相同的前提下，高次版本向低次版本兼容。

发布版本号是一些错误的修正、性能的改进等，在主版本号和次版本号相同的情况下，不同发布版本之间完全兼容。

> Linux下也有一些不符合上述规则的特例，比如Glibc，它包含了许多部分，其中的c语言库采用的方式是：`libc-x.y.z.so`，还有动态链接器`ld-x.y.z.so`，Glibc还有其他的部分也是这样。



#### 8.1.3 SO-NAME

因为不同版本的共享库不一定兼容，所以每个程序中必须包含其所依赖的库的版本信息。

因为不同的主版本是肯定不兼容的，所以系统主要通过主版本号来区分链接的版本，这个机制称为SO-NAME，也就是创建一个指向共享库的**软链接**，其名字只保留共享库的主版本号，例如：“/lib/libfoo.so.2.6.1”的SO-NAME就是“/lib/libfoo.so.2”。

> 由于某些历史原因，动态链接器的SO-NAME也与众不同，比如`ld-2.6.1.so`的SO-NAME是`ld-linux.so`。

如果一个OS里有多个主版本号相同，次同版号不同的库，SO-NAME软链接会指向次版本号最新的库。

没有SO-NAME机制前，编译生成ELF文件时需要将所依赖的库的全名（比如`libfoo.2.6.1`）保存到`.dynamic`中，如果在新的OS环境中没有这个版本的库，就无法正常运行。

有了SO-NAME机制后，就可以将所依赖的库的SO-NAME保存到`.dynamic`段中，之后运行的时候，动态链接器就可以根据SO-NAME来链接到符合条件的最新的库了。

由于次版本号是高版本兼容低版本的，更新库的时候也可以直接删掉旧的次版本号的库了，大大节省了空间。

如果是主版本升级，那么OS中会保存有多个SO-NAME。

> Linux中的`ldconfig`工具，可以遍历所有默认的共享库目录（`lib`、`/usr/lib`），来更新所有SO-NAME的软链接的，使其指向最新的版本库。

**链接名**

GCC编译器可以用`-l`参数使用某个共享库，具体请用看GCC的帮助或百度，这里不再赘述。



### 8.2符号版本

虽然SO-NAME是指向了本机器上最新的此版本号的库，但是存在这种情况：在其他机器上编译的软件依赖的库的次版本号（2.7.1）比运行该软件的环境中库的次版本号高（2.6.1），虽然SO-NAME一样，但是如果直接运行该软件的话，仍然有可能报错，因为该软件可能用到了高次版本库更新的符号。这个问题称作**“次版本号交会问题”**

有些OS会直接向用户发出警告但继续运行，有些OS则是直接禁止运行该软件。

为了更细致的控制符号的版本依赖问题，出现了一种**基于符号的版本机制（Symbol Versioning）**。思想就是给每个符号打上版本标记，比如“VERS_1.1”、“VERS_1.2”。

#### 8.2.2 Solaris中的符号版本机制

符号的版本标记也可以看作一种集合，Solaris中程序员可以通过**符号版本脚本**来指定符号所属的集合，集合与几何之间也存在继承和以来的关系。

一个例子：

```
SUNW_1.2 {
	global:
	swap;
}SUNW_1.1;

SUNW_1.1 {
	global:
	pop;
	push;
}

SUNWprivate {
	global:
	__pop;
	__push;
	local:
	*;
}
```

这个脚本中定义了3个集合：”SUNW_1.2“、”SUNW_1.1“和”SUNWprivate“，第一个集合有一个全局符号`swap`，同时继承了SUNW_1.1集合中的所有符号，SUNW_1.1中包含了`pop`和`push`两个全局符号，SUNWprivate中则声明了`__pop`和`__push`这两个全局符号，同时将其他所有的符号（除了这3个集合中声明过的全局符号）都声明为局部符号。

这种方法又被称为**范围机制（Scoping）**。



#### 8.2.3 Linux中的符号版本

Linux下用符号版本机制用的并不广泛，主要是用共享库符号版本机制的是Glibc中的共享库。

GCC对Solaris的符号版本机制有扩展，可以在C/C++的源代码中嵌入汇编指令，一个例子：

```c++
asm(".symver add, add@VERS_1.1");	// 把add添加到VERS_1.1的集合中，同时命名为add
int add(int a, int b)
{
    return a+b;
}
```

这个机制允许在不同的符号版本中存在相同的符号命名，类似于符号重载，一个例子：

```c++
asm(".symver old_printf, printf@VERS_1.1");
asm(".symver new_printf, printf@VERS_1.2");	//外部的程序可以根据符号版本的不同来访问不同版本的printf
int old_printf()
{
    ...
}
```

书中有一个Linux符号版本机制的实验，可以看看。



### 8.3 共享库系统路径

Linux一般都遵守FHS（File Hierarchy Standard），它规定了系统中的系统文件该如何存放、组织。

FHS中规定的共享库的存放目录如下：

- /lib：最关键的和最基础的共享库，如动态链接器，C语言运行库、数学库，这些是系统工具/运行的基础
- /usr/lib：非系统运行时所需要的关键性的共享库，主要是开发时用到的库
- /usr/local/lib：主要是第三方应用的库，例如python的解释器



### 8.4 共享库查找过程

一个动态连接的模块所依赖的共享库的路径保存在`.dynamic`段里面，由`DT_NEED`类型的项表示。如果保存的是绝对路径，就直接按照这个去找；如果是相对路径，那么动态链接器就会在`/lib`、`/usr/lib`和`/etc/ld.so.conf`配置文件中指定的目录去查找共享库。

我的wsl中的`/etc/ld.so.conf`文件内容是：`include /etc/ld.so.conf.d/*.conf`，也就是说包含了`/etc/ld.so.conf.d/`目录下所有后缀名为`conf`的配置文件的内容，具体可以进一步查看这些文件中包含的目录。

Linux中有一个`ldconfig`程序，可以搜索这些目录中的库，然后更新相应的SO-NAME（需要该库指定了它自己的SO-NAME），并且存放到一个缓存中，就可以加速共享库的查找过程。每当修改了`ld.so.conf`包含的内容或者手动安装了库，都应该运行一下这个程序（用包管理器安装的一般会自动帮你运行。



### 8.5 环境变量

环境变量，简单来说就是可以类比为变成中的变量，只不过这个变量的作用域是整个计算机系统。

同时，环境变量主要用来指示系统中一些“环境”的安装位置，比如各种编程语言的编译环境（例如Python、C++），或者是系统查找动态链接库的目录（比如`LD_LIBRARY_PATH`、`LD_PRELOAD`）。

> PS：由于加载的全局符号会覆盖后加载的同名全局符号，`LD_PRELOAD`可以用来修改某些库的某些函数，经常被用在调试或测试中。
>
> 书中还提到了一个`LD_DEBUG`环境变量，可以用来开启动态链接器的调试功能。



### 8.6 共享库的创建和安装

#### 8.6.1 共享库的创建

创建很简单，就是之前讲过的生成动态链接库的过程，一个典型的命令是：

`$gcc -shared -Wl,-soname,my_soname -o library_name source_files library_files`

即，产生一个名为`library_name`的共享库，它的so-name是`my_soname`，它的源文件包括`source_files`，它依赖`library_files`这些库文件。

> `-Wl`参数用来把参数传递给链接器，这里就是传递soname参数，如果不指定soname，那么`ldconfig`命令就不会查找和更新这个库的soname了。



#### 8.6.2 清除符号信息

普通编译的共享库或可执行文件里面带有符号信息和调试信息，对于最终发布的版本来说，这些信息没什么用，所以可以用`strip`工具来清除掉这些信息（或者向链接器传递`-s`和`-S`参数使得生成的时候就不产生这些信息）。

> `-s`是清除所有符号信息，`-S`是清除调试符号信息。



#### 8.6.3 共享库的安装

方法一：把共享库放在某个标准的系统共享库目录下，比如：/lib、/usr/lib等，然后运行ldconfig就行。（此方法需要root权限

方法二：手动建立SO-NAME（`ldconfig -n shared_library_directory`），然后编译的时候告诉编译器和程序该去哪查找共享库（比如设置`LD_LIBRARY_PATH`环境变量）。



#### 8.6.4 共享库构造和析构函数

关于构造函数和析构函数的概念，在第四章的笔记中提到过。

GCC对C/C++语言进行了扩展，可以使用`__attribute__((constructor))`和`__attribute__((deconstructor))`来分别生命构造和析构函数。

还有可以指定优先级，例如：`__attribute__((constructor(5)))`

具体用法请使用的时候再搜索

#### 8.6.5 共享库脚本

链接脚本有时候也可以看作一个共享库，需要符合一定的格式。比如`libfoo.so`文件的内容就是一句脚本：`GROUP(/lib/libc.so.6 /lib/libm.so.2)`，这个共享库相当于是把`libc`和`libm`这两个库组合成一个了。
