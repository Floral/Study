# 程序员的自我修养

## 第二章

从源代码到可执行程序的整个过程，可以分为四步，分别是：**预编译，编译，汇编，链接**。

### 预编译

预编译主要是处理代码中的预编译指令，预编译指令都是以`#`开头的，形如`#define`、`#include`、`#ifdef`**等**，其中`#define`是直接文本替换；`#include`则是把include的文件直接复制到改行所在的位置；`#ifdef`是用来对部分代码是否需要编译进行控制的。长得像预编译指令的`#param`则会保留，因为这是给传递给编译器的指令。

PS：注释在预编译阶段会被全部删除。

### 编译

狭义的编译就是将源代码翻译为汇编代码的过程，至于为什么说狭义，因为我们平常说的编译，一般包括了后面的汇编和链接过程。

### 汇编

汇编就是把汇编语言转换为机器语言，这本质上是一个**查字典**的过程，因为每一条汇编语句都对应着唯一的机器码（不同ISA的CPU有着不同的字典）。

### 链接

在以前的单文件、小软件时代，由于符号（函数或变量）的定义和对它们的引用都是在同一个文件中，其地址很方便分配与确定，但是随着软件的大型化、模块化发展，一个软件的源代码文件有几十上百个（甚至上千上万），它们生成的目标文件也有几十上百个。在它们之间，符号定义和其引用关系很复杂，一个文件中定义的符号很可能被其他文件所引用，且文件之间存在相互引用，于是导致不能在编译阶段确定符号的地址，只能采用临时地址来暂时替代最终的实际地址。

具体的符号的地址在最后一步——链接过程完成，链接细致一点又可以分为**地址和空间的分配，符号决议，重定位**，这三个步骤。其中第一个过程看名字就很好理解；第二个过程则是链接器检查所有的目标文件中每一个符号的引用，确保它们有且仅有有唯一的定义；第三个过程则是对目标文件中不能确定的临时地址的修正，将其修改为分配完地址后的地址。



### 编译器的流程

现代编译器通常集成了上述四个功能。我们现在以编译一个单一源代码文件的流程来进一步分析编译的背后流程，主要分为6个步骤：词法分析，语法分析，语义分析，中间语言生成，目标代码生成，目标代码优化。

#### 词法分析

词法分析是将源代码输入到一个扫描器中，得到的结果是对代码中各种符号的识别分类，这里的符号包括：关键字，标识符，字面常量运算符等。为后续的语法分析奠定基础。

#### 语法分析

语法分析是检查你所写的代码是否符合语言的语法￼规定。

它利用词法分析得到的记号来生成语法树。语法树就是你此法分析中得到的各种为节点的、按照你所写的代码的表达式来组织的一种树状数据结构。这里的语义分析并**没有确定**各种记号的**具体**类别，例如变量a的类型到底是int还是float，只知道它是一个变量，假如有一句`b=array[a];`，**即使a实际是float类型，但是在语法分析阶段还是不会报错**，因为这一句满足变量作为下标这一个语法，这里检查出来有错误是下一步——语义分析的工作。

一个语法树的例子，以下是表达式`a=(b+4)*c;`的语法树：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20210120204442258.png" alt="image-20210120204442258" style="zoom:25%;" />

#### 语义分析

语义分析是检查你所写的代码表达式是否是具有正确的意义，例如你把一个浮点数用作数组的下标，这在语法上是正确的，因为满足下表示一个标识符这个语法，但是这种写法并没有正确的含义，因为数组的下标是不能用浮点数表示的。

#### 中间语言生成

中间语言生成是将源代码转换为一种，便于优化的表现形式（中间语言），一般有可以转为三地址码，P-代码等。并在这个过程中对代码进行一次优化。由于是从源码转换过来的，所以又称源码级优化。

#### 目标代码生成与优化

中间语言生成之后就进入到了**编译器后端**流程。其就是将中间语言代码转换为最终目标机器平台的机器语言代码（也就是0、1组成的bit流），同时进行优化。其实这个过程就包括了之前所说的汇编过程。





## 第三章 目标文件里有什么



目标文件就是源代码经过编译后的，链接之前的文件，经过链接就变成了可执行文件，它也是一种二进制文件。

目标文件的格式其实与最终的可执行文件的格式是一致的，只是没有经过符号的链接过程。

在Windows环境下，可执行文件的格式是PE（Portable Executable），在Linux环境下，可执行文件的格式叫ELF（Executable Linkable Format），这两种格式差别不大，都是源自于COFF（Common File Format）格式的。

### ELF文件

下面主要介绍一下ELF文件格式。

ELF文件下又可以分为4种类型：

- **可重定位文件（Relocatable File）**，包含代码和数据，一般是指静态链接库文件。
- **可执行文件（Executable File）**
- **共享目标文件（Shared Object File）**，也是一种可重定位文件，但是它可以被用于动态链接。
- **核心转储文件（Core Dump File）**，进程意外终止的时候，系统把进程地址空间的内容和一些其他信息存放到核心转储文件中，可以用于排除BUG。



一个目标文件/可执行文件的基本组成部分都是段（Segment/Section），段就是把一个程序的不同部分分类存放，形成不同的段，一个目标文件最基本的段包括：

- **代码段（程序段）`.text`**，代码段就是存放程序的逻辑代码部分。
- **数据段`.data`**，用于存放变量数据，但是这里存放的是**已初始化**的全局/静态变量。
- **BSS（Block Started by Symbol）`.bss`**，BSS段则是为**未初始化**的全局变量和局部的静态变量，为他们预留位置，BSS段的起源是一个历史原因，同时也可以节省目标文件占用的空间。



那么有人会问，那局部变量存放在哪呢？**局部变量**是存放在进程地址空间中的**栈**里，因为局部变量的生命周期是临时的一个函数调用期，而全局变量/静态变量的生命周期是整个程序运行期间，所以我们将全局/静态变量放在进程中单独的一个段里。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20210122183320332.png" alt="image-20210122183320332" style="zoom: 25%;" />

<center>目标文件的3个基础段</center>

> PS：段名都是以小数点`.`开头的。
>
> PPS：有的编译器不会直接把未初始化的全局变量放在bss段中（即在bss段中分配确定大小的空间），而是会将其标记为一个COMMON符号，等到最后链接成可执行文件后才确定大小，在bss段中分配空间。例如这个程序的bss段大小就为4个字节，而不是8个字节，因为`global_uninit_var`并没有直接在bss段中分配空间，具体原因涉及到后面的弱符号和COMMON块。

同时，目标文件的最开始包含一个ELF文件头（ELF Header），它用来说明整个ELF文件各种信息，包括：是否可执行，是静态链接还是动态链接，入口地址（如果是可执行文件），目标硬件，以及**段表（Section Header Table）**的位置（文件位置偏移）等。这里的段表是一个重要的部分，它本质是一个数组，用来描述ELF文件中各个段的信息（名字、偏移and其他信息）。

目标文件中除了有各种“段”，还有各种“表”，上面说的段表就是一个，除此之外还有重定位表（Relocation Table）、字符串表（String Table）、符号表（Symbol Table）等等。每一个表也是通过段的形式存储在目标文件中的。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20210122181949194.png" alt="image-20210122181949194" style="zoom:25%;" />

<center>ELF文件结构</center>

每一个需要重定位的段（例如代码段、数据段），都会有一个对应的重定位表，用来描述该段中需要重定位的引用的信息。

字符串表是将程序中所用到的变量名、段名等字符串集中起来放在一个段里，通过偏移量来表示字符串的。

符号表就是用来存放代码中用到的各种符号（函数名或变量名）的信息。符号一般分为全局符号、局部符号、段名、行号等。这里的全局符号（全局变量、非static函数）不仅包括定义在本文件中的全局符号，也包括引用其他文件中定义的全局符号，局部符号则是仅本文件内部可见的符号（主要是局部变量，还有static的变量和函数）。**链接过程处理的就是全局符号**。

### 符号

#### 符号修饰问题

> 一个讲的比较好的blog：https://www.cnblogs.com/wfwenchao/articles/4140388.html

在“远古时代”，编译后目标文件中的符号名与源代码中的符号名是一致的，随着软件工程的发展，就出现了一个问题：一个软件可能由多个人共同开发完成，如果他们没有对各自负责的模块中的变量、函数命名进行沟通及规范的话，很可能会造成符号重复的问题，即，不同模块中不同功能的函数名（或全局变量名）可能是一样的，或者是开发者写的函数名与所用到的库中的某一个函数撞名了，那么链接器在符号决议过程中就会冲突报错。

为了解决这个问题，现在的编译器一般会把源代码中的符号，经过一种修饰的规则修饰之后放入目标文件中，称为**符号修饰（Name Decoration）或符号改编（Name Mangling）**，不同的C++编译器对符号的修饰规则是不一样的（例如GNU的g++和微软的Visual C++编译器）。

有了符号修饰这个机制，就能很好地实现函数重载这类机制了，因为修饰机制一般会区分开同名函数的不同参数列表。同时，命名空间也是为了解决符号冲突而引入的一种机制。

一个函数对应一个唯一的**函数签名（Function Signature）**，函数签名包括了确定一个函数需要的所有信息，例如：函数名、参数列表、命名空间等。一个函数签名对应一个修饰后的符号名称（Decorated Name）。

由于C和C++的修饰规则并不一样，所以为了在C++程序中使用C的修饰规则，我们可以使用`extern "C"`这个关键字来声明符号，例如：`extern "C" double a;`，那么编译器就会对变量a使用C语言的修饰规则。



#### 强符号or弱符号、强引用or弱引用

> 一个讲的比较好的blog：https://www.cnblogs.com/downey-blog/p/10470674.html

##### 强符号和弱符号

强符号和弱符号是针对定义来说的，在C/C++语言中，已初始化的全局变量是一种强符号，未初始化的则是弱符号。在符号决议的过程中如果发现了多个同名的强符号**定义**，那么就会报错；如果有一个强符号定义以及一些弱符号定义，则不会报错，且强符号定义会覆盖弱符号定义；如果没有强符号定义，只有弱符号定义，那么会选择占用空间最大的那个（例如double类型比int型占用的字节大）。

我们也可以手动定义一个初始化的强符号，只需使用`__attribute__((weak))`关键字，例如：`__attribute__((weak)) int weak2 = 2;`，不过这样手动定义的弱符号不能和强符号共存。

**弱符号的一个用处是：在库中的定义是弱符号，用户可以重新定义一个自己使用的同名强符号，使得其覆盖库中版本，使用用户自定义版本的库函数的作用。**

##### 强引用和弱引用

一般没有特殊声明的**引用**都是强引用，如果一个强引用在链接的符号决议过程中没有找到定义，链接器会报符号未定义的错误。而弱引用在没有找到定义时则不会报错，链接器会用0或者一个特殊的值代替。

将一个符号的引用声明为弱引用需要用到`__attribute__((weakref))`这个关键字，例如：`__attribute__((weakref)) foo()`，就是声明了一个名为foo的弱引用函数。当然，为了避免弱引用没有定义就使用，在使用前最好用if判断一下foo是否是0。

**弱引用一个重要的作用就是，使得程序的不同功能模块更容易地裁剪和组合。**



## 第四章 静态链接

所谓静态链接，就是在链接阶段把所有参与链接的目标文件合并到一个最终的可执行文件中。有静态就有动态，后面会讲的动态链接就是链接过程中只是指明了主程序在运行时需要哪些动态链接库（模块），最终链接得到的可执行文件并没有包含所有模块的代码，而是在运行过程中会动态地加载那些模块。



### 静态链接的过程

从目标文件到最终的可执行文件，主要分为两步：

1. **空间与地址分配**，这里的空间指的是目标文件的段在可执行文件中的空间位置，地址指的是每一条指令的虚拟地址，此步骤完成后就能确定目标文件中全局符号在可执行文件中的实际位置（虚拟地址），为第2步做准备。
2. **符号解析与重定位**，即根据重定位表的信息和第1步得到的全局符号地址对引用位置的地址进行更新。

#### 空间与地址分配

从前面的章节可以知道，每一个目标文件都是许多段组成的，要把许多目标文件这么多不同的段合并到最终的可执行文件里，一个很自然的想法就是把不同文件中的同一种段（.text或.data或其他的）合并成一个段，实际采用的就是这种方案。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/4-1%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" alt="4-1空间分配策略" style="zoom: 33%;" />

<center>这里插张图.jpg</center>

在合并的过程中，链接器会把所有的目标文件的符号表收集起来，组成一个新的全局符号表，为后续的符号解析和重定位做准备。

将段合并之后，就可以得到各个符号在可执行文件的段中的位置（偏移）与分配的虚拟地址（VMA）了。

> 这里讲一下虚拟地址（VMA）和加载地址（LMA）。
>
> 对于每一个进程，在操作系统（OS）中都有一个独立的假想的地址空间，我们称之为虚拟地址空间，虚拟地址空间可以起到隔离不同进程的作用。
>
> 现代的可执行文件中，使用的都是虚拟地址空间中的地址，在加载到物理内存的过程中，还需要经过一个地址转换的硬件模块（MMU），将虚拟地址转换为物理地址。
>
> PS：如果没有MMU的支持，那么目标文件中的虚拟地址就等于物理地址。
>
> 加载地址，对于普通的PC机，即是把程序从硬盘中加载到内存中之后的地址，一般来说加载地址与虚拟地址是相同的（即加载到哪就在哪运行），除了嵌入式的特例（自行百度）。



#### 符号解析与重定位

所谓符号解析，就是查找合并后文件中的段中引用的全局符号的定义（即找到定义的虚拟地址），这个步骤依赖的是全局符号表。

重定位就是修正指令中引用符号的地址，利用的是重定位表，重定位表的每一项对应一个需要修正的位置的偏移（每一个需要重定位的地方叫做**重定位入口**），同时包含修正方法的类型以及该符号在符号表中的地址。

修正方法的类型总的可以分为**绝对地址修正**和**相对地址修正**两类。

以下是每个重定位入口对应的包含重定位需要的信息的数据结构：

```c
typedef struct{
    int offset;  	// 需要被修改的引用的段偏移(重定位入口地址)
    int symbol:24, 	// 被修改的引用应指向的符号 
        type:8;   	// 修改方式
}ELF32_REL;
```

重定位段（表）的内容就是一个该数据结构的数组。

### 静态库链接

静态库就是一系列编译好的还未链接的目标文件的集合（通过ar打包），一般是一个库函数对应一个目标文件，因为这样可以实现用到什么函数就链接什么函数，不会附带把不需要的函数链接到可执行文件中，从而节省了空间。

这里也有张图.jpg

### 链接过程控制

链接控制过程有两种方式：

1. 命令行参数式
2. 链接脚本式

链接脚本的方式灵活性很强，甚至可以自定义段名。在进行嵌入式或无操作系统的平台开始时，通常会用这种方式来控制可执行文件的段的分布，以满足硬件的要求。

### COMMON块

在链接之前的目标文件中，未初始化的全局变量会被标记为COMMON类型，且不会直接在`.bss`段中分配空间，为什么呢？

本质原因是链接器不能区分符号的类型，无法判断若符号的类型是否一致，导致弱符号的占用空间在链接前不能确定（强符号和弱符号那一节中讲过）。



### C++相关问题

主要有两个问题：

1. 重复代码消除
2. 全局对象的构造和析构

#### 重复代码消除

这里要消除的代码主要是由C++的模板机制、外部内联函数、虚函数表等造成的冗余。以模板为例，如果在不同的源代码文件（编译单元）中可能对同一个模板`add<T>()`进行了实例化，且实例化参数相同`add<int>()`，那么就会在不同目标文件中生成相同的实例化代码，如果直接合并的话，就会造成冗余。

解决的方法是对每一个实例化后的模板，将其单独存在在目标文件中的一个段中，这个段的名字是该实例化模板修饰后的名称（例如：`.temp.add<int>`），保证了唯一性，于是不同目标文件中的同一种实例化模板就能被检查出来，在合并的时候只需保留一个段就行。

**函数级链接**

函数级别链接，就是把每一个函数都单独地放到一个段里，链接器检测到用到了哪个函数就链接相应的段，没有用到的不会被链接到最终的文件里，与前面的静态库链接差不多。其目的也是为了减小最终的文件大小。

#### 全局对象的构造和析构

在最终的可执行文件中，真正的程序入口是`_start`（Linux系统下），在这个函数中进行进程初始化工作，然后在其中调用`main`函数，进入到用户定义的主程序。全局类的构造就是在进入`main`之前这一段过程完成的，同样，其他基本类型的全局变量也是在这一段过程中完成初始化的。在`main`函数结束之后，会返回到`_start`中，进行一些清理工作（例如全局类的析构），然后再结束进程。

对此，ELF文件中有两个特殊的段：`.init`和`.fini`。在`.init`段中的代码，会在`main`函数之前执行，而在`.fini`段中的代码，会在`main`函数之后执行。

### ABI（Application Binary Interface）

API（Application Programming Interface）是源码级别的接口，而ABI是二进制级别的接口。

与ABI相关的东西有很多，具体包括：**符号修饰标准，变量内存布局，函数调用方式等跟可执行文件二进制兼容性相关的内容。**同时，机器的硬件平台、编程语言、编译器、链接器、操作系统等都会影响到ABI，所以，ABI的标准化一直是一个大问题。不同目标文件的ABI不同的话，就不能相互链接起来。



### BFD库

BFD全称Binary File Descriptor library，是GNU的一个项目，目的是为了处理不同的目标文件格式。





## 第五章 Windows PE/COFF

Windows下的可执行文件格式为PE（Portable Executable），与ELF格式同根同源，都是COFF（Common Object File Format）格式的一种扩展。所以它们之间基本结构相同，下文主要说明它两之间的差异。

我们可以用dumpbin查看obj文件的信息，输入`/ALL`参数可以查看所有相关信息：

`dumpbin /ALL SimpleSection.obj > SimpleSection.txt`

### PE的前身COFF文件



<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/5.2-COFF%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="5.2-COFF目标文件格式" style="zoom: 33%;" />

COFF与之前介绍的ELF文件的一个主要不同就是，COFF的头文件包括两部分，一个是映像头（Image Header），类比ELF中的文件头，描述文件的总体结构和属性；第二个是段表（Section Table），而在ELF中，段表不是紧挨着文件头的。这个结构是一个数组结构，数组大小等于段的数量。

> 映像（Image）：因为PE文件在装载时被直接映射到进程的虚拟空间中运行，它是进程的虚拟空间的映像。所以PE可执行文件也被称为**映像文件（Image File）**

COFF文件的映像头对应的数据结构是`_IMAGE_FILE_HEADER`，书上说定义在`VC\PlatformSDK\include\WinNT.h`中，不过这应该是在作者那个年代的VC版本，我在自己电脑上的Visual Studio 2019 community的目录找了一下，并没有找到。该文件在win10下的目录应该是`C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\um\`（版本号可能有所不同），前提是你安装了Windows SDK，文件名为`winnt.h`，数据结构定义如下：

```c++
typedef struct _IMAGE_FILE_HEADER {
    WORD Machine;
    WORD NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD SizeOfOptionalHeader;
    WORD Characteristics;
} IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;
```

这些字段的含义看命名应该很容易理解，知道有这些东西就行，具体需要用到的时候再百度。

同时，段表对应的数据结构定义为`_IMAGE_SECTION_HEADER`，也位于`winnt.h`文件中。

```c++
typedef struct _IMAGE_SECTION_HEADER {
    BYTE Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
    } Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;
```

字段含义就不说了，理由同上，不过有一个点需要说一下，就是`SizeOfRawData`字段指的是该段在文件中的大小，而`VirtualSize`则是该段被加载到内存后的实际大小，这两个大小可能会不一样，且往往是前者比后者小。例如，bss段的`SizeOfRawData`为0，而`VirtualSize`则为bss段所含数据的大小。

### 链接指示信息

> COFF中`.drectve`段的内容是编译器传递给链接器的指令（Directive），即编译器希望告诉连接器该怎样链接这个目标文件。



### 调试信息

COFF中所有以`.debug`开头的段都包含着调试信息，例如`.debug$S`包含的是符号（Symbol）相关的调试信息；`.debug$P`包含的是预编译头文件（Precompile）相关的调试信息；`.debug$T`包含的是类型（Type）相关的调试信息。



### 符号表

dumpbin输出的最后一部分是COFF的符号表，总共有6列，从左到右依次是：符号编号、符号所表示的对象所占空间、符号所在位置、符号类型、符号可见范围、符号名（修饰后和修饰前）。

```
COFF SYMBOL TABLE
000 010471B7 ABS    notype       Static       | @comp.id
001 80000191 ABS    notype       Static       | @feat.00
002 00000000 SECT1  notype       Static       | .drectve
    Section length   18, #relocs    0, #linenums    0, checksum        0
004 00000000 SECT2  notype       Static       | .debug$S
    Section length   B8, #relocs    0, #linenums    0, checksum        0
006 00000000 SECT3  notype       Static       | .data
    Section length    C, #relocs    0, #linenums    0, checksum AC5AB941
008 00000000 SECT3  notype       External     | _global_init_var
009 00000004 UNDEF  notype       External     | _global_uninit_var
00A 00000000 SECT4  notype       Static       | .text$mn
    Section length   4E, #relocs    5, #linenums    0, checksum CC61DB94
00C 00000000 UNDEF  notype ()    External     | _printf
00D 00000000 SECT4  notype ()    External     | _func1
00E 00000020 SECT4  notype ()    External     | _main
00F 00000004 SECT3  notype       Static       | $SG6034
010 00000008 SECT3  notype       Static       | ?static_var@?1??main@@9@9 (`main'::`2'::static_var)
011 00000000 SECT5  notype       Static       | .bss
    Section length    4, #relocs    0, #linenums    0, checksum        0
013 00000000 SECT5  notype       Static       | ?static_var2@?1??main@@9@9 (`main'::`2'::static_var2)
014 00000000 SECT6  notype       Static       | .chks64
    Section length   30, #relocs    0, #linenums    0, checksum        0
```

第三列的ABS表示对象所占空间，SECTx表示对象定义在第x个段，UNDEF表示符号在本文件中未定义，被定义在其他文件。

第四列的notype表示变量和其他符号类型，notype()则表示函数类型。

第五列的Static表示符号是局部变量，仅在本目标文件内可见，External则是全局可见的，可被其他目标文件引用。



### Windows下的ELF——PE

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/5.6-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="5.6-PE文件格式" style="zoom:33%;" />

PE文件在COFF的格式基础上，又有一些变化：

首先文件开头添加了DOS MZ可执行文件格式的文件头和桩代码（DOS MZ File Header and Stub）；第二，COFF的`IMAEG_FILE_HEADER`扩展为了`IMAGE_NT_HEADER`，其中添加了`IMAGE_OPTIONAL_HEADER32`部分。

之所以要添加DOS MZ相关的头文件和桩代码，是为了使为Windows编写的程序能“兼容”原有的DOS系统，以至于在DOS系统下不会被执行而导致错误。

其中`IMAGE_DOS_HEADER`的定义如下：

```c++
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```

其中`e_magic`这个字段是“魔数”，简单来说就是用来区分不同文件类型的，详细可以看：https://zh.wikipedia.org/wiki/%E9%AD%94%E8%A1%93%E6%95%B8%E5%AD%97_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)，PE的该字段包括“MZ”这两个字母的ASCII码。

其他字段中最重要的就是`e_cs`和`e_ip`这两个了，这两个字段的值指向程序的入口地址。

在DOS系统下运行PE文件，会因为魔数而检测到PE文件是一个“MZ”格式的文件，然后开始读取`e_cs`和`e_ip`的值准备执行，但其本质还是PE文件，且PE文件中这两个字段指向的并不是真正的程序入口地址，而是指向`DOS Stub`的起始位置，`DOS Stub`是可以在DOS下运行的一小段代码，这段代码唯一的作用是向终端输出一行字符串：“This program cannot be run in DOS”，然后就退出程序，这样就防止了在DOS下执行PE可能导致的错误。

`IMAGE_OPTIONAL_HEADER32`字面上是可选的，但实际上对于PE来说，是必须的，因为其中包含了很多对于PE执行来说重要的信息，比如`DataDirectory`。但是我们不必熟知，用到的时候再查即可，具体结构就不展示了。

### PE 数据目录

数据目录是一个数据结构——`_IMAGE_DATA_DIRECTORY`，定义为：

```c++
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
```

这个数据结构描述了PE文件中其他数据结构（如导入表、导出表、资源表、重定位表等）的虚拟地址和大小。

上一节最后的可选头文件中就包含了一个数据目录的数组，每一个元素对应一个表，以让系统很方便的找到所要用的表。





## 第六章 可执行文件的装载与进程

在讲装载之前，我们首先要了解程序和进程的区别，我用一种不严谨的说法来一句话解释：硬盘中的程序被装载到内存中就变成了进程。

> 程序（狭义上是可执行文件）是一个静态概念，它是一些预先编译好的指令和数据的集合的一个文件；进程则是一个动态的概念，它是程序运行时的一个过程，或者讲，一个正在运行的程序。很多时候把动态库叫做运行时（Runtime）就有这种含义。
>
> 有一个很形象的比喻就是，程序是一个大厨做菜时的菜谱，计算机的CPU相当于这个大厨，相关的厨具就是计算机的其他硬件，整个做菜的过程就是一个进程。

所谓装载，就是把存储在硬盘等介质内的程序（指令和数据），加载到内存中的某个位置，然后才能由CPU执行。这是由传统的冯·诺伊曼结构的所决定的（学过计组的都懂）。

### 6.1 进程虚拟地址空间

现代计算机系统的内存中，可以同时存在许多进程，为了防止这些进程在运行的过程中相互干扰，同时也可以防止恶意程序（病毒）对其他进程的破坏，操作系统（OS）中的每个进程都有自己独立的**虚拟地址空间（Virtual Address Space）**。虚拟地址空间的大小由CPU的地址总线的位数决定，32位的为4G，64位就有很多很多了（多到目前为止可以看作是无限的）。

本书的讨论都是在32位的环境下。

无论是Windows还是Linux下，一个进程的4G虚拟地址空间的主要分为两部分：操作系统部分和用户进程部分。为什么操作系统也要在用户进程的虚拟地址空间中占用一部分空间？我的想法是，因为要保证用户进程在操作系统的监控之下运行，因为不同进程间的虚拟地址空间是相互独立的，如果OS（OS是一个特殊的进程）独立于用户进程，那么OS就没法对该进程进行监控了，该用户进程也不能调用OS的系统调用了（以上来自于一个没有系统学过OS的人的“猜想”）。

Linux默认占用1G的虚拟地址空间，Windows默认占用2G，不过可以通过修改`Boot.ini`文件来修改Windows占用的空间。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6.1-Linux%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83.png" alt="6.1-Linux进程虚拟空间分布" style="zoom: 33%;" />

<center>图6-1 Linux进程虚拟空间分布</center>



#### PAE

在32位时代，为了扩大可用的内存空间，有些厂商把CPU的地址总线位数进行了扩展（使之超过CPU数据总线的位数），例如：Intel 1995年的Pentium Pro CPU开始采用了36位的物理地址，但它本身是一个32位的CPU。

那么如何利用这些高于32位地址空间的内存呢？Intel是通过修改页映射的方式来实现的，这种地址扩展方式就成为**PAE（Physical Address Extension）**，因为是物理上扩展了地址空间。

> 一个常见的实现就是OS提供一个窗口映射的方法，把额外的内存映射到进程地址空间来。应用程序可以跟据需要来选择申请和映射，比如一个应用程序中的`0x10000000~0x20000000`这一段256MB的虚拟地址空间作为**窗口**，程序可以从高于4GB的物理空间中申请多个大小为256MB的物理空间，并依次编号，如：A、B、C。然后可以根据需要将窗口映射到不同的空间去，例如需要用到A块中的内容是，就把窗口对应的地址映射到A的实际物理地址，然后就可以通过访问窗口范围的地址来访问A块中的地址了，同理，需要用到B中的内容是，可以将窗口映射到B块。在Windows下，这种操作方式叫做**AWE（Address Windowing Extensions）**。

### 6.2 装载的方式

最简单的装载就是一次性把程序的所有内容都装载到内存中，可是内存空间是极为珍贵的，很多时候并不能满足程序的要求。同时，跟据程序运行的局部性原理，我们可以只把程序的一部分留在内存中，其他部分放在硬盘中，等用到的时候再装入内存，这就是**动态装载**的基本原理。

动态装载的常用方法有两种：**覆盖装入（Overlay）**和**页映射（Paging）**。

#### 覆盖装入

覆盖装入在虚拟存储发明之前使用得比较广泛，现在几乎被淘汰了，因为它比较的使用很麻烦，需要由程序员自己写一个**覆盖管理器（Overlay Manager）**，来管理程序不同部分（模块）的装载。

> 在多个模块的情况下，需要程序员手动将模块按照他们之间的调用关系组织成树状结构（如图）。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6-2%20%E8%A6%86%E7%9B%96%E8%A3%85%E5%85%A5%E8%B0%83%E7%94%A8%E6%A0%91%E7%8A%B6%E5%9B%BE.png" alt="6-2 覆盖装入调用树状图" style="zoom: 33%;" />

<center> 6-2 覆盖装入调用树状图</center>

图中，同一高度代表同一内存地址，所以有重叠的模块是不能同时存在的。树中的子节点（模块）是依赖于父节点的，也就是说子节点存在于内存中的时候，父节点也要存在。

这也就引出了这种方法所需要注意的两个问题：

1. 一个模块的调用路径（也就是从树根main模块，到这模块上的所有途经模块所构成的路径）都必须在内存中，才能保证程序的依赖关系
2. 跨树间的调用是被禁止的。因为跨树会导致模块的内存重叠冲突，不同的路径不能同时存在于内存中。



#### 页映射

页映射是虚拟存储机制的一部分。它的原理就是把可执行文件和内存空间都分为许多大小一致的“页”（Intel IA32的页是4KB），当进程运行到某一部分的代码不存在于内存中时，就发生“缺页中断”，把需要的页加载到内存中。同时，如果内存的页都被占满了，这时我们需要选择一个页被替换掉，选择的方法有许多，例如：FIFO、LUR等页替换算法。

在这种方法中，OS就充当着覆盖管理器的角色，更具体的说，是OS的存储管理器。



### 6.3 从操作系统的角度看可执行文件的装载

从操作系统的角度来看，可执行文件的装载主要包含两个大的操作：

1. 进程的建立
2. 页错误

#### 6.3.1 进程的建立

创建一个进程分为三步：

1. 创建一个独立的虚拟地址空间
2. 读取可执行文件头，并建立虚拟空间与可执行文件的映射关系
3. 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行

> **创建虚拟地址空间** 一个虚拟空间由一组页映射函数**将虚拟空间的各个页映射至相应的物理空间**，那么创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。
>
> **读取可执行文件头，并建立虚拟空间与可执行文件的映射关系** 第一步完成的是虚拟空间到物理空间的映射关系，而这一步完成的是虚拟空间与可执行文件之间的映射。是装载过程中最重要的一步。
>
> Linux中把虚拟进程空间中的一个连续的地址空间叫做**虚拟内存区域（VMA，Virtual Memory Area）**，Windows中叫做虚拟段（Virtual Section）。一般一个VMA一半对应一个段（一个或多个页）。
>
> https://baike.baidu.com/item/VMA/9839255
>
> **将CPU的指令寄存器设置成可执行文件的入口地址，启动运行** 这一步是最简单的一步，它将CPU的控制权由OS转交给进程，由此进程开始执行。



#### 6.3.2 页错误

完成上面的步骤，程序其实还没有被装载到内存中，因为只是建立了映射关系，并没有真正映射。

当CPU执行到程序的入口地址（以0x8048000这个虚拟地址为例），发现这个页并没有被加载到物理内存中（通过一个数据结构可得到这个信息），于是就产生一个“页错误（Page Fault）”，引发缺页中断，CPU的控制权转交给OS，由OS分配一个物理页，建立映射关系，将缺少的页加载到该物理页中，然后将CPU的控制权交还给进程，继续执行。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6.3-%E9%A1%B5%E9%94%99%E8%AF%AF.png" alt="6.3-页错误" style="zoom:33%;" />

<center>图6-3 页错误发生后</center>



### 6.4 进程虚存空间分布

#### 6.4.1 ELF文件链接视图和执行视图

现代OS的装载过程实际采用的是页映射的方式，也就是以页为单位装载指令和数据的，所以存在一个页地址对齐的问题。也就是不同段（Section）映射到虚拟内存空间或实际物理空间的时候，占用的空间必须是页大小的整数倍（起始地址也是）。

但是随着可执行文件中段的数量不断增多（特别是ELF，一个ELF往往有十几个段），就会产生内存碎片的问题，有许多段本身或者末尾实际仅仅使用了一个页的一小部分，造成了极大的浪费。

解决的方案就是，尽可能合并这些段（合并后的称为Segment），然后**将合并后的Segment作为一个整体映射到虚拟内存空间和实际物理空间，并且一个Segment对应一个VMA（Virtual Memory Area）**。这里的Segment翻译过来其实也称为段，只不过是在装载过程中的段，在讨论装载的情况下，段这个字一般都指的是Segment。

那按照什么来合并呢？总不能一股脑儿地把所有段都合并了吧，这样不利于程序内部的结构划分。

ELF采用的方案是**把具有相同权限（读、写、执行）的段合并成一个Segment**，ELF中主要的段的权限组合不多，主要有3种：

> - 以代码段为代表的权限为可读可执行的段
> - 以数据段和BSS段为代表的权限为可读可写的段
> - 以只读数据段为代表的权限为只读的段

ELF中描述Segment的结构叫做**程序头（Program Header）**，很容易与之前说过的段表（Section Header Table）弄混。

我们用readelf查看如下程序的程序头，得到如下结果：

```sh
doa@LAPTOP-DOA:~/Document$ readelf -l SectionMapping.elf
Elf file type is EXEC (Executable file)
Entry point 0x401bc0
There are 10 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000518 0x0000000000000518  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x00000000000935dd 0x00000000000935dd  R E    0x1000
  LOAD           0x0000000000095000 0x0000000000495000 0x0000000000495000
                 0x00000000000265f5 0x00000000000265f5  R      0x1000
  LOAD           0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000005170 0x00000000000068c0  RW     0x1000
  NOTE           0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000020 0x0000000000000020  R      0x8
  NOTE           0x0000000000000290 0x0000000000400290 0x0000000000400290
                 0x0000000000000044 0x0000000000000044  R      0x4
  TLS            0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000000020 0x0000000000000060  R      0x8
  GNU_PROPERTY   0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000020 0x0000000000000020  R      0x8
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000002f40 0x0000000000002f40  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt
   01     .init .plt .text __libc_freeres_fn .fini
   02     .rodata .stapsdt.base .eh_frame .gcc_except_table
   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs
   04     .note.gnu.property
   05     .note.gnu.build-id .note.ABI-tag
   06     .tdata .tbss
   07     .note.gnu.property
   08
   09     .tdata .init_array .fini_array .data.rel.ro .got
```

> 所以总的来说，“Segment”和“Section”是从不同角度来划分同一个ELF文件，这个在ELF中被称为不同的**视图（View）**，从“Section”的角度来看ELF文件就是**链接视图（Linking View）**，从“Segment”的角度来看就是**执行视图（Execution View）**。

#### 6.4.2 堆和栈

在OS中，VMA除了被用来映射可执行文件中的各个Segment，OS还通过使用VMA来对进程的地址空间进行管理。例如进程在运行时还需用到的**堆（Heap）**和**栈（Stack）**等空间，他们在虚拟内存空间中的表现形式也是VMA。

在linux下，可以通过查看`/proc`来查看进程的虚拟空间分布：

```shell
doa@LAPTOP-DOA:~/Document$ cat /proc/184/maps
00400000-00401000 r--p 00000000 00:00 963148                     /home/doa/Document/SectionMapping.elf
00401000-00494000 r-xp 00001000 00:00 963148                     /home/doa/Document/SectionMapping.elf
00494000-00495000 r-xp 00094000 00:00 963148                     /home/doa/Document/SectionMapping.elf
00495000-004bb000 r--p 00095000 00:00 963148                     /home/doa/Document/SectionMapping.elf
004bb000-004bc000 r--p 000bb000 00:00 963148                     /home/doa/Document/SectionMapping.elf
004bd000-004c0000 r--p 000bc000 00:00 963148                     /home/doa/Document/SectionMapping.elf
004c0000-004c3000 rw-p 000bf000 00:00 963148                     /home/doa/Document/SectionMapping.elf
004c3000-004c4000 rw-p 00000000 00:00 0
006ed000-00710000 rw-p 00000000 00:00 0                          [heap]
7fffe2ba2000-7fffe33a2000 rw-p 00000000 00:00 0                  [stack]
7fffe33da000-7fffe33db000 r-xp 00000000 00:00 0                  [vdso]
```

其中最后两列分别指映像文件的节点号和路径。

向堆和栈这种没有指定特定的映像文件的VMA通常称为**匿名虚拟内存区域（Anonymous Virtual Memory Area）**。每个线程都有自己的堆和栈，C语言中使用malloc()内存分配函数就是分配堆中的内存。
可以看到其中还有一个非常特殊的VMA叫做`[vsdo]`，实际上它是OS内核的一个模块，进程可以通过访问这个VMA来跟内核进行通信。

> 进程虚拟地址空间的概念：操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的，有相同映像文件的映射成一个VMA，一个进程基本上可以分为如下几种VMA区域：
>
> - 代码VMA，权限只读、可执行；有映像文件
> - 数据VMA，权限可读写、可执行；有映像文件
> - 堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展
> - 栈VMA，权限可读写、不可知性；无映像文件，匿名，可向下扩展

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6.4-ELF%E4%B8%8ELinux%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" alt="6.4-ELF与Linux进程虚拟空间映射关系" style="zoom: 33%;" />

<center> 图6-4 ELF与Linux进程虚拟空间映射关系</center>



#### 6.4.3 堆的最大申请数量

略

#### 6.4.4 段地址对齐

前面我们说到为了节省由于页对齐产生的内存碎片，而想出和并为Segment的方法。但这并不能满足人类贪婪的欲望，即使是只剩三个Segment了，还是有很大可能多浪费了两个页，为了节省这两个页，我们需要进一步“合并”Segment，**但这种合并与之前的合并为Segment并不一样！！！合并为Segment是在虚拟地址空间和物理空间两个地方都进行合并，而将Segment合并仅仅是在物理空间合并，在虚拟地址空间中的操作是将两个Segment交接处所在的页映射两次。**这么说可能有些抽象，上图：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6.5-ELF%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6%E6%83%85%E5%86%B5.png" alt="6.5-ELF文件合并情况" style="zoom: 33%;" />

<center>图6-5 ELF文件段合并情况</center>

至于为什么虚拟地址空间中不直接合并，我个人的猜想是因为OS层面访问的都是虚拟地址，OS需要区分不同的Segment以判断权限（因为内存权限的最小粒度是页），所以不同Segment在虚拟地址空间中不能在一个页中有交集，否则虚拟地址空间中的同一个页的权限会有冲突。

如果按照正常的映射方式，3个段（SEG0、SEG1、SEG2）应该分别占用1、3、1个Page（物理内存中），总共占用5个，如下图：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/6.6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%AE%B5%E6%9C%AA%E5%90%88%E5%B9%B6%E6%83%85%E5%86%B5.png" alt="6.6-可执行段未合并情况" style="zoom: 33%;" />

<center>图6-6 可执行文件段未合并情况</center>

### 6.5 Linux内核装在ELF过程简介

> 在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定的ELF文件，是原先的bash进程继续返回等待各个启动的新进程结束，然后继续等待用户输入命令。

剩下的用到再查（狗头

### 6.6 Windows PE的装载

> PE与ELF不一样，PE可执行文件的段的数量一般很少，这是因为链接器在产生可执行文件的时候就尽可能地把段合并，最后一般只剩下代码段、数据段、只读数据段和BSS等为数不多的几个段。
>
> PE中有一个很常见的术语叫做RVA（Relative Virtual Address），其实就是相当于文件中的偏移量。它是相对于PE文件的装载机地址的偏移地址。比如一个PE文件被装载到虚拟地址（VA）0x00400000，那么一个RVA为0x1000的地址就是0x00401000。
>
> 每个PE文件在装载**目标地址（Target Address）**，这个地址就是**基地址（Base Address）**。因为PE文件可以被装载到任何地址，所以这个及地址不是固定的，每次装载时都会变化。
>
> 装在一个PE可执行文件的过程：
>
> - 读取文件的第一个页，在这个页中包含了DOS头、PE文件头和段表
> - 检查进程虚拟地址空间中，目标地址是否可用，如果不可用，则选另外一个装在地址。这个问题对于可执行文件来说基本不存在，因为它往往是进程第一个装载的模块，所以目标地址不太可能被占用。这里主要是针对DLL文件的装载而言的，后面还有“Rebasing”这一节会具体介绍这个问题。
> - 使用段表中提供的信息，将PE文件中所有的段一一映射到地址空间中的相应位置。
> - 如果装载地址不是目标地址，则进行Rebasing。
> - 装载所有PE文件所需要的DLL文件
> - 对PE文件中的所有导入符号进行解析
> - 跟据PE头中指定的参数，建立初始化栈和堆。
> - 建立主线程并启动进程。

PE文件中，与装载有关的主要信息都包含在PE扩展头（PE Optional Header）和段表中了。