# C++反汇编与逆向分析技术揭秘



## 第2章 基本数据类型的表现形式

小端模式——小尾方式——高地址放高数据位，低地址放低数据位

大端模式——大尾方式——与上面的相反



### 2.2 浮点数类型

分为定点数和浮点数

定点数就是，整数部分和小数部分的存储位数都是固定的，例如一个4字节单元，前两个字节用于存放整数部分，后两个字节用于存放小数部分。这种方法显然有很大的缺点。



浮点数是用一部分位数来存放小数点的位置信息，来达到小数点“浮动”的效果。

浮点数的格式比定点数要复杂许多，所以对性能要求较高，现在的CPU一般都带有硬件浮点协处理器来辅助浮点数的计算，浮点协处理器中有专门的浮点寄存器，所以不会使用通用寄存器。但是在一些低端的MCU上可能就没有了，这时候需要用软件来模拟计算。

在PC上进行浮点编程，必须先对浮点寄存器进行初始化——也就是声明以及定义一个浮点类型的变量，然后才能使用运行，否则会报错。

```c++
int main()
{
    int nInt = 0;
    scanf("%f",&nInt);	//这种就会报错，因为没有分配和初始化浮点寄存器
}
```



`虽然float类型标准是4字节,但是仍然是以8字节的方式进行处理`，不过这是作者当年那个年代的情况，现在的情况是，float会被放到xmm寄存器中处理，而xmm寄存器是一个128位（16字节）的寄存器。



x86汇编中，中括号`[]`的意思相当于解指针，也就是C语言中的`*`，而中括号中的数字就是一个地址（指针），如果中括号前面加了`dword ptr`这种修饰词，比如`dword ptr [12345678h]`，就是取首地址为`0x12345678`的双字内存单元（dword就是指双字，即4字节），它相当于C++中的引用，是对括号中地址的内存单元的引用，举例子更好理解：`mov dword ptr [12345678h],ecx`，就是把ecx寄存器的值存到首地址为`0x12345678`的双字内存单元中；`mov ecx,dword ptr [12345678h]`则是把首地址为`0x12345678`的双字内存单元中的值复制到ecx寄存器中。



### 2.5 指针和引用

C++中的引用就是**指针的封装**，实际上还是有一个保存指针的内存单元，但是这个指针对用户隐藏，以实现引用的效果。引用比指针的好处就是，安全一点。

这对反汇编来还原源码来说带来了一定困难，因为在汇编下没有引用这种类型，不好判断源码到底是指针还是引用。

### 2.6 常量

`#define`是一个真常量，`const`是一个假常量，`const`是由编译器判断实现的常量，具体为使用`const`定义的常量，实际还是一个变量，只是编译器在编译的时候对代码进行了检查，如果有修改该变量的操作，那么就会报错。

一段有意思的程序：

```c++
	const int nConst = 5;

	int* pConst = (int*)&nConst;
	*pConst = 6;
	int nVar = nConst;

	printf("%d %d\n", nConst, nVar);
```

实际上`const`变量是可以修改的，这段程序编译并不会报错，但是输出仍为`5 5`，这是因为编译器知道`nConst`是`const`的，所以就直接把后面用到`nConst`的地方全都直接替换成了`5`，而实际上`nConst`的值已经被修改成了`6`。



## 第3章 认识启动函数、找到用户入口



