# C++ Primer 5th

## Chapter 1.Getting Start

### Some command in Linux

- compile the source code

```bash
$ g++ (-Wall) -o <outname> <sourcefilename>
```

- get the return code of last executed program

```bash
$ echo $?
```





### iostream

iostream includes the istream and ostream.

### Standard Input and Output Objects

`cin` and `cout` are known as the standard input and output,respectively.

`cerr` is referred to as the standard error, and `clog` are for general information about the execution of the program.



### Output operator

The output operator is defined as `<<` in C++. It must have two operands, and the left-hand operand must be and ostream object. The result of output operator is its left-hand operand. That is, the result is the ostream on which we wrote the given value.



- endl

The `endl` is a special value called a manipulator. It has two function:

1. ending the current line;
2. **flushing the buffer.**

 Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.

- scope operator

We use scope operator `::` to say that int which namespace that we want to call the function or manipulator. eg:

```c++
std::cin
std::endl
```



### Input operator

The input operator `>>` behaves analogously to the output operator. Also return its left-hand operand.





### 1.4.3. Reading an Unknown Number of Inputs

```c++
#include <iostream>
int main()
{
	int sum = 0, value = 0;
	// read until end-of-file, calculating a running total of all values read
	while (std::cin >> value)
	sum += value; // equivalent to sum = sum + value
	std::cout << "Sum is: " << sum << std::endl;
	return 0;
}
```

   The statement `std:cin>>value` returns the left operand of input operator `>>` , which in this case is *std::cin*. When tests the condition of *while*, it tests *std::cin*.

​    When *istream* is used as a condition, the test is **true** if the *istream* hasn't encounter an error, and **false** if it encounter the end-of-file or invalid input( such as reading a value that is not the variable type is declared ). 

> ​    When we enter input to a program from the keyboard, different operating systems use different conventions to allow us to indicates end-of-file.
>
> ​	In Windows: press `ctrl` and `z` simultaneously.
>
> ​	In Unix: press `ctrl` and `d` simultaneously.



### 1.5. Introducing classes

​	A class defines a type along with a collection of operations that are related to that type.

​	Conventionally, we define a new class in a header file that we write our own, and the name of header files are derived from the name of class. Header files that we write usually have a suffix of **.h**, but some programmers use .H, .hpp, or .hxx. The standard library headers typically have no suffix at all. Compilers usually don’t care about the form of header file names, but IDEs sometimes do.



> TIPS:
>
> It can be tedious to repeatedly type these transactions as input to the programs you are testing. Most operating systems support file redirection, which lets us associate a named file with the standard input and the standard output:
>
> $ addItems  <infile >outfile
>
> Assuming $ is the system prompt and our addition program has been compiled into an executable file named addItems.exe (or addItems on UNIX systems), this command will read transactions from a file named infile and write its output to a file named outfile in the current directory.



#### 1.5.2 A First Look at Member Functions

​	dot operator --" . ", call operator -- "()".



## Part I: The Basics

### Chapter 2 Variables and Basic Types

xing

>  以下由于看英文版的速度太慢，而时间有限，故决定一刷先看中文版，二刷再看英文版，但在看中文版的时候以英文版作为辅助

- 算术类型（arithmetic type）
- 空类型（void）



#### 算术类型

​		C++标准规定了算术类型所占位数的**最小值**（浮点型有点特别，其规定的是有效数字的位数），同时允许编译器赋予这些类型更多的位数，这也就是说，在不同系统、不同编译器、不同机器下，同一种类型的位数可能不一样，这就导致了C++可移植性稍微差了点。

​		除了char这个基本字符型，C++还提供了一些支持国际化的字符型（扩展字符集）：wchar_t、char16_t、char32_t。他们的最小为数分别是16 、16 、32。后面两个是Unicode字符。

> 内置类型的机器实现
>
> ​		要赋予内存中某个地址明确的含义，必须首先知道存储在改地址的数据的类型，类型决定了数据所占的比特数以及该如何解释这些比特的内容。



##### 带符号类型和无符号类型

除了bool和扩展字符型之外，其他的整型可以分为有符号的和无符号的。

int、short、long和long long默认都是带符号的，要想得到无符号的，就要在这些声明前加上unsigned。

比较特别的是char类型，他有三种：char、signed char和unsigned char。虽然有三种，但只有两种表现形式：有符号的和无符号的。其中char并不就是signed char，它既可能是有符号的，也可能是无符号的，具体**由编译器决定**。

> 选择类型的一些准则：
>
> - 当数值肯定不为负数时，则选用无符号类型。
> - 一般选用int进行整数运算，而不用short，因为short的位数比较小。
> - 在算术表达式中不要用char或bool，因为char的有无符号不确定，如果确实需要用char来表示一个不大的整数，请指明signed和unsigned。而bool在算术表达式中只能取0或1两个值。
> - 执行浮点运算一般选用double。



##### 类型转换

​		对象的类型**定义了对象能包含的数据和能参与的运算**，其中一种运算被大多数类型支持，就是将对象从一种给定的类型**转换**为另一种相关类型。

​		常见的是把int型当做if或循环的判断条件，这里就会自动的转换为bool型。

###### 含有无符号类型的表达式

​		当一个算术表达式中既有无符号数又有int型是，那么int值就会转换成无符号数。

​		当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不是一个负值，这里有一个有趣的例子：

```c++
#include<iostream>

int main()
{
    unsigned u=42,i=10;
    std::cout<< i-u <<std::endl;
    std::cout<< (signed int)(i-u) <<std::endl;
    return 0;
}

//如果int是32位，其结果是：
//4294967264
//-32
```

​		这里涉及到数字在计算机中的表示方法——都是通过补码来完成存储和计算的，但是其**显示的结果取决于我们如果解释这个补码**，如果解释为无符号数（第一个输出语句），其结果就是一个正数，如果强制转换为有符号类型来解释，那么结果就是-32。

##### 2.1.3字面值常量

​		形如42的值被称作**字面值常量（literal）**，字面值常量的形式和值决定了它的数据类型。

**整形和浮点型字面值：**

​		八进制数以0开头，十六进制以0x开头。20的三种写法：20（十进制），024（八进制），0x14（十六进制）。

​		默认情况下，十进制的字面值是带符号数，八进制和十六进制既可能是有符号数也可能是无符号数。



**字符和字符串字面值** 	P36

​		单个字符用单引号括起来，字符串用双引号括起来，但是单个字符也能用双引号括起来。编译器会在每个字符串结尾添加一个空字符（'\0'），因此字符串常量的实际长度要比它的内容多1。



**转义序列	P36**

​		转义序列就是以反斜线开始的一些特殊字符。如：换行符，制表符等等。

​		还有一种比较特殊的被称作泛化的转义序列，用于表示字符，形式有：以\x后紧跟的1个或多个十六进制数字、以\后紧跟的1-3位八进制数字。数字部分表示的是字符对应的数值。



**指定字面值常量的类型	P37**

​		我们可以给字面值常量表达式通过添加前缀或后缀来改变他们的默认类型。具体见书P37。



**布尔和指针的字面值常量**

​		true和false是布尔类型的字面值，nullptr是指针字面值。



#### 2.2变量	P38

​		C++中，变量（variable）和对象（object）一般可以互换使用。

> 大多数人习惯认为对象是具有某种税局类型的内存空间。

​		C++中，初始化和赋值是两种完全不同的操作，但是在很多编程语言中，二者的区别几乎可以忽略不计，即使在C++中这种区别也无关紧要，但我们必须要有一个这种认识！



**列表初始化	P39**

​		C++提供了4中初始化的方法：

- int units_sold=0;
- int units_sold={0};
- int units_sold{0};
- int units_sold(0);

其中2、3两种用花括号来初始化的形式成为**列表初始化（list initialization）**。当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且存在丢失信息的风险，则编译器将报错，而其他形式的初始化并不会报错，且会丢失信息。具体例子见书P40。



**默认初始化	P40**

​		如果变量定义时没有杯指定初值，那么变量就会被默认初始化，被赋予”默认值“，默认值由变量类型决定，同时变量定义的位置也会对此有影响。**任何定义在函数体外部的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化，其值是未定义的。**



> 建议任何内置类型的变量都要手动初始化，因为如果未初始化，使用的将是一个不确定的值，这样造成的后果比逻辑错误更严重。



##### 2.2.2变量声明和定义的关系！！！！！！	P41

​		变量的声明和定义不是一个概念！！！

​		**声明**使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而**定义**负责创建与名字关联的实体。

​		变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

​		如果想要声明一个变量而非定义它，就在变量名前添加关键字extern，**而且不要显式地初始化变量：**

```c++
extern int i;	//声明i而非定义i
int j;	//声明并定义j
```

> 变量能且只能被定义一次，但是可以被多次声明。

​		变量的定义只能出现在一个文件中，如果其他文件要用到该变量，必须对其进行声明，但绝对不能重复定义。

>如果一个要在一个文件中使用另一个文件中的变量，则被使用的变量必须声明在文件作用域，也就是最外层，在其他文件中使用的时候要加上extern关键字。
>
>同时，要注意的是，要在一个文件中（前者）使用其他文件（后者）中的变量，我们有两种做法，第一种是直接在这个文件中include那个被使用的变量所在的文件，这样只用手动编译前者（也就是包含include的那个）；第二种方式是将不加include语句，但是要将后者编译成静态链接文件.o（使用-c选项），然后将前者与.o文件同时编译。

##### 2.2.3标识符

- 必须以字母或下划线开头

- 变量名一般用小写字母
- 用户自定义的类名一般用大写字母开头
- 多个单词一般用驼峰规则或者下划线来分割单词



#### 2.3复合类型	P45

​		这里先介绍两种符合类型：引用和指针。

##### 引用

> C++11中新增了”右值引用“，会在后面介绍，其主要用于内置类。严格来说，当我们使用术语”引用（reference）“时，指的是”左值引用“。xuanxiang

​		**引用（reference）**为对象起了另外一个名字，引用类型引用另外一种类型。定义形式：&d，d是声明的变量名。例如：`int ival=1024;int &refVal=ival;//refVal指向ival（是ival的另一个名字）`引用类型必须被初始化，否则会报错，定义引用时，会把引用和它的初始值**绑定（bind）**在一起，并且无法重新绑定。

> 引用**并非对象**，它只是为一个已经存在的对象起另外一个名字。



##### 指针

- 指针本身就是一个对象，允许对指针赋值和拷贝
- 指针无须在定义是赋初始值，但在编程时最好手动初始化，以避免其随机值带来的影响。
- 给指针赋值，它们的类型必须一致。



​		定义形式：*d，d是变量名。需要配合`&取址符`来定义。

​		空指针不指向任何对象。可以通过以下几种方法得到空指针：

```c++
int *p1=nullptr;
int *p2=0;
//先#include<cstdlib>
int *p3 = NULL;
```

​		在现在的C++中，建议使用前两种形式。



**void\*指针**

​		`void*`指针能指向任何类型的对象。但由于我们不知道它指向的地址到底是什么类型的对象，因此我们不能直接操作void*指针所指的对象。



**指向指针的引用**

​		当`*`和`&`叠加使用时，例如：`int *&r=p;`，那么我们应该从右往左读，最靠近变量名的修饰符决定了变量的性质。这里的r是一个指向指针的引用。



#### 2.4 const限定符

​		必须初始化，且不能修改。

​		默认情况下，const对象仅在文件内有效，如果要在不同文件中使用同一个const变量，那么就要在定义和声明处都加上extern关键字（非const变量只用在声明处加上extern），同时定义是定义在文件作用域。



> 今后要注意区分：指向常量的指针和常量指针。这是两个东西而不是一个。声明方式也不一样。具体见书P56。



##### constexpr和常量表达式

​		常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。对于字面值，要使用const声明才能算作常量表达式。

###### constexpr变量

​		constexpr关键字用于声明常量表达式变量，编译器会帮助验证你所定义的变量是不是常量表达式。



#### 2.5 处理类型	P60



##### 2.5.1 类型别名

​		定义一个类型的别名的传统方法是用关键字typedef：`typedef double wages;`。C++11提供了一种新的方法：使用using——别名声明，例子：`using SI = Sales_item;`，使SI等效于Sales_item。



##### 2.5.2 auto类型说明符

​		auto类型可以自动让编译器通过初始值判断这个变量是什么类型的，因此auto定义的变量必须有初始值。



##### 2.5.3 decltype 类型指示符

​		decltype返回的是操作数的数据类型，可以用它来声明一个变量，而不需要像auto一样必须通过初始化来定义。例：

```c++
const int ci=0,&cj=ci;
decltype(ci) x=0;
decltype(cj) y=x;
```

​	如果decltype后括号中的表达式的内容是解引用操作，那么decltype将得到引用类型，如果是外层带括号的表达式`decltype((ci))`，那么得到的也是引用类型，如果只是一个表达式，但是不带括号，例如：`decltype(ci+0)`，那么得到的就是int型。



#### 2.6 自定义数据结构 P64



##### 2.6.1 struct结构体

例：

```c++
struct Sales_data{
    std::string bookNo;
    unsigned units_sold=0;
    double revenue=0.0;
};
```

​		以struct关键字开始，紧接着的是结构体的名字，然后是花括号包括的具体内容，最后别忘了加上分号（这是因为可以直接在右花括号后面直接接变量名以示对该类型对象的定义）。





##### 2.6.3 编写自己的头文件

头文件的名字必须和类的名字一致，同时，为了保障当头文件被多次包含到一个文件中的时候也能正常工作，需要用预处理器来解决问题。

**预处理器**

​		预处理器是在编译之前执行的一段i程序，可以部分的改变我们所写的程序。之前已经用到了一项预处理功能#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。

​		我们这里要用到的是**头文件保护符（header guard）**，头文件保护符以来与处理变量。预处理变量只有两种状态：已定义和未定义。#define指定把一个名字设定为预处理变量，#ifdef和#ifndef用来检测预处理变量是否被定义，前者当被定义时为真，后者当为被定义时为真，当检查结果为真时，则执行后续操作直到遇到#endif指令为止。

> 整个程序中的预处理变量包括头文件保护符必须唯一，通常使用类的名字来构建保护符的名字，同时，预处理变量的名字全部大写。





### 第三章 字符串、向量和数组

#### 3.1 命名空间的using声明	P74

​		之前我们在使用每个标准库函数前都加上了`std::`来说明我们使用的是命名空间std中的名字，但是这样显得有些繁琐，如今我们可以用**using声明**来简化，形式如下：

```c++
using namespace::name;
//一个例子：
using std::cin;
```

​		一旦声明了上述语句，就可以在后面的代码中直接访问命名空间中的名字。

注意事项：

- 每个名字都需要独立的using声明
- 头文件不应包含using声明



#### 3.2 标准库类型string	P75

本节介绍一些string的常用操作

##### 3.2.1 定义和初始化string对象

初始化string有以下几种方式：

```c++
//1.
string s1;
//2.
string s2(s1);		//s2是s1的副本
//3.
string s2 = s1;		//等价于s2(s1),s2是s1的副本
//4.
string s3("value");		//s3是字面值“value”的副本，除了字面值最后的那个空字符外
//貌似string s3{"value"}也是一样的效果
//5.
string s3 = "value";	//等价于上一种方式
//6.
string s4(n,'c');	//把s4初始化为由连续n个字符c组成的串
```



##### string对象上的操作

**读写string对象**

可以通过cin和cout来读写。

> 在执行读操作的时候，string对象会自动忽略开头的空白并从第一个真正的字符开始读起，直到遇见下一处空白为止。



**读取位置数量的string对象**

```c++
int main()
{
    string word;
    while(cin >> word)
        cout<<word<<endl;
    return 0;
}
```

该程序在遇到EOF或非法输入时结束输入。



**用getline读取一整行**

为了让string能读取到字符串中的空白，我们使用`getline`来代替`>>`，getline读取一次会读取到遇到换行符的位置（**会读入换行符但是不会将换行符存入字符串中**）。示例：

```c++
int main()
{
    string line;
    while(getline(cin,line))
        cout<<line <<endl;
    return 0;
}
```



**string的empty和size操作**

`string.empty()`用来判断string对象是否为空，若为空则为真。`string.size()`返回的是string对象的长度。



**string::size_type类型**

`string.size()`返回的是一个string::size_type类型的值，而不是int或unsigned。它是一种无符号类型，注意不要轻易的把无符号类型和有符号数放在一个表达式中，否则有符号数会被自动转成无符号数。

**比较string对象**

可以直接用==、!=、<、<=、>、>=等操作符来比较string，不等关系比较的原则是比较第一个不相等的字符的字典序，如果两个不等长，但是短字符串是长字符串开头的一部分，那么短字符串小。

**string对象的赋值和加法**

比较简单，具体见书P80



##### 3.2.3 处理string对象中的字符

cctype头文件中提供了一系列标准库函数来处理字符串中的字符。P82

> C++版本的C标准库头文件
>
> C++版本的C标准库头文件的名称与C版本的有些不一样，C++版本的将C版本的后缀.h去掉了，在第一个字母前加上了一个字母c，例如：C的一个标准库头文件name.h的C++版本是cname，在以后的C++程序中，都建议使用C++版本的标准库头文件



**范围for语句**

```c++
for( declaration: expression)
    statement
```

与Java中的范围for语句功能一样。

**用范围for语句改变字符串中的字符**

要改变string对象中字符的值，必须把循环变量定义成引用类型，假设我们要把整个string对象转换成大写，只要对其中每个字符调用toupper函数并将结果再赋给原字符就可以了:

```c++
string s("Hello World!!!");
for(auto &c:s)
    c=toupper(c);
cout<<s<<endl;
```



**只处理一部分字符**

用**下表运算符（[]）**可以处理特定位置的字符。下标从0开始。

> **注意！！！**
>
> C++标准并不要求标准库检测下标是否合法，一旦使用了超出范围的下标，就会产生不可预知的结果。其下表范围必须大于等于0，小于size()的值。



#### 3.3 标准库类型vector	P86

​		vector表示对象的集合，其中所有对象的类型都相同。集合中每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也常被称作**容器（container）**。vector在头文件vector中。

​		vector是一个类模板，它本身不是类，使用模板时需要指出编译器应该把类实例化成何种类型，类型写在尖括号中。示例：

```c++
vector<int> ivec;
vector<Sales_item>	Sales_vec;
vector<vector<string>> file;	//以前，还需要在string后的两个尖括号中加一个空格来区分>>符号
```



##### 3.3.1 定义和初始化vector对象

P87

**值初始化**

​		当使用`vector<T> vec(n)`来创建一个vector时，会创建一个能容纳n个元素的vector，此时库会创建一个之初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型`T`决定。

​		如果vector对象的元素是内置类型，如int，则元素初始值自动设为0，如果是某种类，如string，则由该类默认初始化。



**列表初始值还是元素数量**

对于`vector<int>`的初始化，可能会有歧义，这里就要通过圆括号和花括号来区分了，简单来说就是，圆括号决定的是vector本身的属性，花括号的内容是vector内每个元素的值。



##### 3.3.2 向vector对象中添加元素

​		由于C++的vector能高效地增长，因此我们不需要在创建vector的时候指定大小，只有一种情况是例外，那就是所有元素的值都一样时，其他情况一般都是先定义一个空的vector对象，再在运行时向其中添加具体的值。

​		添加元素的操作由vector的成员函数**push_back**完成，例：`vec.push_back(T);`，其中vec是一个定义好的vector对象，T是vector包含的元素类型。

> 由此可见vector与一种数据结构很相似——栈。
>
> 在使用vector的时候，有一条隐含的要求：如果循环体内部包含有vector对象添加元素的语句，则不能用范围for循环。具体原因在5.4.3节介绍。



##### 3.3.3 其他vector操作	P91

​		访问vector中的元素也能通过范围for循环。

**计算vector内对象的索引**

​		vector内元素的索引与string一样，也是从0开始算起的。

**不能用下表形式添加元素（但是能通过下表来修改元素的值）**

​		只能通过push_back来添加。

> vector也存在下标不在正确范围内的情况，而且非常常见，由于这种错误不能被编译器发现，因此需要我们编程的时候非常仔细，同时，确保下标合法的一种有效手段就是尽可能使用范围for语句。
>
> 通过下表访问不存static在的元素会导致严重后果——缓冲区溢出(buffer overflow)，这也可能导致程序出现安全问题。



#### 3.4 迭代器介绍

​		除了通过下表运算符访问对象的元素，还能通过**迭代器（iterator）**。

​		标准库中除了vector这个容器，还定义了其他的容器。所有标准库容器都可以使用迭代器，但是其中只有极少数几种才同时支持下标运算符。

​		string虽然不是容器，但是也支持迭代器。

​		需要注意的是通过end()成员返回的迭代器指向的是为元素的下一位置，即一个不存在的“**尾后(off the end)**”。所以被称为**尾后迭代器（off-the-end iterator）**。常用来配合begin()来判断是否处理完对象中的所有元素。

- 迭代器与指针类似，也有**解引用**的操作。

- 但凡是使用了迭代器的循环体都不要想迭代器所属的容器添加元素，否则会使迭代器失效。



##### 3.4.2 迭代器运算

​		string和vector的迭代器提供了更多额外的运算符——P99。

> 灵活运用迭代器的各种运算可以完成很多功能。
>
> P100也的二分法值得研究。



#### 3.5 数组

​		数组的大小必须在编译的时候已知，因此必须是一个常量表达式。同时，数组的类型也必须明确，不能使用auto。



**字符数组的特殊性**

​		字符数组结尾还会被加上一个空字符`\0`，它会占用一个数组的空间，如果空间不够则会报错。



**指针数组和数组的指针**

```c++
int *ptrs[10];		//ptrs是含有10个整型指针的数组
int &refs[10]=	/* ? */;	//错误：不存在引用的数组，因为引用不是一个对象
int (*Parray)[10] = &arr;	//Parray指向一个含有10个整数的数组；
int (&arrRef)[10] = arr;	//arrRef引用一个含有10个整数的数组；
```



##### 3.5.2 访问数组元素

在使用数组下表的时候，通常将其定义为**size_t**类型。size_t是一种机器相关的无符号类型，他被设计得足够大以便能表示内存中任意对象的大小。定义在cstddef头文件中。

> 数组也要注意不要让下表超出了范围！！！否则会产生错误。



**标准库函数begin和end**

​		标准库函数begin和end用于获取数组的首个元素的指针和最后一个元素的下一位值的指针。使用方法：

```c++
int ia[]={...};
int *beg = begin(ia);
int *last = end(ia);
```



> 注意！
>
> 指针和迭代器可以比较的，条件是两个指针或者迭代器指向同一个对象中的元素或者尾元素的下一个位置。
>
> 可以利用这个特性来遍历。



**使用数组初始化vector对象**

```c++
int int_arr[] = {0,1,2,3,4,5};
vector<int> ivec(begin(int_arr),end(int_arr));	//把int_arr的首元素地址和尾后地址当做初始化参数就行了
```

​		也能只拷贝数组中的一部分，只要改变输入的起始地址就行了。



#### 3.6 多维数组

**重要！！！**

> 使用**范围for循环**语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，否则auto类型会把控制变量设为指针类型的！！！



**类型别名简化多维数组的指针**

​		如果用typedef定义一个数组的别名，那么中括号应该放在新名字的后面而不是原名字的后面。。。不知道为啥。



### 第四章 表达式

#### 4.1 基础	P120

​		一般二元运算符要求运算对象类型相同，实际上有时候不同也没关系，编译器会自动将他们转换成同一类型（如果原类型能转换的话）。

​		小整数类型（如bool、char、short等）通常会被**提升（promoted）**成较大的整数类型。



**重载运算符**

​		当运算符作用于类类型的运算对象时，用户可以自定义其含义。



**右值和左值**

https://www.cnblogs.com/catch/p/3500678.html

​		C语言中，左值可以位于赋值语句的左侧，右值不行。而在C++语言中，二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象或者函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。

>当一个对象被用作右值的时候，用的是对象的值（内容），当做向被用作左值的时候，用的是对象的身份（在内存中的位置）（也就是地址？）



##### 4.1.3 求值顺序

​		对于那些没有规定运算对象按照什么顺序求值的运算符来说，其结果是未定义的，比如乘号*和<<运算符。

```c++
int i=0;
cout<< i << " "<< ++i <<endl;	//未定义的
```

​		我们无法推断上述程序的结果，可能输出的是1 1，也可能是0 1，甚至编译器还可能做完全不同的操作。

> 如果一个未定义运算顺序的表达式中，多个运算对象影响了同一个对象额时候，则它是一条错误的表达式。将产生未定义的行为。

​		但是有4中运算符明确规定了运算对象的求职顺序。

- 逻辑与（&&），先计算左侧运算对象的值，为真的时候才继续求右侧运算对象的值。
- 逻辑或（||），先计算左侧运算对象的值，为假是才计算右侧对象的值。
- 条件运算符（?:）
- 逗号运算符（,）



> 以下两条经验准则对书写复合表达式有益：
>
> 1. 拿不准的时候最好用括号来强制让表达式的罪和关系复合程序逻辑的要求
> 2. 如果表达式中改变了某个运算对象的值，则在表达式的其他地方不要再使用这个运算对象。



#### 4.2 算术运算符

​		bool值不应该参与运算，例：

```c++
bool b=true;
bool b2= -b;	//b2仍然是true！
```

​		当bool值参与运算时，将被提升成整数值1，对它求负后结果是-1，,1再转换回布尔值并将其作为b2的初始值，由-1！=0，所以b2仍然是true。



- %取余运算符的运算对象不能包含浮点类型，只能是整型。



**关系运算符**

​		关系运算符返回的结果是布尔值，因此将几个关系运算符连写在一起会产生意想不到的结果：

```c++
if(i<j<k)	//若k大于1，则条件肯定为真！
if(i<j && j<k)	//要正确实现逻辑应该这样写
```



**相等性测试与布尔字面值**

> 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象，因为true会被转换成1，false会被转换成0。



#### 4.4 赋值运算符	P129

- 对于int型的赋值，有一点有意思的是如果不加花括号，把一个浮点数字面值复制给一个整型常量i时，可以编译运行，但结果会截取去掉小数部分，如果在浮点数字面值的外部加上了一个花括号，那么编译就会报错，因为列表初始化不允许把一个占用空间较大的类型转换成一个占用空间较小的。

例如：

```c++
    int k;
    k=3.145;	//正确，k=3
    k={3.14};	//错误，编译会报错：窄化转换
```



**赋值运算符满足右结合律**

​		连等的情况先从左右侧的等号开始赋值，返回的是赋值运算符左侧的运算对象。



**赋值运算符的优先级较低**

> 赋值运算符的优先级比关系运算符的低，因此在条件语句中，赋值部分通常应该加上括号。



#### 4.5 递增和递减运算符	P131

> 前置递增/递减运算符直接返回修改后的值，而后置递增/递减运算符会将原始值处存下来并返回。
>
> 如果我们不需要修改原来的值，用后置版本的运算符就是一种浪费——因为浪费了存储原始值的空间，所以在不需要修改或获取原始值的时候，一般都用前置运算符。

```c++
auto pbeg=v.begin()
while(pebg!=v.end() && ^pbeg>=0)
    cout<< *pebg++ <<endl;		//这种写法比下面的更简洁，后置运算符的优先级比*高

	cout<< *pebg <<endl;
	pebg++;
```



#### 4.6 成员访问运算符	P133

- 点运算符，直接用于对象本身。
- 箭头运算符，用于对象的指针。



#### 4.7 条件运算符	P134

- 在输出表达式中使用条件运算符记得要在最外层加上一对括号，否则会输出意想不到的结果——P135



#### 4.8 位移运算符	P135

> 关于符号位如何处理没有明确的规定，取决于不同的机器，因此强烈建议仅将位移运算符用于处理无符号类型

- 如果唯一运算符的运算对象是“小整型”，那么就会被自动提升成较大的整数类型，例如int。

- 位移运算符（又叫IO运算符）满足左结合律。



#### 4.9 sizeof运算符

- sizeof运算符返回一条表达式或一个类型名字**所占的字节数**。
- sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。

- 两种形式：`sizeof(type)`和`sizeof expr`



#### 4.10 逗号运算符

- 逗号运算符有两个运算对象，按照**从左向右**的顺序依次求值。
- 逗号运算符的结果是右侧表达式的值，左侧的值会被丢弃掉。



#### 4.11 类型转换	P141

##### 4.11.1 算术转换

- 整型提升

  如果一个较小类型的整数类型的所有值都能被存在int中，那他就会被提升成int类型。例如:bool、char、signed char、unsigned char、short和unsigned short都能可能被转换成int。

- 无符号类型的运算对象

  如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。

  如果不一致，那么有如下规律：如果无符号类型的所有制都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

  这也就是说，如果无符号类型所占的二进制位数大于等于带符号类型的，那么就会被转换成无符号类型，如果无符号类型所占的二进制位数小于带符号类型的，那么就会被转换成带符号类型。



##### 4.11.2 其他类型隐式转换



##### 4.11.3 显示转换

**命名的强制类型转换**

格式：` cast-name<type>(expression) `

其中cast-name有四种：static_cast、dynamic_cast、const_cast、reinterpret_cast。

其中static_cast、const_cast、reinterpret_cast能完成传统C/C++类型转换的功能：

- static_cast

  完成的是传统类型强制转换，但是被转换的不能包括底层const。

- dynamic_cast

  支持运行时识别类型。

- const_cast

  只能改变运算对象的底层const，去掉或者加上某个对象的const属性。

- reinterpret_cast

  顾名思义，就是重新解释一遍被改变的对象，但是对象本身的类型不变，可以理解为只是改变了对象类型的名字，但是这个名字所指的对象类型还是没有变化，这种类型转换可能会带来一些错误。



### 第五章 语句

#### 5.1 简单语句	P154



#### 5.4 条件语句	P156

其中值得注意的就是switch语句了，switch后括号中的表达式只能是整型或者枚举型。case后的表达式必须是整型常量表达式。



其他语句与C语言中的无异。除了多了一个毫无用处的goto语句。。。感兴趣的可以自行查阅。

### 第六章 函数

#### 6.1 函数基础	P182

**实参是形参的初始值。**



**函数返回类型**

函数的返回类型不能是数组类型或函数类型，但是可以是指向数组或函数的指针。



**自动对象**

**局部静态对象**



##### 6.1.2 函数声明

函数的定义只能有一个，但是声明可以有多次。

函数声明 不用包含函数体，因此形参的名字可以省略，但是写上形参的名字还是有好处的，它可以帮助使用者更好的理解函数的功能。

函数的三要素：

- 返回类型
- 函数名
- 形参类型

这三要素描述了**函数的接口**，说明了调用该函数所需要的全部信息。函数声明也称作**函数原型**。



##### 6.1.3 分离式编译

简单来说，C++的源程序完成后要经过**编译**和**链接**两个步骤才能生成可执行文件。

当代码分离时，我们要把需要用到的代码都告诉编译器，否则会出现变量或函数未定义的情况。

> 例如，在Linux系统下用g++编译器，若不带任何参数，则编译器会自动编译链接你所指定的文件，若加上参数-c，那么编译器只会编译源文件生成**对象代码(Object Code)**，在Linux系统下后缀名是`.o`。然后再用编译器把对象文件*链接*在一起生成可执行文件。
>
> 具体请阅读书上P187.



#### 6.2 参数传递	P187

参数传递有两种方式：

- 传值
- 传引用

当形参是引用类型时，就是传引用调用，在函数内部对形参的改变会影响外部原来的值，而传值调用则不会。



**使用引用避免拷贝**

当实参所占字节比较多时，使用引用传参来避免拷贝是一个非常好的做法，若在函数中不需要改变原来的值，则最好将其声明为常量引用。既能节省空间，又能避免在函数中对实参的改变。

**使用引用形参返回额外信息**

一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。



> 当实参是右值时，形参不能是引用类型。



##### 6.2.3 const形参和实参

当用实参初始化形参时会忽略掉顶层的const。

在C++语言中，允许定义若干具有相同名字的函数，但是前提是不同函数的形参列表应该有明显的区别。对于编译器来说，因为顶层的const被忽略掉了，所以两个同名函数仅仅具有形参const和非const差别的时候是不能通过编译的。



**尽量使用常量引用**



##### 6.2.4 数组形参

```c++
void print(const int*);
void print(const int[]);
void print(const int[10]);	//这里的维度表示我们期望数组含有多少元素，实际不一定
//这三种声明都是等价的，最后一个声明中二的维度并不是强制满足的。
```

因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术。

**1. 使用标记指定数组长度**



**2. 使用标准库规范**

使用标准库的begin()和end()标准库函数。

**3. 显式传递一个表示数组大小的形参**



##### 6.2.5 main：处理命令行选项

这一小节让我明白了命令行参数的接收原理。

main()函数有两个可选的形参:

```c++
int main(int argc,char *argv[])	{/*...*/}
//其中第二个参数等价于char **argv,指向一个二维数组
```

其中，第一个参数表示第二个参数数组中字符串的数量，不需要用户输入。

例如，当用户输入以下命令行时：

```bash
prog -d -o ofile data0
#其中prog是一个你已经写好的程序名
```

当实参传给main()函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素一次传递命令行提供的实参。最后一个指针之后的元素保证为0。

以上面的命令行为例，argc应该等于5，argv应该包含如下的C风格字符串：

```c++
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

> 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入



##### 6.2.6 含有可变形参的函数

两种方法：

- 实参类型相同时：通过initializer_list类型
- 实参类型不同：模板（第十六章介绍）

**initializer_list形参**

这也是一个模板，只不过别人帮你写好了。

initializer_list提供的操作——P198

> 感觉这跟vector一样，vector也能用作可变数量的形参。



**省略符形参**

省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。

省略符形参只能出现在形参列表最后一个位置。



#### 6.3 返回类型和return语句

return语句种植当前正在执行的函数并将控制权返回到调用该函数的地方。

如果返回的是引用类型，那么也不会执行拷贝操作，有利于节省空间。

**同时要注意！！！千万不要返回局部对象的引用或指针，因为函数完成后，局部变量所占的存储空间也随之会被释放掉，返回的引用或指针会变成未定义的值。**



##### 6.3.3 返回数组指针——P205

语法上来说，想要定义一个返回数组的指针或引用的函数比较繁琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名。

如果不使用类型别名，那么声明的形式会非常麻烦：`int (*func(int i))[10];`，它的格式是`Type (*function(parameter_list)) [dimension];`

还有一种方法是使用**尾置返回类型**。还是上面那个例子，改写成尾置返回类型后为：`auto func(int i) -> int(*)[10];`



**使用decltype**也能简化，前提是你要知道你返回的是哪个数组，还要在函数声明时加上一个*号。



#### 6.4 函数重载

如果同一作用域内的几个函数名字相同单形参列表不同（返回值也可以不同），我们称之为重载。

> main函数不能重载



形参的顶层const不会影响传入函数的对象，因此两个同名函数声明只存在顶层const的区别的话，那么这两个函数声明等价。



#### 6.5 特殊用途语言特性



##### 6.5.1 默认实参

```c++
typedef string::size_type sz;
string screen(sz ht=24,sz wid = 80,char backgrnd = '');
```

像这种直接在形参列表中赋值的形式就是赋给形参默认值，后面的值就是默认实参。这样既能接收用户传入的值也能在用户没有传入值的时候赋给形参默认值。

同时，要注意如果形参列表中既有没有默认值的形参，又有有默认值的形参，那么没有默认值的形参应该放在有默认值的形参的前面。

##### 6.5.2 内联函数与constexpr函数

类似宏指令define，在编译阶段将内联函数名展开成函数。只需在函数的返回类型前面加上关键字inline就能将函数声明成内联函数了。

> 内联说明只是想编译器发出一个请求，编译器可以选择忽略这个请求。
>
> 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。



**constexpr函数**

constexpr函数是指**能**用于常量表达式的函数。

- constexpr函数被隐式地指定为内联函数；

也就是说，在一定条件下，这个函数可以用作常量表达式，这个条件就是以下两个约定：

- 他的返回类型以及所有的形参类型都得是字面值类型；
- 函数体中必须有且只有一条return语句。

被标记为constexpr的函数也可以不能被用作常量表达式，只要不满足上述条件就行了，我们也允许constexpr函数的返回值不是常量，例子在书上P214。

> constexpr函数不一定返回常量表达式。

**通常把内联函数和constexpr函数的定义放在头文件中**



##### 6.5.3 调试帮助

利用assert预处理宏和NDEBUG预处理变量来辅助调试、debug。

编译器和预处理器还定义了一些对于程序调试来说很有用的变量：

- _ _func _ _，其值等于每个函数的名字(中间的空格是为了在markdown下避免被解释为标记符号，实际上是连着的两个下划线，下同)
- _ _ FILE _ _，存放文件名的字符串字面值
- _ _ LINE _ _，存放当前行号的整型字面值
- _ _ TIME _ _，存放文件编译时间的字符串字面值
- _ _ DATE _ _，存放文件编译日期的字符串字面值



#### 6.6 函数匹配——P217

由于函数重载，因此在一个函数有多个重载的时候，调用这个函数时就需要编译器对函数进行匹配度分析，寻找最佳匹配，如果没有最佳匹配，编译器会报错。具体匹配过程请看书。

> 我们在设计重载的函数时应尽量避免调用时需要强制类型转换的形参集合。



#### 6.7 函数指针

函数指针也指向某种特定类型的函数。而函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：

```c++
bool lengthCompare(const string&,const string&);
```

该函数的类型是`bool (const strig&,const string&)`。想要声明一个可以指向该函数的指针，只需要用指针名替换函数名即可：

```c++
bool (*pf) (const string&,const string&);
```

pf和*的括号必不可少，不然就变成了返回类型为bool\*的名为pf的函数了。

- 给函数指针赋值时取址符可选，必须的是函数的名字。
- 通过函数指针调用函数时的解引用符号*也是可选的。
- 也能给函数指针赋予nullptr和0。
- 函数指针也能作为形参，作为形参时，指针前的星号可以省略，此时看起来就像一个函数声明，但是却是当成指针来使用的。
- 我们写的函数能返回函数的指针类型，但是不能返回函数类型。
- 由于函数指针作为形参或返回值的时候写法比较繁琐，推荐使用别名来简化，也可使用auto和decltype来帮助判断返回的函数指针是什么类型。详情请看书P222。





### 第七章 类

类的基本思想是**数据抽象**和**封装**。数据抽象是一种依赖于**接口**和**实现**分离的编程（以及设计）技术。

类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。



#### 7.1 定义抽象数据类型

**引入this**

这里的一个重要概念就是this。

当我们调用成员函数时，成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如，如果调用`total.isbn()`，则编译器负责把total的地址传递给isbn的隐式形参this，可以等价的认为编译器将该调用重写成了如下的形式：`Sale_data::isbn(&total)`，当然这只是个伪代码，用来说明原理。

this总是指向调用成员函数的“这个”对象，所以this是一个常量指着，即不能改变this指向的对象，但能改变它指向对象的内容。



**const成员函数**

由于调用成员函数是通过this来指向对象的，正如上面的那个伪代码，从那可以看出，因为this的类型为`Sales_data *const`，那么如果调用该成员函数的对象是一个常量对象，那么就会出错，因为一个非常量指针不能绑定在一个常量对象上。这时我们需要将this对象的类型修改为指向常量对象的常量指针`const Sales_data *const`，这样即使我们使用一个常量对象也能调用该常量函数了，增添const的形式如下，即在参数列表后加上一个const:

`std::string isbn() const{return bookNo;}`

像这样使用const的成员函数被称作常量成员函数，当然，在这些函数中不能改变this指向对象的内容了。

> 因此，我们在设计一些常量对象也能使用的成员函数时，需要将他们声明为常量成员函数。



**构造函数**

- 没有返回值
- 不能被声明为const



**构造函数初始值列表**

```c++
Sales_data(const std::string &s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n) { }
```

其中形参列表后面的冒号和花括号前面的部分就是构造函数初始值列表了，它的意思是用s来初始化booNo，用n初始化units_sold，用p和n的乘积初始化revenue。

> 没有出现在初始值列表的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。
>
> 如果类包含有内置类型或者符合类型的成员，这些成员的默认初始化的值是未定义的！！！
>
> 所以建议给每个类内成员赋予类内初始值。



#### 7.2 访问控制与封装——P240

与JAVA一样，通过public和private控制访问权限。

class关键字和struct关键字的**唯一区别**就是定义在第一个访问说明符之前的成员，在class中是private的，在struct中是public的。



##### 7.2.1 友元

如果一个类要授权那些非类成员的函数或者类访问它的private成员，那么就要把那些函数或者成员在类内部声明为friend。同时这些函数在类外部的声明和定义也不能缺省。



#### 7.3 类的其他特性



**定义一个类型成员**

就是自定义某账户那个类型在类中的别名。类似于我们使用的`string::size_type`就是一个例子。

定义方法是直接在public域内用using或者typedef定义。



**可变数据成员**

有事我们希望既是一个对象是const的，我们也能修改其中的某个数据成员，那么这时候就要将该数据成员声明为可变数据成员，声明方法就是直接在类型前加上mutable关键字。



##### 7.3.2 返回*this的成员函数

要注意该函数是否是const成员函数，如果是，那么它的返回值也应该是常量对象，要加上const声明。

同时，两个同名的成员函数是否是const成员函数能构成重载，也就是说，两个同名的函数但是一个是const成员函数，一个不是，这两个函数是重载的，不会报错。