# C++ Primer 5th

[TOC]



## Chapter 1.Getting Start

### Some command in Linux

- compile the source code

```bash
$ g++ (-Wall) -o <outname> <sourcefilename>
```

- get the return code of last executed program

```bash
$ echo $?
```





### iostream

iostream includes the istream and ostream.

### Standard Input and Output Objects

`cin` and `cout` are known as the standard input and output,respectively.

`cerr` is referred to as the standard error, and `clog` are for general information about the execution of the program.



### Output operator

The output operator is defined as `<<` in C++. It must have two operands, and the left-hand operand must be and ostream object. The result of output operator is its left-hand operand. That is, the result is the ostream on which we wrote the given value.



- endl

The `endl` is a special value called a manipulator. It has two function:

1. ending the current line;
2. **flushing the buffer.**

 Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.

- scope operator

We use scope operator `::` to say that int which namespace that we want to call the function or manipulator. eg:

```c++
std::cin
std::endl
```



### Input operator

The input operator `>>` behaves analogously to the output operator. Also return its left-hand operand.





### 1.4.3. Reading an Unknown Number of Inputs

```c++
#include <iostream>
int main()
{
	int sum = 0, value = 0;
	// read until end-of-file, calculating a running total of all values read
	while (std::cin >> value)
	sum += value; // equivalent to sum = sum + value
	std::cout << "Sum is: " << sum << std::endl;
	return 0;
}
```

   The statement `std:cin>>value` returns the left operand of input operator `>>` , which in this case is *std::cin*. When tests the condition of *while*, it tests *std::cin*.

​    When *istream* is used as a condition, the test is **true** if the *istream* hasn't encounter an error, and **false** if it encounter the end-of-file or invalid input( such as reading a value that is not the variable type is declared ). 

> ​    When we enter input to a program from the keyboard, different operating systems use different conventions to allow us to indicates end-of-file.
>
> ​	In Windows: press `ctrl` and `z` simultaneously.
>
> ​	In Unix: press `ctrl` and `d` simultaneously.



### 1.5. Introducing classes

​	A class defines a type along with a collection of operations that are related to that type.

​	Conventionally, we define a new class in a header file that we write our own, and the name of header files are derived from the name of class. Header files that we write usually have a suffix of **.h**, but some programmers use .H, .hpp, or .hxx. The standard library headers typically have no suffix at all. Compilers usually don’t care about the form of header file names, but IDEs sometimes do.



> TIPS:
>
> It can be tedious to repeatedly type these transactions as input to the programs you are testing. Most operating systems support file redirection, which lets us associate a named file with the standard input and the standard output:
>
> $ addItems  <infile >outfile
>
> Assuming $ is the system prompt and our addition program has been compiled into an executable file named addItems.exe (or addItems on UNIX systems), this command will read transactions from a file named infile and write its output to a file named outfile in the current directory.



#### 1.5.2 A First Look at Member Functions

​	dot operator --" . ", call operator -- "()".



## Part I: The Basics

### Chapter 2 Variables and Basic Types

xing

>  以下由于看英文版的速度太慢，而时间有限，故决定一刷先看中文版，二刷再看英文版，但在看中文版的时候以英文版作为辅助

- 算术类型（arithmetic type）
- 空类型（void）



#### 算术类型

​		C++标准规定了算术类型所占位数的**最小值**（浮点型有点特别，其规定的是有效数字的位数），同时允许编译器赋予这些类型更多的位数，这也就是说，在不同系统、不同编译器、不同机器下，同一种类型的位数可能不一样，这就导致了C++可移植性稍微差了点。

​		除了char这个基本字符型，C++还提供了一些支持国际化的字符型（扩展字符集）：wchar_t、char16_t、char32_t。他们的最小为数分别是16 、16 、32。后面两个是Unicode字符。

> 内置类型的机器实现
>
> ​		要赋予内存中某个地址明确的含义，必须首先知道存储在改地址的数据的类型，类型决定了数据所占的比特数以及该如何解释这些比特的内容。



##### 带符号类型和无符号类型

除了bool和扩展字符型之外，其他的整型可以分为有符号的和无符号的。

int、short、long和long long默认都是带符号的，要想得到无符号的，就要在这些声明前加上unsigned。

比较特别的是char类型，他有三种：char、signed char和unsigned char。虽然有三种，但只有两种表现形式：有符号的和无符号的。其中char并不就是signed char，它既可能是有符号的，也可能是无符号的，具体**由编译器决定**。

> 选择类型的一些准则：
>
> - 当数值肯定不为负数时，则选用无符号类型。
> - 一般选用int进行整数运算，而不用short，因为short的位数比较小。
> - 在算术表达式中不要用char或bool，因为char的有无符号不确定，如果确实需要用char来表示一个不大的整数，请指明signed和unsigned。而bool在算术表达式中只能取0或1两个值。
> - 执行浮点运算一般选用double。



##### 类型转换

​		对象的类型**定义了对象能包含的数据和能参与的运算**，其中一种运算被大多数类型支持，就是将对象从一种给定的类型**转换**为另一种相关类型。

​		常见的是把int型当做if或循环的判断条件，这里就会自动的转换为bool型。

###### 含有无符号类型的表达式

​		当一个算术表达式中既有无符号数又有int型是，那么int值就会转换成无符号数。

​		当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不是一个负值，这里有一个有趣的例子：

```c++
#include<iostream>

int main()
{
    unsigned u=42,i=10;
    std::cout<< i-u <<std::endl;
    std::cout<< (signed int)(i-u) <<std::endl;
    return 0;
}

//如果int是32位，其结果是：
//4294967264
//-32
```

​		这里涉及到数字在计算机中的表示方法——都是通过补码来完成存储和计算的，但是其**显示的结果取决于我们如果解释这个补码**，如果解释为无符号数（第一个输出语句），其结果就是一个正数，如果强制转换为有符号类型来解释，那么结果就是-32。

##### 2.1.3字面值常量

​		形如42的值被称作**字面值常量（literal）**，字面值常量的形式和值决定了它的数据类型。

**整形和浮点型字面值：**

​		八进制数以0开头，十六进制以0x开头。20的三种写法：20（十进制），024（八进制），0x14（十六进制）。

​		默认情况下，十进制的字面值是带符号数，八进制和十六进制既可能是有符号数也可能是无符号数。



**字符和字符串字面值** 	P36

​		单个字符用单引号括起来，字符串用双引号括起来，但是单个字符也能用双引号括起来。编译器会在每个字符串结尾添加一个空字符（'\0'），因此字符串常量的实际长度要比它的内容多1。



**转义序列	P36**

​		转义序列就是以反斜线开始的一些特殊字符。如：换行符，制表符等等。

​		还有一种比较特殊的被称作泛化的转义序列，用于表示字符，形式有：以\x后紧跟的1个或多个十六进制数字、以\后紧跟的1-3位八进制数字。数字部分表示的是字符对应的数值。



**指定字面值常量的类型	P37**

​		我们可以给字面值常量表达式通过添加前缀或后缀来改变他们的默认类型。具体见书P37。



**布尔和指针的字面值常量**

​		true和false是布尔类型的字面值，nullptr是指针字面值。



#### 2.2变量	P38

​		C++中，变量（variable）和对象（object）一般可以互换使用。

> 大多数人习惯认为对象是具有某种税局类型的内存空间。

​		C++中，初始化和赋值是两种完全不同的操作，但是在很多编程语言中，二者的区别几乎可以忽略不计，即使在C++中这种区别也无关紧要，但我们必须要有一个这种认识！



**列表初始化	P39**

​		C++提供了4中初始化的方法：

- int units_sold=0;
- int units_sold={0};
- int units_sold{0};
- int units_sold(0);

其中2、3两种用花括号来初始化的形式成为**列表初始化（list initialization）**。当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且存在丢失信息的风险，则编译器将报错，而其他形式的初始化并不会报错，且会丢失信息。具体例子见书P40。



**默认初始化	P40**

​		如果变量定义时没有杯指定初值，那么变量就会被默认初始化，被赋予”默认值“，默认值由变量类型决定，同时变量定义的位置也会对此有影响。**任何定义在函数体外部的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化，其值是未定义的。**



> 建议任何内置类型的变量都要手动初始化，因为如果未初始化，使用的将是一个不确定的值，这样造成的后果比逻辑错误更严重。



##### 2.2.2变量声明和定义的关系！！！！！！	P41

​		变量的声明和定义不是一个概念！！！

​		**声明**使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而**定义**负责创建与名字关联的实体。

​		变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

​		如果想要声明一个变量而非定义它，就在变量名前添加关键字extern，**而且不要显式地初始化变量：**

```c++
extern int i;	//声明i而非定义i
int j;	//声明并定义j
```

> 变量能且只能被定义一次，但是可以被多次声明。

​		变量的定义只能出现在一个文件中，如果其他文件要用到该变量，必须对其进行声明，但绝对不能重复定义。

>如果一个要在一个文件中使用另一个文件中的变量，则被使用的变量必须声明在文件作用域，也就是最外层，在其他文件中使用的时候要加上extern关键字。
>
>同时，要注意的是，要在一个文件中（前者）使用其他文件（后者）中的变量，我们有两种做法，第一种是直接在这个文件中include那个被使用的变量所在的文件，这样只用手动编译前者（也就是包含include的那个）；第二种方式是将不加include语句，但是要将后者编译成静态链接文件.o（使用-c选项），然后将前者与.o文件同时编译。

##### 2.2.3标识符

- 必须以字母或下划线开头

- 变量名一般用小写字母
- 用户自定义的类名一般用大写字母开头
- 多个单词一般用驼峰规则或者下划线来分割单词



#### 2.3复合类型	P45

​		这里先介绍两种符合类型：引用和指针。

##### 引用

> C++11中新增了”右值引用“，会在后面介绍，其主要用于内置类。严格来说，当我们使用术语”引用（reference）“时，指的是”左值引用“。xuanxiang

​		**引用（reference）**为对象起了另外一个名字，引用类型引用另外一种类型。定义形式：&d，d是声明的变量名。例如：`int ival=1024;int &refVal=ival;//refVal指向ival（是ival的另一个名字）`，**引用类型必须被初始化**，否则会报错，定义引用时，会把引用和它的初始值**绑定（bind）**在一起，并且无法重新绑定。

> 引用**并非对象**，它只是为一个已经存在的对象起另外一个名字。



##### 指针

- 指针本身就是一个对象，允许对指针赋值和拷贝
- 指针无须在定义是赋初始值，但在编程时最好手动初始化，以避免其随机值带来的影响。
- 给指针赋值，它们的类型必须一致。



​		定义形式：*d，d是变量名。需要配合`&取址符`来定义。

​		空指针不指向任何对象。可以通过以下几种方法得到空指针：

```c++
int *p1=nullptr;
int *p2=0;
//先#include<cstdlib>
int *p3 = NULL;
```

​		在现在的C++中，建议使用前两种形式。



**void\*指针**

​		`void*`指针能指向任何类型的对象。但由于我们不知道它指向的地址到底是什么类型的对象，因此我们不能直接操作void*指针所指的对象。



**指向指针的引用**

​		当`*`和`&`叠加使用时，例如：`int *&r=p;`，那么我们应该从右往左读，最靠近变量名的修饰符决定了变量的性质。这里的r是一个指向指针的引用。



#### 2.4 const限定符

​		必须初始化，且不能修改。

​		默认情况下，const对象仅在文件内有效，如果要在不同文件中使用同一个const变量，那么就要在定义和声明处都加上extern关键字（非const变量只用在声明处加上extern），同时定义是定义在文件作用域。



> 今后要注意区分：指向常量的指针和常量指针。这是两个东西而不是一个。声明方式也不一样。具体见书P56。



##### constexpr和常量表达式

​		常量表达式（const expression）是指**值不会改变并且在编译过程就能得到计算结果**的表达式。对于字面值，要使用const声明才能算作常量表达式。

###### constexpr变量

​		constexpr关键字用于声明常量表达式变量，编译器会帮助验证你所定义的变量是不是常量表达式。



#### 2.5 处理类型	P60



##### 2.5.1 类型别名

​		定义一个类型的别名的传统方法是用关键字typedef：`typedef double wages;`。C++11提供了一种新的方法：使用using——别名声明，例子：`using SI = Sales_item;`，使SI等效于Sales_item。



##### 2.5.2 auto类型说明符

​		auto类型可以自动让编译器通过初始值判断这个变量是什么类型的，因此auto定义的变量必须有初始值。



##### 2.5.3 decltype 类型指示符

​		decltype返回的是操作数的数据类型，可以用它来声明一个变量，而不需要像auto一样必须通过初始化来定义。例：

```c++
const int ci=0,&cj=ci;
decltype(ci) x=0;
decltype(cj) y=x;
```

​	如果decltype后括号中的表达式的内容是解引用操作，那么decltype将得到引用类型，如果是外层带括号的表达式`decltype((ci))`，那么得到的也是引用类型，如果只是一个表达式，但是不带括号，例如：`decltype(ci+0)`，那么得到的就是int型。



#### 2.6 自定义数据结构 P64



##### 2.6.1 struct结构体

例：

```c++
struct Sales_data{
    std::string bookNo;
    unsigned units_sold=0;
    double revenue=0.0;
};
```

​		以struct关键字开始，紧接着的是结构体的名字，然后是花括号包括的具体内容，最后别忘了加上分号（这是因为可以直接在右花括号后面直接接变量名以示对该类型对象的定义）。





##### 2.6.3 编写自己的头文件

头文件的名字必须和类的名字一致，同时，为了保障当头文件被多次包含到一个文件中的时候也能正常工作，需要用预处理器来解决问题。

**预处理器**

​		预处理器是在编译之前执行的一段i程序，可以部分的改变我们所写的程序。之前已经用到了一项预处理功能#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。

​		我们这里要用到的是**头文件保护符（header guard）**，头文件保护符以来与处理变量。预处理变量只有两种状态：已定义和未定义。#define指定把一个名字设定为预处理变量，#ifdef和#ifndef用来检测预处理变量是否被定义，前者当被定义时为真，后者当为被定义时为真，当检查结果为真时，则执行后续操作直到遇到#endif指令为止。

> 整个程序中的预处理变量包括头文件保护符必须唯一，通常使用类的名字来构建保护符的名字，同时，预处理变量的名字全部大写。





### 第三章 字符串、向量和数组

#### 3.1 命名空间的using声明	P74

​		之前我们在使用每个标准库函数前都加上了`std::`来说明我们使用的是命名空间std中的名字，但是这样显得有些繁琐，如今我们可以用**using声明**来简化，形式如下：

```c++
using namespace::name;
//一个例子：
using std::cin;
```

​		一旦声明了上述语句，就可以在后面的代码中直接访问命名空间中的名字。

注意事项：

- 每个名字都需要独立的using声明
- 头文件不应包含using声明



#### 3.2 标准库类型string	P75

本节介绍一些string的常用操作

##### 3.2.1 定义和初始化string对象

初始化string有以下几种方式：

```c++
//1.
string s1;
//2.
string s2(s1);		//s2是s1的副本
//3.
string s2 = s1;		//等价于s2(s1),s2是s1的副本
//4.
string s3("value");		//s3是字面值“value”的副本，除了字面值最后的那个空字符外
//貌似string s3{"value"}也是一样的效果
//5.
string s3 = "value";	//等价于上一种方式
//6.
string s4(n,'c');	//把s4初始化为由连续n个字符c组成的串
```



##### string对象上的操作

**读写string对象**

可以通过cin和cout来读写。

> 在执行读操作的时候，string对象会自动忽略开头的空白并从第一个真正的字符开始读起，直到遇见下一处空白为止。



**读取位置数量的string对象**

```c++
int main()
{
    string word;
    while(cin >> word)
        cout<<word<<endl;
    return 0;
}
```

该程序在遇到EOF或非法输入时结束输入。



**用getline读取一整行**

为了让string能读取到字符串中的空白，我们使用`getline`来代替`>>`，getline读取一次会读取到遇到换行符的位置（**会读入换行符但是不会将换行符存入字符串中**）。示例：

```c++
int main()
{
    string line;
    while(getline(cin,line))
        cout<<line <<endl;
    return 0;
}
```



**string的empty和size操作**

`string.empty()`用来判断string对象是否为空，若为空则为真。`string.size()`返回的是string对象的长度。



**string::size_type类型**

`string.size()`返回的是一个string::size_type类型的值，而不是int或unsigned。它是一种无符号类型，注意不要轻易的把无符号类型和有符号数放在一个表达式中，否则有符号数会被自动转成无符号数。

**比较string对象**

可以直接用==、!=、<、<=、>、>=等操作符来比较string，不等关系比较的原则是比较第一个不相等的字符的字典序，如果两个不等长，但是短字符串是长字符串开头的一部分，那么短字符串小。

**string对象的赋值和加法**

比较简单，具体见书P80



##### 3.2.3 处理string对象中的字符

cctype头文件中提供了一系列标准库函数来处理字符串中的字符。P82

> C++版本的C标准库头文件
>
> C++版本的C标准库头文件的名称与C版本的有些不一样，C++版本的将C版本的后缀.h去掉了，在第一个字母前加上了一个字母c，例如：C的一个标准库头文件name.h的C++版本是cname，在以后的C++程序中，都建议使用C++版本的标准库头文件



**范围for语句**

```c++
for( declaration: expression)
    statement
```

与Java中的范围for语句功能一样。

**用范围for语句改变字符串中的字符**

要改变string对象中字符的值，必须把循环变量定义成引用类型，假设我们要把整个string对象转换成大写，只要对其中每个字符调用toupper函数并将结果再赋给原字符就可以了:

```c++
string s("Hello World!!!");
for(auto &c:s)
    c=toupper(c);
cout<<s<<endl;
```



**只处理一部分字符**

用**下表运算符（[]）**可以处理特定位置的字符。下标从0开始。

> **注意！！！**
>
> C++标准并不要求标准库检测下标是否合法，一旦使用了超出范围的下标，就会产生不可预知的结果。其下表范围必须大于等于0，小于size()的值。



#### 3.3 标准库类型vector	P86

​		vector表示对象的集合，其中所有对象的类型都相同。集合中每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也常被称作**容器（container）**。vector在头文件vector中。

​		vector是一个类模板，它本身不是类，使用模板时需要指出编译器应该把类实例化成何种类型，类型写在尖括号中。示例：

```c++
vector<int> ivec;
vector<Sales_item>	Sales_vec;
vector<vector<string>> file;	//以前，还需要在string后的两个尖括号中加一个空格来区分>>符号
```



##### 3.3.1 定义和初始化vector对象

P87

**值初始化**

​		当使用`vector<T> vec(n)`来创建一个vector时，会创建一个能容纳n个元素的vector，此时库会创建一个之初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型`T`决定。

​		如果vector对象的元素是内置类型，如int，则元素初始值自动设为0，如果是某种类，如string，则由该类默认初始化。



**列表初始值还是元素数量**

对于`vector<int>`的初始化，可能会有歧义，这里就要通过圆括号和花括号来区分了，简单来说就是，圆括号决定的是vector本身的属性，花括号的内容是vector内每个元素的值。



##### 3.3.2 向vector对象中添加元素

​		由于C++的vector能高效地增长，因此我们不需要在创建vector的时候指定大小，只有一种情况是例外，那就是所有元素的值都一样时，其他情况一般都是先定义一个空的vector对象，再在运行时向其中添加具体的值。

​		添加元素的操作由vector的成员函数**push_back**完成，例：`vec.push_back(T);`，其中vec是一个定义好的vector对象，T是vector包含的元素类型。

> 由此可见vector与一种数据结构很相似——栈。
>
> 在使用vector的时候，有一条隐含的要求：如果循环体内部包含有vector对象添加元素的语句，则不能用范围for循环。具体原因在5.4.3节介绍。



##### 3.3.3 其他vector操作	P91

​		访问vector中的元素也能通过范围for循环。

**计算vector内对象的索引**

​		vector内元素的索引与string一样，也是从0开始算起的。

**不能用下表形式添加元素（但是能通过下表来修改元素的值）**

​		只能通过push_back来添加。

> vector也存在下标不在正确范围内的情况，而且非常常见，由于这种错误不能被编译器发现，因此需要我们编程的时候非常仔细，同时，确保下标合法的一种有效手段就是尽可能使用范围for语句。
>
> 通过下表访问不存static在的元素会导致严重后果——缓冲区溢出(buffer overflow)，这也可能导致程序出现安全问题。



#### 3.4 迭代器介绍

​		除了通过下表运算符访问对象的元素，还能通过**迭代器（iterator）**。

​		标准库中除了vector这个容器，还定义了其他的容器。所有标准库容器都可以使用迭代器，但是其中只有极少数几种才同时支持下标运算符。

​		string虽然不是容器，但是也支持迭代器。

​		需要注意的是通过end()成员返回的迭代器指向的是为元素的下一位置，即一个不存在的“**尾后(off the end)**”。所以被称为**尾后迭代器（off-the-end iterator）**。常用来配合begin()来判断是否处理完对象中的所有元素。

- 迭代器与指针类似，也有**解引用**的操作。

- 但凡是使用了迭代器的循环体都不要向迭代器所属的容器添加元素，否则会使迭代器失效。



##### 3.4.2 迭代器运算

​		string和vector的迭代器提供了更多额外的运算符——P99。

> 灵活运用迭代器的各种运算可以完成很多功能。
>
> P100也的二分法值得研究。



#### 3.5 数组

​		数组的大小必须在编译的时候已知，因此必须是一个常量表达式。同时，数组的类型也必须明确，不能使用auto。



**字符数组的特殊性**

​		字符数组结尾还会被加上一个空字符`\0`，它会占用一个数组的空间，如果空间不够则会报错。



**指针数组和数组的指针**

```c++
int *ptrs[10];		//ptrs是含有10个整型指针的数组
int &refs[10]=	/* ? */;	//错误：不存在引用的数组，因为引用不是一个对象
int (*Parray)[10] = &arr;	//Parray指向一个含有10个整数的数组；
int (&arrRef)[10] = arr;	//arrRef引用一个含有10个整数的数组；
```



##### 3.5.2 访问数组元素

在使用数组下表的时候，通常将其定义为**size_t**类型。size_t是一种机器相关的无符号类型，他被设计得足够大以便能表示内存中任意对象的大小。定义在cstddef头文件中。

> 数组也要注意不要让下表超出了范围！！！否则会产生错误。



**标准库函数begin和end**

​		标准库函数begin和end用于获取数组的首个元素的指针和最后一个元素的下一位值的指针。使用方法：

```c++
int ia[]={...};
int *beg = begin(ia);
int *last = end(ia);
```



> 注意！
>
> 指针和迭代器可以比较的，条件是两个指针或者迭代器指向同一个对象中的元素或者尾元素的下一个位置。
>
> 可以利用这个特性来遍历。



**使用数组初始化vector对象**

```c++
int int_arr[] = {0,1,2,3,4,5};
vector<int> ivec(begin(int_arr),end(int_arr));	//把int_arr的首元素地址和尾后地址当做初始化参数就行了
```

​		也能只拷贝数组中的一部分，只要改变输入的起始地址就行了。



#### 3.6 多维数组

**重要！！！**

> 使用**范围for循环**语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，否则auto类型会把控制变量设为指针类型的！！！



**类型别名简化多维数组的指针**

​		如果用typedef定义一个数组的别名，那么中括号应该放在新名字的后面而不是原名字的后面。。。不知道为啥。



### 第四章 表达式

#### 4.1 基础	P120

​		一般二元运算符要求运算对象类型相同，实际上有时候不同也没关系，编译器会自动将他们转换成同一类型（如果原类型能转换的话）。

​		小整数类型（如bool、char、short等）通常会被**提升（promoted）**成较大的整数类型。



**重载运算符**

​		当运算符作用于类类型的运算对象时，用户可以自定义其含义。



**右值和左值**

https://www.cnblogs.com/catch/p/3500678.html

​		C语言中，左值可以位于赋值语句的左侧，右值不行。而在C++语言中，二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象或者函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。

>当一个对象被用作右值的时候，用的是对象的值（内容），当做向被用作左值的时候，用的是对象的身份（在内存中的位置）（也就是地址？）



##### 4.1.3 求值顺序

​		对于那些没有规定运算对象按照什么顺序求值的运算符来说，其结果是未定义的，比如乘号*和<<运算符。

```c++
int i=0;
cout<< i << " "<< ++i <<endl;	//未定义的
```

​		我们无法推断上述程序的结果，可能输出的是1 1，也可能是0 1，甚至编译器还可能做完全不同的操作。

> 如果一个未定义运算顺序的表达式中，多个运算对象影响了同一个对象额时候，则它是一条错误的表达式。将产生未定义的行为。

​		但是有4中运算符明确规定了运算对象的求职顺序。

- 逻辑与（&&），先计算左侧运算对象的值，为真的时候才继续求右侧运算对象的值。
- 逻辑或（||），先计算左侧运算对象的值，为假是才计算右侧对象的值。
- 条件运算符（?:）
- 逗号运算符（,）



> 以下两条经验准则对书写复合表达式有益：
>
> 1. 拿不准的时候最好用括号来强制让表达式的罪和关系复合程序逻辑的要求
> 2. 如果表达式中改变了某个运算对象的值，则在表达式的其他地方不要再使用这个运算对象。



#### 4.2 算术运算符

​		bool值不应该参与运算，例：

```c++
bool b=true;
bool b2= -b;	//b2仍然是true！
```

​		当bool值参与运算时，将被提升成整数值1，对它求负后结果是-1，,1再转换回布尔值并将其作为b2的初始值，由-1！=0，所以b2仍然是true。



- %取余运算符的运算对象不能包含浮点类型，只能是整型。



**关系运算符**

​		关系运算符返回的结果是布尔值，因此将几个关系运算符连写在一起会产生意想不到的结果：

```c++
if(i<j<k)	//若k大于1，则条件肯定为真！
if(i<j && j<k)	//要正确实现逻辑应该这样写
```



**相等性测试与布尔字面值**

> 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象，因为true会被转换成1，false会被转换成0。



#### 4.4 赋值运算符	P129

- 对于int型的赋值，有一点有意思的是如果不加花括号，把一个浮点数字面值复制给一个整型常量i时，可以编译运行，但结果会截取去掉小数部分，如果在浮点数字面值的外部加上了一个花括号，那么编译就会报错，因为列表初始化不允许把一个占用空间较大的类型转换成一个占用空间较小的。

例如：

```c++
    int k;
    k=3.145;	//正确，k=3
    k={3.14};	//错误，编译会报错：窄化转换
```



**赋值运算符满足右结合律**

​		连等的情况先从左右侧的等号开始赋值，返回的是赋值运算符左侧的运算对象。



**赋值运算符的优先级较低**

> 赋值运算符的优先级比关系运算符的低，因此在条件语句中，赋值部分通常应该加上括号。



#### 4.5 递增和递减运算符	P131

> 前置递增/递减运算符直接返回修改后的值，而后置递增/递减运算符会将原始值处存下来并返回。
>
> 如果我们不需要修改原来的值，用后置版本的运算符就是一种浪费——因为浪费了存储原始值的空间，所以在不需要修改或获取原始值的时候，一般都用前置运算符。

```c++
auto pbeg=v.begin()
while(pebg!=v.end() && ^pbeg>=0)
    cout<< *pebg++ <<endl;		//这种写法比下面的更简洁，后置运算符的优先级比*高

	cout<< *pebg <<endl;
	pebg++;
```



#### 4.6 成员访问运算符	P133

- 点运算符，直接用于对象本身。
- 箭头运算符，用于对象的指针。



#### 4.7 条件运算符	P134

- 在输出表达式中使用条件运算符记得要在最外层加上一对括号，否则会输出意想不到的结果——P135



#### 4.8 位移运算符	P135

> 关于符号位如何处理没有明确的规定，取决于不同的机器，因此强烈建议仅将位移运算符用于处理无符号类型

- 如果唯一运算符的运算对象是“小整型”，那么就会被自动提升成较大的整数类型，例如int。

- 位移运算符（又叫IO运算符）满足左结合律。



#### 4.9 sizeof运算符

- sizeof运算符返回一条表达式或一个类型名字**所占的字节数**。
- sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。

- 两种形式：`sizeof(type)`和`sizeof expr`



#### 4.10 逗号运算符

- 逗号运算符有两个运算对象，按照**从左向右**的顺序依次求值。
- 逗号运算符的结果是右侧表达式的值，左侧的值会被丢弃掉。



#### 4.11 类型转换	P141

##### 4.11.1 算术转换

- 整型提升

  如果一个较小类型的整数类型的所有值都能被存在int中，那他就会被提升成int类型。例如:bool、char、signed char、unsigned char、short和unsigned short都能可能被转换成int。

- 无符号类型的运算对象

  如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。

  如果不一致，那么有如下规律：如果无符号类型的所有制都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

  这也就是说，如果无符号类型所占的二进制位数大于等于带符号类型的，那么就会被转换成无符号类型，如果无符号类型所占的二进制位数小于带符号类型的，那么就会被转换成带符号类型。



##### 4.11.2 其他类型隐式转换



##### 4.11.3 显示转换

**命名的强制类型转换**

格式：` cast-name<type>(expression) `

其中cast-name有四种：static_cast、dynamic_cast、const_cast、reinterpret_cast。

其中static_cast、const_cast、reinterpret_cast能完成传统C/C++类型转换的功能：

- static_cast

  完成的是传统类型强制转换，但是被转换的不能包括底层const。

- dynamic_cast

  支持运行时识别类型。

- const_cast

  只能改变运算对象的底层const，去掉或者加上某个对象的const属性。

- reinterpret_cast

  顾名思义，就是重新解释一遍被改变的对象，但是对象本身的类型不变，可以理解为只是改变了对象类型的名字，但是这个名字所指的对象类型还是没有变化，这种类型转换可能会带来一些错误。



### 第五章 语句

#### 5.1 简单语句	P154



#### 5.4 条件语句	P156

其中值得注意的就是switch语句了，switch后括号中的表达式只能是整型或者枚举型。case后的表达式必须是整型常量表达式。



其他语句与C语言中的无异。除了多了一个毫无用处的goto语句。。。感兴趣的可以自行查阅。

### 第六章 函数

#### 6.1 函数基础	P182

**实参是形参的初始值。**



**函数返回类型**

函数的返回类型不能是数组类型或函数类型，但是可以是指向数组或函数的指针。



**自动对象**

**局部静态对象**



##### 6.1.2 函数声明

函数的定义只能有一个，但是声明可以有多次。

函数声明 不用包含函数体，因此形参的名字可以省略，但是写上形参的名字还是有好处的，它可以帮助使用者更好的理解函数的功能。

函数的三要素：

- 返回类型
- 函数名
- 形参类型

这三要素描述了**函数的接口**，说明了调用该函数所需要的全部信息。函数声明也称作**函数原型**。



##### 6.1.3 分离式编译

简单来说，C++的源程序完成后要经过**编译**和**链接**两个步骤才能生成可执行文件。

当代码分离时，我们要把需要用到的代码都告诉编译器，否则会出现变量或函数未定义的情况。

> 例如，在Linux系统下用g++编译器，若不带任何参数，则编译器会自动编译链接你所指定的文件，若加上参数-c，那么编译器只会编译源文件生成**对象代码(Object Code)**，在Linux系统下后缀名是`.o`。然后再用编译器把对象文件*链接*在一起生成可执行文件。
>
> 具体请阅读书上P187.



#### 6.2 参数传递	P187

参数传递有两种方式：

- 传值
- 传引用

当形参是引用类型时，就是传引用调用，在函数内部对形参的改变会影响外部原来的值，而传值调用则不会。



**使用引用避免拷贝**

当实参所占字节比较多时，使用引用传参来避免拷贝是一个非常好的做法，若在函数中不需要改变原来的值，则最好将其声明为常量引用。既能节省空间，又能避免在函数中对实参的改变。

**使用引用形参返回额外信息**

一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。



> 当实参是右值时，形参不能是引用类型。



##### 6.2.3 const形参和实参

当用实参初始化形参时会忽略掉顶层的const。

在C++语言中，允许定义若干具有相同名字的函数，但是前提是不同函数的形参列表应该有明显的区别。对于编译器来说，因为顶层的const被忽略掉了，所以两个同名函数仅仅具有形参const和非const差别的时候是不能通过编译的。



**尽量使用常量引用**



##### 6.2.4 数组形参

```c++
void print(const int*);
void print(const int[]);
void print(const int[10]);	//这里的维度表示我们期望数组含有多少元素，实际不一定
//这三种声明都是等价的，最后一个声明中二的维度并不是强制满足的。
```

因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术。

**1. 使用标记指定数组长度**



**2. 使用标准库规范**

使用标准库的begin()和end()标准库函数。

**3. 显式传递一个表示数组大小的形参**



##### 6.2.5 main：处理命令行选项

这一小节让我明白了命令行参数的接收原理。

main()函数有两个可选的形参:

```c++
int main(int argc,char *argv[])	{/*...*/}
//其中第二个参数等价于char **argv,指向一个二维数组
```

其中，第一个参数表示第二个参数数组中字符串的数量，不需要用户输入。

例如，当用户输入以下命令行时：

```bash
prog -d -o ofile data0
#其中prog是一个你已经写好的程序名
```

当实参传给main()函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素一次传递命令行提供的实参。最后一个指针之后的元素保证为0。

以上面的命令行为例，argc应该等于5，argv应该包含如下的C风格字符串：

```c++
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

> 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入



##### 6.2.6 含有可变形参的函数

两种方法：

- 实参类型相同时：通过initializer_list类型
- 实参类型不同：模板（第十六章介绍）

**initializer_list形参**

这也是一个模板，只不过别人帮你写好了。

initializer_list提供的操作——P198

> 感觉这跟vector一样，vector也能用作可变数量的形参。



**省略符形参**

省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。

省略符形参只能出现在形参列表最后一个位置。



#### 6.3 返回类型和return语句

return语句种植当前正在执行的函数并将控制权返回到调用该函数的地方。

如果返回的是引用类型，那么也不会执行拷贝操作，有利于节省空间。

**同时要注意！！！千万不要返回局部对象的引用或指针，因为函数完成后，局部变量所占的存储空间也随之会被释放掉，返回的引用或指针会变成未定义的值。**



##### 6.3.3 返回数组指针——P205

语法上来说，想要定义一个返回数组的指针或引用的函数比较繁琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名。

如果不使用类型别名，那么声明的形式会非常麻烦：`int (*func(int i))[10];`，它的格式是`Type (*function(parameter_list)) [dimension];`

还有一种方法是使用**尾置返回类型**。还是上面那个例子，改写成尾置返回类型后为：`auto func(int i) -> int(*)[10];`



**使用decltype**也能简化，前提是你要知道你返回的是哪个数组，还要在函数声明时加上一个*号。



#### 6.4 函数重载

如果同一作用域内的几个函数名字相同单形参列表不同（返回值也可以不同），我们称之为重载。

> main函数不能重载



形参的顶层const不会影响传入函数的对象，因此两个同名函数声明只存在顶层const的区别的话，那么这两个函数声明等价。



#### 6.5 特殊用途语言特性



##### 6.5.1 默认实参

```c++
typedef string::size_type sz;
string screen(sz ht=24,sz wid = 80,char backgrnd = '');
```

像这种直接在形参列表中赋值的形式就是赋给形参默认值，后面的值就是默认实参。这样既能接收用户传入的值也能在用户没有传入值的时候赋给形参默认值。

同时，要注意如果形参列表中既有没有默认值的形参，又有有默认值的形参，那么没有默认值的形参应该放在有默认值的形参的前面。

##### 6.5.2 内联函数与constexpr函数

类似宏指令define，在编译阶段将内联函数名展开成函数。只需在函数的返回类型前面加上关键字inline就能将函数声明成内联函数了。

> 内联说明只是想编译器发出一个请求，编译器可以选择忽略这个请求。
>
> 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。



**constexpr函数**

constexpr函数是指**能**用作\返回常量表达式的函数。

- constexpr函数被隐式地指定为内联函数；

也就是说，在一定条件下，这个函数可以用作常量表达式，这个条件就是以下两个约定：

- 他的返回类型以及所有的形参类型都得是字面值类型；
- 函数体中必须有且只有一条return语句。

被标记为constexpr的函数也可以不能被用作常量表达式，只要不满足上述条件就行了，我们也允许constexpr函数的返回值不是常量，例子在书上P214。

> constexpr函数不一定返回常量表达式。

**通常把内联函数和constexpr函数的定义放在头文件中**



##### 6.5.3 调试帮助

利用assert预处理宏和NDEBUG预处理变量来辅助调试、debug。

编译器和预处理器还定义了一些对于程序调试来说很有用的变量：

- _ _func _ _，其值等于每个函数的名字(中间的空格是为了在markdown下避免被解释为标记符号，实际上是连着的两个下划线，下同)
- _ _ FILE _ _，存放文件名的字符串字面值
- _ _ LINE _ _，存放当前行号的整型字面值
- _ _ TIME _ _，存放文件编译时间的字符串字面值
- _ _ DATE _ _，存放文件编译日期的字符串字面值



#### 6.6 函数匹配——P217

由于函数重载，因此在一个函数有多个重载的时候，调用这个函数时就需要编译器对函数进行匹配度分析，寻找最佳匹配，如果没有最佳匹配，编译器会报错。具体匹配过程请看书。

> 我们在设计重载的函数时应尽量避免调用时需要强制类型转换的形参集合。



#### 6.7 函数指针

函数指针也指向某种特定类型的函数。而函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：

```c++
bool lengthCompare(const string&,const string&);
```

该函数的类型是`bool (const strig&,const string&)`。想要声明一个可以指向该函数的指针，只需要用指针名替换函数名即可：

```c++
bool (*pf) (const string&,const string&);
```

pf和*的括号必不可少，不然就变成了返回类型为bool\*的名为pf的函数了。

- 给函数指针赋值时取址符可选，必须的是函数的名字。
- 通过函数指针调用函数时的解引用符号*也是可选的。
- 也能给函数指针赋予nullptr和0。
- 函数指针也能作为形参，作为形参时，指针前的星号可以省略，此时看起来就像一个函数声明，但是却是当成指针来使用的。
- 我们写的函数能返回函数的指针类型，但是不能返回函数类型。
- 由于函数指针作为形参或返回值的时候写法比较繁琐，推荐使用别名来简化，也可使用auto和decltype来帮助判断返回的函数指针是什么类型。详情请看书P222。





### 第七章 类

类的基本思想是**数据抽象**和**封装**。数据抽象是一种依赖于**接口**和**实现**分离的编程（以及设计）技术。

类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。



#### 7.1 定义抽象数据类型

**引入this**

这里的一个重要概念就是this。

当我们调用成员函数时，成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如，如果调用`total.isbn()`，则编译器负责把total的地址传递给isbn的隐式形参this，可以等价的认为编译器将该调用重写成了如下的形式：`Sale_data::isbn(&total)`，当然这只是个伪代码，用来说明原理。

this总是指向调用成员函数的“这个”对象，所以this是一个常量指着，即不能改变this指向的对象，但能改变它指向对象的内容。



**const成员函数**

由于调用成员函数是通过this来指向对象的，正如上面的那个伪代码，从那可以看出，因为this的类型为`Sales_data *const`，那么如果调用该成员函数的对象是一个常量对象，那么就会出错，因为一个非常量指针不能绑定在一个常量对象上。这时我们需要将this对象的类型修改为指向常量对象的常量指针`const Sales_data *const`，这样即使我们使用一个常量对象也能调用该常量函数了，增添const的形式如下，即在参数列表后加上一个const:

`std::string isbn() const{return bookNo;}`

像这样使用const的成员函数被称作常量成员函数，当然，在这些函数中不能改变this指向对象的内容了。

> 因此，我们在设计一些常量对象也能使用的成员函数时，需要将他们声明为常量成员函数。



**构造函数**

- 没有返回值
- 不能被声明为const



**构造函数初始值列表**

```c++
Sales_data(const std::string &s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n) { }
```

其中形参列表后面的冒号和花括号前面的部分就是构造函数初始值列表了，它的意思是用s来初始化booNo，用n初始化units_sold，用p和n的乘积初始化revenue。

> 没有出现在初始值列表的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。
>
> 如果类包含有内置类型或者符合类型的成员，这些成员的默认初始化的值是未定义的！！！
>
> 所以建议给每个类内成员赋予类内初始值。



#### 7.2 访问控制与封装——P240

与JAVA一样，通过public和private控制访问权限。

class关键字和struct关键字的**唯一区别**就是定义在第一个访问说明符之前的成员，在class中是private的，在struct中是public的。



##### 7.2.1 友元

如果一个类要授权那些非类成员的函数或者类访问它的private成员，那么就要把那些函数或者成员在类内部声明为friend。同时这些函数在类外部的声明和定义也不能缺省。



#### 7.3 类的其他特性



**定义一个类型成员**

就是自定义某账户那个类型在类中的别名。类似于我们使用的`string::size_type`就是一个例子。

定义方法是直接在public域内用using或者typedef定义。



**可变数据成员**

有事我们希望既是一个对象是const的，我们也能修改其中的某个数据成员，那么这时候就要将该数据成员声明为可变数据成员，声明方法就是直接在类型前加上mutable关键字。



##### 7.3.2 返回*this的成员函数

要注意该函数是否是const成员函数，如果是，那么它的返回值也应该是常量对象，要加上const声明。

同时，两个同名的成员函数是否是const成员函数能构成重载，也就是说，两个同名的函数但是一个是const成员函数，一个不是，这两个函数是重载的，不会报错。



##### 7.3.3 类类型

只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，他就被认为是声明过了（但尚未定义），因此类允许包含指向他自身类型的引用或指针。

##### 7.3.4 友元再探

一个类可以声明另一个类或者另一个类的成员函数作为友元。

**友元声明和作用域**

类和非成员函数的声明不是必须在他们的友元声明之前。但是要使用该类或者非成员函数时，他们的声明必须在使用处之前。

友元可以定义在一个类的内部，但是这也不能算是声明，我们必须在类的外部提供相应的声明从而使得函数可见。具体例子见P252。



#### 7.4 类的作用域——P253

> 一个类就是一个作用域

如果一个成员函数定义在类之外，并且它的返回类型是类中的某个类型，那么返回类型必须指明它是哪个类的成员，因为只有在出现了函数名之后才进入到类的作用域。



##### 7.4.1 名字查找与类的作用域

类的定义分为两步：

1. 首先，编译成员的声明；
2. 直到类全部可见后才编译函数体。

因此，在一个成员函数中可以使用声明在其后面的数据成员或成员函数。

> 类型名的定义通常出现在累的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。



#### 7.5 构造函数再探

也许之前我们对使用构造函数初始值列表感到迷惑？为什么要有这个东西呢？为什么不能在构造函数内部赋给成员初始值呢？

其实，只要进入到构造函数体内部开始执行，也就是构造函数的花括号内部时，成员的初始化就完成了，而如果在此之前我们在该类中定义了一些const或者引用类型的数据成员，就会报错，因为我们没有将这些数据成员初始化。**这时就必须要使用构造函数初始值列表了。**

构造函数初始值列表只用于说明初始化成员的值，而不限定初始化的具体执行顺序，成员初始化顺序与他们在类定义中出现的顺序一致。因此，**最好令构造函数初始值的顺序与 成员函数声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。**



**委托构造函数**

就是在一个构造函数的成员初始值列表中写上调用其他构造函数来完成初始化工作。

**默认构造函数**

当对象杯默认初始化或之初始化时自动执行默认构造函数。

##### 7.5.4 隐式的类类型转换

> 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数乘坐转换构造函数。

如Sales_data类中分别只接受string和istream&的两个构造函数。

注意：编译器只会自动的执行一步类型转换。例如从字符串字面值转换到string，但不能继续从string转换到Sales_data。

**如何抑制构造函数定义的隐式转换？**

只需在相应的构造函数前加上explicit关键字即可。

标明了explicit的构造函数只能用于直接初始化，而不能用于隐式转换。

> 为何要抑制隐式转换？
>
> - 个人认为是因为有一些函数的参数传递如果通过隐式转换来完成，那么其目的就会变得非常不明确。
>
>   例如有一个函数`int getRevenue(Sales_data);`，如果它支持string类型的隐式转换，那么调用这个函数就可以写成`getRevenue("abcdefg");`，很明显，这里的函数传入一个string会让非代码编写者的阅读代码的人感到非常困惑，除非它知道Sales_data类存在这么一个隐式类型转换。同时，这样的调用也会造成一些逻辑错误，因为string转换成Sales_data类中revenue的值会被初始化为0，可能影响程序结果。



##### 7.5.5 聚合类

如果一个类满足以下条件：

- 所有成员都是public的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有virtual函数

我们就称它是聚合的。

例如，下面一个简单的例子：

```c++
struct Data{
    int ival;
    string s;
};
```

我们可以使用花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员。

注意：初始值列表的顺序要与数据成员声明的顺序一致，同时，初始值列表的元素个数绝对不能超过类的成员数量。



##### 7.5.6 字面值常量类

一个字面值常量类至少包含一个constexpr构造函数。同时，其数据成员都必须是字面值类型。

在构造函数前加上constexpr关键字就能声明constexpr构造函数了。

我们定义constexpr类的原因是想让该类能被当做常量表达式使用。





#### 7.6 类的静态成员——P268

在类成员前加上static就能声明一个静态成员了。

类的静态成员是该类的所有对象所共有的，同时只要类完成了定义，他们也就完成了定义，也就可以在没有定义对象时就访问这些静态成员。

- 静态成员不能调用非静态成员
- 静态类成员函数中不能使用this指针

> 通常情况下，类的静态成员不应该在类的内部初始化。
>
> 但是我们能为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr或const。
>
> 同时，即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员，该定义不需指定初始值，因为在类内部已经被初始化了。
>
> 这里有一点我觉得很“奇葩”的限制：
>
> - 如果是一个整数类型的静态数据成员，要被类内初始化的话只需加上const
> - 如果是一个非整数型（例如double）的静态数据成员，要类内初始化就要加上constexpr
>
> 不知道这里深层次的原理是什么。。。书上目前还没有具体的解释。



## 第二部分 C++标准库

### 第八章 IO库——P278



本章主要讲了三个IO库：

1. iostream
2. fstream
3. sstream

分别是用于从控制台、文件、内存string对象读取数据的IO库。

还定义了一组类型用来操纵wchar_t类型的数据，宽字符版本的类型和海曙的名字以一个w开始。例如：wcin、wcout和wcerr分别是对应cin、cout、cerr的宽字符版对象。其余的请看书P278。



#### 8.1 IO类——P278

**IO类之间的关系**

ifstream和istringstream都继承自istream，ofstream和ostringstream都继承自ostream。因此我们可以像使用istream或ostream一样来使用其他对象。

**IO对象无拷贝值或赋值**

**8.1.2 条件状态**

所有的IO类都具有一系列访问和操纵流的**条件状态**的函数和标志。

所谓条件状态就是IO对象所处的状态：是否崩溃，是否遇到了eof，是否处于有效状态等等。

IO类都包含一些标志成员和函数来判断和管理条件状态，具体请见书上P279表格8.2。

**8.1.3 管理输出缓冲**

每个输出流都管理一个缓冲区，用来保存duixiangduixiang程序读写的数据。例如，如果执行下面的代码：

```c++
os<<"please enter a value:";
```

该字符串可能被立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。

缓冲机制能将程序的多个输出操作合成单一的系统级写操作（例如：打印），以此来减少多次系统级写操作的花费（因为系统机械操作可能很耗时）。

于是我们可以将多个输出操作县写入缓冲区，再一次将缓冲区刷新。

导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：

- 程序正常结束，main函数的return会执行刷新缓冲操作。
- 缓冲区满时，要刷新缓冲区才能继续写入缓冲区。
- 使用操纵符如endl来显示地刷新缓冲区。
- 通过操纵符unitbuf来设置流的内部状态。见P282。
- 一个输出流可能被关联到另一个流。

> 如果程序崩溃，输出缓冲区不会被刷新，他所输出的数据很可能停留在输出缓冲区中等待打印。
>
> 所以随手手动显示刷新缓冲区对于调试一个程序很重要，因为你可能会以为那些已经执行但是只是写入缓冲区的代码没有执行而浪费大量时间。

**关联输入和输出流**

使用流的tie()函数。

#### 8.2 文件输入输出

一个文件流只能关联到一个文件，如果想改变想读写的文件，要先close()。

一个局部文件流，当离开该文件流的作用域时，与之关联的文件会自动关闭。

**文件模式**

C++的文件模式不是通过传入'r','rb'之类的字符串来设置的，而是通过fstream、ifstream、ofstream中的成员in、out、app、ate、trunc、binary来设置的，具体功能请见书P286。



#### 8.3 string流

string流是一中比较新颖的流（对于学C的同学来说）。

string流包含一些特有的操作。

string流对象都有str()方法，用来返回对象保存的string拷贝或者将一个字符串拷贝到该对象中。

- 对于istringstream对象，我们要用一个string对象来初始化它，然后可以把该istringstream对象当做cin来使用了，就是从保存string中一个一个输入。
- 对于ostringstream对象，可以不指定初始化的string对象，因为我们要将string写入到其中去，可以直接当做cout来使用，只不过写入的内容不会显示在屏幕上而已，而是会“显示”在ostringstream对象保存的string中，然后通过str()函数调用。



> string流可以用来配合getline，将getline得到的一行字符串分割成更小的“单词”来输入给string对象。





### 第九章 顺序容器

6种顺序容器类型：

- vector
- deque——双端队列
- list——双向列表
- forward_lsit——单向列表
- array——固定大小数组
- string

> 通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。

**选择容器的基本原则**见书P293



#### 9.2 容器库概览

容器操作——见书P295，表9.2

##### 9.2.1 迭代器

**迭代器范围**

> 迭代器范围的概念是标准库的基础

一个迭代器范围由一堆迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。

特点为**左开右闭**：[begin,end)



##### 9.2.4 容器定义和初始化

- array比较特殊，需要同时指定元素类型和大小。
- array支持拷贝和赋值操作，但是内置类型的数组却不能。

- 用另一个容器初始化一个容器，有两种方法：

  1. 直接用另一个容器作为构造函数的参数，这个方法要求两个容器的类型及其元素类型必须匹配。
  2. 将另一个容器的一对迭代器作为构造函数参数，以这对迭代器范围内的元素作为初始值，不要求容器类型和元素类型相同，但是元素类型必须能相互转换。（array不支持）

  

##### 9.2.5 赋值和swap——P302

array类型不支持用花括号列表赋值，只支持在初始化的时候赋值。

array同时也不支持assign操作（但是支持swap）。

其他所有容器都支持swap和assign操作。其中assign操作与用一个容器初始化另一个容器类似，可以说就是为了在初始化后再次赋值设计的操作。

> - 除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常熟时间内完成。
> - swap提供容器的成员函数版和非成员函数版，非成员函数版的swap在泛型编程中式非常重要的，因此统一使用非成员函数版本的swap是一个好习惯。

##### 9.2.7 关系运算符

比较两个容器实际上是进行元素的逐对比较，如果容器的元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。



#### 9.3 顺序容器操作

##### 9.3.1 添加元素

有以下几种操作：

- push_back()，尾部创建一个元素
- emplace_back()，尾部创建一个由传入参数构造的元素，也就是先由元素的构造函数创建一个再加入到容器中
- push_front()，在头部创建一个元素
- emplace_front()，在头部......
- insert()，有三种形式：单个插入、单个重复插入、范围插入
- emplace()，在迭代器p指向的元素之前创建一个元素

> - forward_list有自己专有版本的insert和emplace，不支持push_back和emplace_back
> - vector和string不支持push_front和emplace_front
> - array不支持上面的所有操作

insert和emplace都是默认在给定的迭代器之前插入元素，后面所讲的forward_lsit的insert和emplace默认是在给定迭代器之后插入元素。

**insert的返回值是指向第一个新加入元素的迭代器。**



##### 9.3.2 访问元素

有四种访问形式：

- back()，返回尾元素的引用，若容器为空，则函数行为未定义
- front()，返回首元素的引用，若容器为空，则函数行为未定义
- c[n]，返回下标为n的元素的引用，越界则未定义
- c.at(n)，返回下标为n的元素引用，如果下标越界，则抛出out_of_range异常

其中后面两个随机访问的方式只支持支持随机访问的容器（string、vector、deque、array）。同时，使用at方法比直接使用下标运算符更安全。





**9.3.3 删除元素**

删除元素有以下几种方法：

- c.pop_back()
- c.pop_front()
- c.erase()
- c.clear()

> 其中，forward_list不支持pop_back；vector和string不支持pop_front
>
> forward_list由特殊版本的erase



**删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它（们）是存在的。**



erase()有两种形式，一种是接受一个迭代器，删除该迭代器所指的元素，一种是接受一对迭代器，删除这对迭代器所指定的范围内的迭代器，返回一个指向最后一个被删元素之后的迭代器。



**forward_list的特殊操作**

由于forward_list实现的是手写的单向链表的数据结构，没有简单的办法来获取一个元素的前驱，因此，在一个forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来完成的（例如其他的容器的insert都是插入到给定元素之前）。

forward_list还多了一个返回**首前迭代器**的函数成员before_begin()，这个迭代器指向第一个元素之前，但不能解引用。

forward_list中插入或删除元素的操作：

- lst.before_begin()
- lst.cbefore_begin()
- lst.insert_after()
- emplace_after(p,args)
- lst.erase_after()

具体函数重载方法详见书P313。



> 要注意的是，我们对容器的操作（插入、删除）可能会使迭代器失效。因此建议每次添加或删除元素之后重新定位迭代器，例如，不要使用保存的end()返回的迭代器来当做循环终止判断条件，而是应该每次调用end()来判断是否到达尾后。



#### 9.4 vector对象是如何增长的

vector和string的元素都是连续存储的。但同时容器的大小又是可变的。

因此，当vector目前所处的空间没有空间容纳新元素时，再向容器中push一个新元素，系统会分配给容器新的连续的内存空间（足够存储更多的元素），然后把已有元素移动到新空间中，再向新空间中push元素，从这就可以看出来，这个操作很耗时。

**管理容量的成员函数**

- c.shrink_to_fit()，请求将capacity减少为与size()相同的大小
- c.capacity()，不重新分配内存空间的话，c可以保存多少元素
- c.revserve()，分配至少能容纳n个元素的内存空间

只有当reserve()要求的容量超过当前容量时，vector才会重新分配内存空间，使capacity至少与要求的空间一样大。

如果要求的容量小于当前容量，则reserve()什么也不做，即reserve()永远不会减少容器占用的内存空间。类似的resize()只会改变容器中元素的数目，而不是容器的容量。

如果想改变容器容量，可以使用shrink_to_fit()退回不需要的内存空间。但这个函数只是一个请求，具体的实现也可以选择忽略此请求。

只有当加入新元素时超出了capacity的大小时，vector才会重新分配更大的内存空间，Linux系统下一般是按当前容量翻倍。



#### 9.5 额外的string操作——P320

**构造string的其他方法**

具体见书P321。

**substr操作**

返回一个string的一部分或全部的拷贝，比较实用。

**改变string的其他方法**

除了之前讲过的insert、erase、assign之外。string还有append和replace操作。顾名思义，分别是向string追加内容和替换内容的，

由于重载函数较多，具体使用方法请自行查阅书籍或其他资料。

**string搜索操作**

有以下几种搜索操作：

- s.find(args)，查找s中args第一次出现的位置
- s.rfind(args)，查找s中args最后一次出现的位置
- s.find_first_of(args)，在s中查找args中任何一个字符第一次出现的位置
- s.find_last_of(args)，在s中查找args中任何一个字符最后一次出现的位置
- s.find_first_not_of(args)，在s中查找第一个不在args中的字符
- s.find_last_not_of(args)，在s中查找最后一个不在args中的字符

其中args允许的形式见书P326。

**compare函数——P327**

类似C语言的strcmp

**数值转换——P327**

字符串和数值类型的转换有以下几种函数：

数值转string:

- to_string(args)

string转数值：

- stoi()
- stol()
- stoul()
- stoll()
- stoull()
- stof()
- stod()
- stold()



#### 9.6 容器适配器——P329

本质上，一个容器适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。

标准库定义了三个顺序容器适配器：stack、queue、priority_queue。

一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。



**定义一个适配器**

定义容器适配器类似于定义容器，例如：定义一个stack：`stack<int> stk;`

适配器还能在定义时接受一个其他顺序容器（除array和forward_list外）



默认情况下，stack和queue是基于deque实现的，priority_queue是在vector熵实现的。

对于一个给定的适配器，可以使用哪些容器是有限制的。因为有些容器不能满足适配器的某些操作要求。

**栈适配器**

栈所支持的操作：

- s.pop()，删除栈顶元素，但不返回该元素值
- s.push(item)，创建一个新元素压入栈顶，该元素通过拷贝或移动item而来
- s.emplace(args)，由args构造一个新元素压入栈顶
- s.top()，返回栈顶元素，但不弹出栈



**队列适配器**

支持的操作：

- q.pop()，返回首元素或优先级最高的元素
- q.front()，返回首元素，只适用于queue
- q.back()，返回尾元素，只适用于queue

- q.top()，返回最高优先级的元素，但不删除该元素，只适用于priority_queue
- q.push(item)，在queue末尾或priority_queue中恰当的位置创建一个元素
- q.emplace(args)，由args构造一个元素，放在queue末尾或priority_queue的恰当位置

> priority_queue默认使用元素类型的<运算符来确定相对优先级。





### 第十章 泛型算法



> 泛型算法操作的都是容器的迭代器，它们并不会执行容器本身的操作，例如：vector的push_bach等。

泛型算法大致分为**只读**算法、**写入**算法和“**重排容器元素**”算法，他们的意义看名字就很清楚了。

常用的只读算法有：

- find()
- find_if()
- count()
- accumulate()
- equal()

常用的写入算法有：

- fill()
- fill_n()
- copy()
- replace()
- replace_copy()

常见的重排元素算法有：

- sort()
- stable_sort()
- unique()
- unique_copy()

> 大部分泛型算法定义在头文件algorithm中，还有一部分定义在numeric里。

有一点值得注意的是：

- 泛型算法可能改变容器内元素的值，但永远不会直接添加或删除元素，即永远不会直接改变容器的大小。

假如我们要使在执行算法的过程中，添加新的元素的话，可以借助**插入迭代器**来实现。插入迭代器是一种特殊的迭代器，定义在iterator头文件中，直接向插入迭代器赋值，它会帮助我们完成插入新元素的操作。

插入迭代器三种：

- back_inserter
- front_inserter
- inserter

前两种顾名思义，容易理解，第三种比较灵活，它要接受一个指向容器元素的迭代器，来向这个迭代器所知的元素前插入新元素。



#### 10.3 定制操作

> 我们可以向算法传递任何**可调用对象**。对于一个对象或者一个表达式，如果可以对其使用调用运算符()，则称它为可调用的。函数和lambda表达式都是可调用对象。

我们可以给一些泛型算法传递一些参数来替换掉默认的操作，达到我们自己的目的。例如：sort()算法默认是按照元素的<运算符来排列元素的，我们也可以向它传递第三个参数来改变它的排列方式，这个参数叫做“**谓词(predicate)**”。

谓词分为一元和二元，分别代表接受一个参数和两个参数。**接受谓词的算法输入序列中的元素调用谓词。因此元素类型必须能转换成谓词的参数类型。**

##### lambda表达式

谓词可以是自己定义的函数，但是这些函数只能接受一个或两个参数，如果想接受更多的参数，就要使用**lambda表达式**了。

lambda表达式与JAVA中的匿名函数类似，可以看做一个未命名的内联函数，其定义形式是：`[capture lsit](parameter list) -> return type{function body}`。我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。其中捕获列表的作用是“捕获”其所在函数内的局部变量，使之能在lambda函数体内使用，其捕获方式有**值捕获**和**引用捕获**之分，值捕获不捕获的是变量的拷贝。

我们也可以给这个“匿名函数”起名，即将lambda表达式给一个变量赋值（一般是声明为auto类型），然后就可以通过这个标识符来调用lambda表达式了。一个例子见书P346。

对于一个被lambda值捕获的变量，在lambda表达式中不允许修改它的值，若想修改，则需在函数体{}前加上mutable关键字。而引用捕获的变量可以被修改。

- lambda表达式在创建的时候就会被拷贝被值捕获的变量，在其创建之后的操作不会影响之后调用lambda时的值。

##### 参数绑定——P354

除了lambda表达式，我们还能使用参数绑定的特性来向自定义函数传递参数以满足谓词的限制。

参数绑定是通过bind()函数来实现的，它定义在functional头文件中，它所用到的占位符是定义在std中的placeholders命名空间中。



#### 10.4 再探迭代器

之前已经说过了插入迭代器，在iterator头文件中还定义了：

- 流迭代器(stream iterator)
- 反向迭代器(reverse iterator)
- 移动迭代器(move iterator)

##### 流迭代器

分为istream_iterator和ostream_iterator。分别用于读取流和写入流。

既然是迭代器，那么就可以用于泛型算法，因此，设计流迭代器的目的就是为了让泛型算法从流对象读取数据或写入数据。

我们可以还利用一对流迭代器范围构造容器！其他的迭代器使用方法（应该）都能用于流迭代器。

##### 反向迭代器

反向迭代器可通过容器的rbegin()、rend()、crbegin()、crend()等函数来获得。rbegin()获取的反向迭代器指向容器的最后一个元素，rend()指向首元素的前一个元素。

值得一提的是，当我们把使用普通正向迭代器的地方都换成反向迭代器时，结果的顺序一般都会相反，因为反向迭代器的++和--运算符使迭代器的移动方向与正向迭代器刚好相反。



#### 10.5 泛型算法结构

算法所要求的迭代器操作可分为5个**迭代器类别**：

- 输入迭代器——只读，将迭代器指向的的内容输入到算法中
- 输出迭代器——只写，将代码中的结果写入到迭代器指向的元素中。
- 前向迭代器——可读写，只能递增
- 双向迭代器——可读写，可增可减
- 随机访问迭代器——可读写，可随机访问

泛型算法的形参和命名都有其规律，具体见书P367。



#### 10.6 特定容器算法

list和forward_lsit比较特殊，因此他们将一些通用版本的算法定义成了成员函数：

- merge()
- remove()
- remve_if()
- reverse()
- sort()
- unique()

还定义了一个他们特有的算法：

- splice()

> 对list和forward_list使用他们自己的成员函数版本的算法比使用通用版的算法效率更高，因此要优先使用。





### 第十一章 关联容器



与顺序容器相对的，是关联容器。C++提供了八种关联容器：

按关键字顺序保存元素：

- map
- set
- multimap
- multiset

无序集合：

- unordered_map
- unordered_set
- unordered_multimap
- unordered_multiset

#### map

map类型是以键值对的方式存储的，它的元素类型是**piar**，piar有两个成员：first和second，其中first保存关键字，second保存关键字对应的值。

#### set

set只是关键字的集合，没有对应的值。



- map和set的关键字都是const的，不能修改，只有map的值可以修改。
- map和set默认都是不能保存重复关键字的元素，只能有一个。如果想保存多个重复关键字的元素，请用muitl版本。
- map和set将元素排序的依据是关键字的**<运算符**，所以关键字的类型要支持<运算符。也可以自己定义的操作来代替<运算符，这需要我们定义“严格弱序”（可以看做小于等于，具体定义请见P378），自定义类型和自定义比较方式的定义形式见书P379。

#### 11.3 关联容器的操作——P381

关联容器操作有一部分与顺序容器一样，例如：获取/使用迭代器、插入元素（insert、emplace）、删除元素。

值得一提的是map的下标操作（只有非multi版支持下标操作），如果一个关键字还不在这个map中，那么下标操作就会自动插入这个关键字的元素，值为值初始化（与值的类型有关）后的值。PS：用at方法不能这样。。。

- 如果向非multi版的容器insert已经存在的关键字，那么insert什么也不做，该关键字的值仍维持不变。

**访问元素**

访问map和set中的元素可以用以下方法：

- find()
- count()
- lower_bound()
- upper_bound()
- equal_range()

其中，lower_bound(k)返回的是一个迭代器，指向第一个关键字**不小于k**的元素，upper_bound(k)返回的是第一个关键字大于k的元素，equal_range(k)，返回的是一个迭代器pair，表示关键字k的范围，若k不存在，pair的两个成员均等于c.end()。

这三个成员函数的主要作用是访问multimap和multiset的元素，因为multi版本不能直接访问某一个元素。因为有序的multi版本容器中，关键字相同的元素会相邻存储。获取了所要查找的关键字的存储范围之后就好“下手了”。



#### **11.4 无序容器**

也就是unordered版本的map和set。

无序容器不用维护元素的顺序，效率比有序版本要高。采用**哈希函数**和关键字类型的==运算符来组织元素（我们也能自己定义）。

无需容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。

无序容器管理操作见书P395。





### 第十二章 动态内存与智能指针

每个程序包括静态内存、栈内存和自由空间（或者说是堆）。

- 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。
- 栈内存用来保存定义在函数内的非static对象。
- 堆是用来存储动态分配的对象——即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制。

动态内存管理是通过一对运算符来完成的：

- new，在动态内存中创建对象并返回它的指针。
- delete，接受一个动态对象的指针，销毁该对象并释放与之关联的内存。

所以我们使用动态对象一般都是通过指针，但是管理普通指针需要程序员非常细心，要清楚地知道这个指针什么时候该释放了，什么时候还有用不能释放。因为如果在不该释放的时候释放了，那么就会造成很严重的后果，程序崩溃什么的，如果该释放却没释放，就会造成内存泄露（浪费内存资源）。浴室C++的标准库提供了两种智能指针，来“自动管理”动态内存：

- shared_ptr——允许多个该指针指向同一个对象
- unique_ptr——同一时间只允许一个该指针指向对象

还有一个比较特殊的伴随类：weak_ptr，它是一种弱作用，指向shared_ptr所管理的对象。

这些智能指针都定义在memory头文件中。

#### 12.1 动态内存与智能指针

**shared_ptr**

> shared_ptr的操作见书P401

shared_ptr的特点就是会自动的在最后一个指向一个动态对象的shared_ptr被销毁时，同时销毁该动态对象，释放相关内存。

shared_ptr中包含一个计数器，当一个shared_ptr被拷贝时，计数器就会加1，当指向同一个对象的一个shared_ptr被赋予了新值或者被销毁时，计数器就会减1，当计数器变成0时，shared_ptr就会自动释放自己管理的对象。



**unique_ptr**

> uniqu_ptr的操作见书P418

同一时刻只能有一个unique_ptr指向一个动态对象。当unique_ptr对象被销毁时，它所指向的对象也被销毁。

因此，unique_ptr不支持任何形式的拷贝（赋值或者拷贝构造）。

但是这也有一个特例，这就是当一个unique_ptr是一个函数的返回值的时候，这是合法的。也可以说：我们可以拷贝或者赋值一个将要被毁灭的unique_ptr。



**weak_ptr**

> weak_ptr的操作见P420

weak_ptr是一个不控制所指对象生存周期的智能指针，它指向由一个shared_ptr管理的对象。

将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。所以当最后一个shared_ptr被销毁的时候，他们所指向的对象还是会被释放。所以weak_ptr指向的对象可能不存在，所以我们在访问它所指向的对象之前要进行检查操作——wp.lock()。



一般来说我们通过new所构造的对象给shared_ptr和unique_ptr赋值，但是shared_ptr有一种更安全的方法来获得一个动态对象的shared_ptr，那就是make_shared<T>()，可以给这个函数传递T的构造函数的参数来初始化这个动态对象的值。



**不要混合使用普通指针和智能指针**

因为当普通指针和智能指针指向同一个动态对象的时候，如果最后一个指向这个对象的智能指针被销毁了，那么这个独享也会被销毁，但是普通指针还是指向那块地址，如果在后面用到了普通指针就会造成segmentation fault。



#### 12.2 动态数组

分配动态数组的操作就是在类型后加上一个中括号指明数量：`int *pia = new int[get_size()]`。get_size()当然能换成具体的大小。

释放动态数组就比较特别一点：`delete [] pia`，中括号是在指针名前面的。



##### allocator类

new有一些灵活性的局限，其中一方面表现在它内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。

当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。

allocator类也定义在memory头文件中。

正如上面所说，allocator将分配内存和构造对象分离了，因此要构造动态对象的步骤就多了一步：

1. 使用allocate()成员方法分配所需的内存大小，返回指向这块内存的第一个未构造对象的指针。
2. 使用construct()成员方法构造动态对象。

当我们使用完对象后，销毁和释放对象的步骤如下：

1. 使用destroy()成员函数来执行对象的析构函数。
2. 使用deallocate()成员函数来释放内存。



**拷贝和填充未初始化内存的算法**

- uninitialized_copy(b,e,b2)
- uninitialized_copy_n(b,n,b2)
- uninitialized_fill(b,e,t)
- uninitialized_fill_n(b,n,t)

具体见书P429



## 第三部分 类设计者的工具

### 第十三章 拷贝控制

当一个类被定义的时候，我们会显式地或由编译器隐式地指定此类型在拷贝对象、移动、赋值和销毁的时候做什么。因为这些是每一个类的基本操作。这些操作统称为“**拷贝控制操作**”。

具体的通过定义五中特殊的成员函数来实现这些操作：

- 拷贝构造函数
- 拷贝赋值函数
- 移动构造函数
- 移动赋值函数
- 析构函数

> 在定义任何C++类时，拷贝控制操作都是必要部分。初学C++必须显式定义这些操作，因为如果不显式定义，编译器也会为我们定义，但编译器定义的版本的行为可能并非我们所想，甚至导致程序错误。



**注：下面内容为作者总结的一些比较重要的或容易犯错的知识点，并非全部知识点，未提及的知识点还请君好好看书。**



##### 13.1.1拷贝构造函数

拷贝构造函数就是接受一个const该类型参数的构造函数，从传入的参数来构造一个新的对象，这个过程称为拷贝初始化。

拷贝初始化是在**定义对象的同时**用`=`来赋给对象初始值，直接初始化是通过`()`来初始化值的。（P441）

拷贝初始化和直接初始化的区别是：

- 拷贝初始化是先分配空间并给数据成员赋予默认值（或者未定义的值），然后再用传入的值赋给这个新的对象的数据成员。
- 直接初始化是在分配空间的时候就同时赋给这个空间新的值。

因此，直接初始化一般比拷贝初始化速度要快些。

**拷贝构造函数的参数**

由于非引用类型的参数要进行拷贝初始化，如果拷贝构造函数的参数是非引用的话，那么调用拷贝构造函数这个过程就会无限递归。

**合成的拷贝构造函数**

编译器为我们定义的合成构造函数会依次将给定对象中的每个非static成员拷贝给正在创建的对象中。（P441）



##### 13.1.2 拷贝赋值运算符

赋值运算符的返回值是对象的引用。

**合成拷贝运算符**

合成拷贝运算符也会将右侧运算对象的每个非static成员赋予左侧对象的对应成员。

##### 13.1.3 析构函数

析构函数是在对象被销毁时被自动调用的函数，析构函数会首先执行函数体，然后按逆序销毁成员。函数体中的操作用于释放一些不能被自动释放的资源，如：动态内存、指针成员指向的对象等。析构函数体本身并不直接销毁成员，而是做一些销毁成员步骤之外的事。（P445）

> 内置类型没有析构函数。
>
> 隐式销毁一个内置指针（这里的内置是普通指针的意思）类型的成员不会delete它所指的对象。
>
> 当指向一个对象的引用或者指针离开作用域时，析构函数不会执行，所以要手动delete掉这个指针。而智能指针会自动delete。



##### 13.1.4 三/五法则jiaohuancaozuo



**需要析构函数的类也需要拷贝和赋值操作**

这里说的需要是指显式定义。

由于需要析构函数的类都是包含指针或者分配了动态内存的类，因此拷贝、赋值的时候需要分配新的内存，否zuzhi则合成的拷贝构造、赋值函数会将指针指向的地址赋给新的对象。导致两个对象的成员指向同一块地址。（如果你就是要这样的效果。。。当我没说）

**需要拷贝操作的类也需要赋值操作，反之亦然**



因此，这些拷贝控制操作是一个整体，通常没有只需要定义其中一两个的情况。



##### 13.1.5 使用=default

=default是显式的要求编译器生成合成的版本。



##### 13.1.6 阻止拷贝

有一些类不允许拷贝的操作，比如iostream类。因为对于这些类来说，拷贝操作不合理或没意义。

要阻止拷贝只需要定义成**删除的函数**就行——在参数列表后加上=delete。

还有一种方法就是将这些操作显式地定义为private的，但是这样在类内的其它函数也能执行拷贝操作。



析构函数不能是删除的成员。如果强硬定义成了删除的，那么编译器不允许定义该类型的变量。（P450）



#### 13.2 拷贝控制和资源管理

我们定义的一个包含指针成员的类，我们可以使它的行为像值或者像指针。这可以通过拷贝构造函数和拷贝运算符来控制。

如果要使之像值，那么就在拷贝的时候新建一个对象，拷贝值，如果想让之像指针，只需拷贝指针的值即可。



#### 13.3 交换操作

对于某些类，交换操作可能只需要交换成员指针的值就行了，这样可以大大提高执行效率。于是我们需要自己定义swap函数。

同时，对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的，如果一个类定义了自己的swap，那么这些算法将使用类自己定义的版本，否则就会使用标准库定义的swap。

如果要手动使用自己定义的swap，那就直接写swap()，而不是std::swap()。后者是调用标准库版本的。

**在赋值运算符中使用swap**

在赋值运算符中使用swap函数通常被称为**拷贝并交换（copy and swap）**技术。做法就是传入的变量是非引用的，相当于先用拷贝运算符新建了一个临时对象，然后在用swap把这个临时对象和this指向的对象的内容交换，就能直接返回*this了。（P459）

这种技术的优点就是处理了**自赋值**情况且天然就是异常安全的。





#### 13.4 拷贝控制示例

> 拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作。即先拷贝传入的值，然后销毁左侧运算对象的资源，再将拷贝保存的值赋给左侧运算对象。



#### 13.6 对象移动

对象移动这个概念比较新颖，其实并不神秘，也不神奇。下面我们通过几个问题来了解对象移动。（P470）

1. 什么是对象移动？

对象移动就是移交对象对某一块内存的“管辖权”。例如：可以将一个对象的成员指针的值赋给另一个对象的成员指针，然后指向nullptr。如果把对象移动的过程看做一个黑盒子，那么最终的结果就是把对象O1的成员数据“移动到了”对象O2中，而不是“拷贝”。

但是，虽然叫对象移动，却并不意味着这个过程中就没有拷贝的发生，上面也说了会拷贝指针的值。只是对于对象的内容来说，没有拷贝。

2. 为什么要对象移动？

从上可知，对象移动仅仅需要拷贝一两个指针的值，而不需要将指针指向的值整个拷贝一份给另一个对象，因此，对象移动效率比拷贝高。

3. 怎么实现对象移动？

要实现对象移动的关键要素有两个：

- 右值引用
- 移动构造函数或移动赋值运算符

右值引用是传入移动构造函数或移动赋值运算符的参数。这两个函数都应该是我们自定义的（虽然好像也有合成 的），也就是说，对象移动的操作是我们自定的，只要符合对象移动的定义即可，没有那么复杂和神秘。

那为啥要搞个右值引用出来呢？

我个人认为是为了与普通的拷贝构造函数/拷贝赋值运算符区分开来，毕竟这两个函数的参数一般都是引用。（不过这只是我个人的瞎猜。。。不要太当真。其实我也不清楚真相）



**什么是右值引用呢？**

我们之前使用的引用都是左值引用，我们引用的是这个这个对象的”身份“。就好比我们使用一个“人”的左值引用，那么我们用的就是他作为人的这个身份，如果使用的是这个人的右值引用，那么引用的就是他的具体属性（值），例如：姓名，身高等信息。

左值引用声明只需要一个&，右值引用需要两个&。（P471）

右值引用有两个条件：

- 所引用的对象将要被销毁
- 该对象没有其他用户

既然都把资源移到了另一个对象嘛，那么源对象也没什么用了，自然要被销毁了。

**如果得到右值引用呢？**

通过std::move()这个标准库函数可以得到右值引用。因为右值引用只能绑定到一个右值上，不能绑定到其他变量上，且一般的变量/对象都是左值。但是有时候我们就是要求要移动某一个变量/对象的数据，那么这时候就要通过std::move()来返回一个右值引用的对象了，说白了就是将一个变量强制转换成右值引用。



介绍了对象移动的一些关键问题，其他的有关对象移动实现的问题就请你们自己好好看书去吧 (\*\^\__\^\*) 嘻嘻……



对了，还有一个关键概念就是移动迭代器，通过标准库的make_move_iterator()方法获得。它的解引用符生成一个右值引用，产地给一些拷贝或者赋值算法的话，就能将这些迭代器指向的对象移动到新的对象中，提高效率。



> 其他的普通成员函数也能提供接受右值引用的版本，借助移动操作，提高效率。（P481）



## 附录

### zuzhi辨析const和constexpr

- constexpr包括了const的含义
- constexpr修饰的**表达式\函数本身**只是表明了在编译期间可知，但不一定非要已知。。。（即使不已知，那也没办法的意思）
- const则是只是限定了不能修改



### 编程遇到的问题

1. 在编写第12章12.3节的程序时

- 类中的数据成员如果不初始化（分配内存）的话是没有产生对象的，如果这时候调用了数据成员，就会报segmentation fault(core dump)。所以如果不在类内指定数据成员的默认值/列表初始化的话就要用new分配一个动态内存了。

> 一般来说出现segmentation fault错误的时候都是内存出错了，访问了不存在的变量、数组越界、访问了系统保护的内存地址、栈溢出等都会引发这个错误。

