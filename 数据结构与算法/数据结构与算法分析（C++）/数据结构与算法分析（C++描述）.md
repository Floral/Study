# 数据结构与算法分析（C++描述）

## 第一章 程序设计：综述

### 1.4 C++类

##### 常成员函数

在函数参数列表后加上const表示该函数为**访问函数（Accessor）**，即不会改变类内部的状态的函数。相对应的是**修改函数（mutator）**。



#### 1.4.3 接口与实现分离

C++中，一般把类的接口和实现分开，接口放在以``.h`为后缀名的文件中。需要接口声明的实现文件需要`#include`这个接口文件。



##### 对象的声明

C++中对象的声明可以用圆括号（），但是如果要用圆括号声明一个使用零参数构造函数的对象，例如：`MyObject a();`，这里我们想使用`MyObject`的零参数构造函数来声明这个函数，但是编译器实际上会识别为一个返回`MyObject`对象的名为a的参数列表为空的函数，因此为了解决这种写法带来的混乱现象，C++可以使用（同时也建议）花括号来当作对象的声明：`MyObject a{};`。



### 1.5 C++细节

#### 关于左右值的再度讨论

**左值（lvalue）**是一个标识非临时性对象的表达式，一般来说，有“变量名”的就是左值。**右值（rvalue）**是一个标识临时性对象的表达式，或者是一个不与任何对象相联系的值（如字面值常量）。

这里有一个有意思的情况：在一个函数里，有一个声明的变量（局部变量），在这个函数里，它是一个左值，但是当它被return后，出了这个函数，它就是一个右值（准确来说是这个函数的表达式）。具体代码如下：

```c++
MyObject func(){
	MyObject a;	//在这个函数内，a是一个左值
    ...
    return a;
}
int main(){
    MyObject x;
    x=func();	//func()这个表达式是一个右值，因为这是一个无名的临时变量，如果没有把这个值赋给x，那么就会被回收
    return 0;
}
```

但是如果一个函数返回的是在调用这个函数之前就存在的对象时，那么这个函数调用表达式就是一个右值。例如：

```c++
MyType func(const vector<MyType> &arr){
    return arr[randomInt(0,arr.size()-1)];
}
```

这里返回的`arr[randomInt(0,arr.size()-1)]`是一个左值，因为这个函数返回的时传入函数的引用中的一个元素。并不是临时对象。



#### 左值引用的（常见）用途

1. 给结构复杂的变量名起别名
2. 用于范围for循环
3. 避免复制，节省空间



#### 右值

函数返回的右值可以通过**移动（move）**来赋值给左值，从而避免了复制，提高了效率。

如果赋值运算符（或构造函数）的右边是一个右值，那么当左边的对象支持移动对象操作时，C++会自动地移动对象，避免复制。

>右值和右值引用不是一个东西，右值引用本身是一个左值，因为它也是有变量名的，有存储地址。所以一个函数的接收参数里面是一个右值引用，如果要在函数里面调用需要传递右值的函数时，需要再次使用`std::move()`将右值引用变成右值传递给函数。
>
>参考地址：https://zhuanlan.zhihu.com/p/95628575

#### 浅拷贝（shallow copy）、深拷贝（deep copy）

浅拷贝和深拷贝是对于包含指针类型的类来说的。

如果使用默认的拷贝构造函数或者拷贝赋值运算符，那么只会拷贝指针的值，即指针指向的地址的值（这种情况被称为**浅拷贝**）。那么两个对象包含的指针所指向的是同一个内部数据对象，如果其中一个对象销毁的时候删除了那个内部数据对象，那么另一个类访问它的指针时就会出错。

**深拷贝**就是完全复制所拷贝的对象，在第二个对象中创建一个新的数据对象，其值与第一个对象的内部指针指向的对象值相同，并使其内部指针指向该数据对象。

### 1.6 模板

#### 模板类的接口与实现分离编译

模板类接口与实现的分离编译很容易出问题，在这里建议建议放在同一个.h文件中编译。C++的STL也是采取这样的策略。

## 第三章 表、栈和队列

我们通常说的**表ADT（List Abstract Data Type）**在C++中有两种实现，一种是vector，另一种是list。

vector提供的是表ADT得到一中可增长的数组实现，list是表ADT的双向链表实现。



### list的实现

这里面有用到继承，因此在这里我对继承的函数重载与virtual的关系研究了一下，具体请见C++Primer_5th.md附录。





