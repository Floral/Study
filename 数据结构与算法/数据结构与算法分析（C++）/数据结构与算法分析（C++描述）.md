# 数据结构与算法分析（C++描述）

## 第一章 程序设计：综述

### 1.4 C++类

##### 常成员函数

在函数参数列表后加上const表示该函数为**访问函数（Accessor）**，即不会改变类内部的状态的函数。相对应的是**修改函数（mutator）**。



#### 1.4.3 接口与实现分离

C++中，一般把类的接口和实现分开，接口放在以``.h`为后缀名的文件中。需要接口声明的实现文件需要`#include`这个接口文件。

不过这样做的话，如果涉及到模板类，那么在编译的时候可能会遇到问题。

##### 对象的声明

C++中对象的声明可以用圆括号（），但是如果要用圆括号声明一个使用零参数构造函数的对象，例如：`MyObject a();`，这里我们想使用`MyObject`的零参数构造函数来声明这个函数，但是编译器实际上会识别为一个返回`MyObject`对象的名为a的参数列表为空的函数，因此为了解决这种写法带来的混乱现象，C++可以使用（同时也建议）花括号来当作对象的声明：`MyObject a{};`。



### 1.5 C++细节

#### 关于左右值的再度讨论

**左值（lvalue）**是一个标识非临时性对象的表达式，一般来说，有“变量名”的就是左值。**右值（rvalue）**是一个标识临时性对象的表达式，或者是一个不与任何对象相联系的值（如字面值常量）。

这里有一个有意思的情况：在一个函数里，有一个声明的变量（局部变量），在这个函数里，它是一个左值，但是当它被return后，出了这个函数，它就是一个右值（准确来说是这个函数的表达式）。具体代码如下：

```c++
MyObject func(){
	MyObject a;	//在这个函数内，a是一个左值
    ...
    return a;
}
int main(){
    MyObject x;
    x=func();	//func()这个表达式是一个右值，因为这是一个无名的临时变量，如果没有把这个值赋给x，那么就会被回收
    return 0;
}
```

但是如果一个函数返回的是在调用这个函数之前就存在的对象时，那么这个函数调用表达式就是一个右值。例如：

```c++
MyType func(const vector<MyType> &arr){
    return arr[randomInt(0,arr.size()-1)];
}
```

这里返回的`arr[randomInt(0,arr.size()-1)]`是一个左值，因为这个函数返回的时传入函数的引用中的一个元素。并不是临时对象。



#### 左值引用的（常见）用途

1. 给结构复杂的变量名起别名
2. 用于范围for循环
3. 避免复制，节省空间



#### 右值

函数返回的右值可以通过**移动（move）**来赋值给左值，从而避免了复制，提高了效率。

如果赋值运算符（或构造函数）的右边是一个右值，那么当左边的对象支持移动对象操作时，C++会自动地移动对象，避免复制。

>右值和右值引用不是一个东西，右值引用本身是一个左值，因为它也是有变量名的，有存储地址。所以一个函数的接收参数里面是一个右值引用，如果要在函数里面调用需要传递右值的函数时，需要再次使用`std::move()`将右值引用变成右值传递给函数。
>
>参考地址：https://zhuanlan.zhihu.com/p/95628575

#### 浅拷贝（shallow copy）、深拷贝（deep copy）

浅拷贝和深拷贝是对于包含指针类型的类来说的。

如果使用默认的拷贝构造函数或者拷贝赋值运算符，那么只会拷贝指针的值，即指针指向的地址的值（这种情况被称为**浅拷贝**）。那么两个对象包含的指针所指向的是同一个内部数据对象，如果其中一个对象销毁的时候删除了那个内部数据对象，那么另一个类访问它的指针时就会出错。

**深拷贝**就是完全复制所拷贝的对象，在第二个对象中创建一个新的数据对象，其值与第一个对象的内部指针指向的对象值相同，并使其内部指针指向该数据对象。

### 1.6 模板

#### 模板类的接口与实现分离编译

模板类接口与实现的分离编译很容易出问题，在这里建议建议放在同一个.h文件中编译。C++的STL也是采取这样的策略。



#### 函数对象





## 第三章 表、栈和队列

我们通常说的**表ADT（List Abstract Data Type）**在C++中有两种实现，一种是vector，另一种是list。

**vector**提供的是表ADT得到一中可增长的**数组实现**，**list**是表ADT的**双向链表实现**。



### list的实现

这里面有用到继承，因此在这里我对继承的函数重载与virtual的关系研究了一下，具体请见C++Primer_5th.md附录。

### 栈

栈的实现也包括数组和链表两种。具体与表和队列的实现思路大致相同，并且要简化一些。

栈的应用有很多：

- 检查符号
- 利用后缀表达式（逆波兰记法）来计算算式
- 把中缀表达式转换成后缀表达式
- 函数调用时用栈存储调用前的信息（寄存器的值，返回地址等）



### 队列

队列也是一种表，其实现也有数组和链表两种形式，链表实现比较简单，数组的实现会遇到一些问题，就是当队尾达到数组尾部后不能再增加了，但是数组前面也许还有已经出队列的空闲位置时怎么办。解决方法就是让队尾回到数组的开头，这种情况叫**循环队列**





## 第四章 树



### 树的概念

树的定义自行百度。。。

说一下树的属性：

- 路径：节点n~1~到n~k~的路径定义为节点n~1~ ， n~2~ ，…，n~k~的一个序列，这个序列要满足对于任意$1 \leq i \leq k$ ，n~i~都是n~i+1~的父节点。该路径的长（length）是该路径上 的边的条数，即k-1。

- 深度：对于任意节点n~i~，n~i~的深度是从根到n~i~的唯一路径的长。因此，根的深度为0。
- 高度：n~i~的高度就是n~i~到一片树叶的最长路径的长。因此所有树叶的高就是0，一棵树的高等于它的根的高。



### 树的实现

树按照子节点的多少可以分为普通树和二叉树，普通树的任意一个节点可以有多个（三个或以上），二叉树的任意一个节点的子节点不能超过两个。

二叉树的实现比较容易，只需在每个节点中添加两个子节点的指针。普通树就比较难了，因为子节点数量不确定，采用数组存储子节点指针的话，可能会有重新分配大小的操作，这很耗时。于是我们采用链表的形式，于是每个节点只需包括指向下一个兄弟节点的指针和指向第一个子节点的指针。这样结构的结果就是拥有同一个父节点的兄弟节点位于一条链表上。

### 树的遍历

对于普通树来书说，树的遍历分为：先序遍历、后序遍历。正如其名，其中的“先”、“后”只的是一个子树的根节点是最先访问的还是最后访问的。

对于二叉树来说还可以有中序遍历，也就是在中间被访问的。

### 二叉树

二叉树的结构比较特别，用处也很多，例如下面要说的表达式树和二叉查找树。

#### 表达式树

表达式树的树叶是操作数，其他节点都是操作符（这里假设所有的操作符都是二元的）。

#### 二叉查找树

二叉查找树的定义是：对于一个二叉树中的任意一个节点X，其左子树的**所有节点**的值都小于X，其右子树的**所有节点**的值都大于X。

#### AVL树

自从出现了二叉查找树，查找的效率有了一定的提升，但是可能也会出现一些极端的情况，例如极端的链表情况（就是树的每个节点仅仅只有左子孩子，相当于退化成了一条链表）。这会造成查找某些节点所需的操作次数很多，效率降低。

为了改善这种情况，我们可以调整二叉查找树的形状，以提升平均的查找效率。很容易知道，要想查找操作越少，树的深度越浅就越好。对于一定节点数的树来说，让最大深度最小的方法就是尽量使各个节点的左右子树具有差不多的深度（不至于一段太深，一端太浅），这就是所谓的**平衡**。也可以把一个（子）树的根节点想象成一个天平的支点，其左右子树的节点数量/深度不一的话，这个天平就不平衡了，其平均查找的效率也就不高了。

最理想的平衡二叉树就是每个节点的左右子树高度（深度）相同。不过这种树的要求太严格了，实际难以使用。于是我们适当放宽平衡的条件：任意一个节点的左右子树的高度相差不超过1。这就是AVL树了。

AVL树是如何保证平衡条件的呢？是通过在每次插入操作后执行响应的平衡操作来调整树的结构以保证满足平衡条件的。

对于AVL来说，插入一个新节点会导致不平衡的情况有四种（我们把需要调整的的节点称为A）：

-  对A的左儿子的左子树进行一次插入
- 对A的左儿子的右子树进行一次插入
- 对A的右儿子的左子树进行一次插入
- 对A的右儿子的右子树进行一次插入

其中，1、4和2、3分别可以看作镜像对称的情况。

处理的方法有：

- 单旋转
  - 左单旋转
  - 右单旋转
- 双旋转
  - 左-右双旋转
  - 右-左双旋转

单旋转是用于第1和第4种情况的，较为简单，双旋转是用于第2、3种情况的，稍微复杂。通过名字来看，双旋转其实就是进行了两次单旋转。



为了节约时间。。。具体的图和示例我就不画了。。。这里放一个别人的链接（写的挺详细的

>  https://zhuanlan.zhihu.com/p/56066942

~~小声bb：这怎么能叫懒呢？读书人的事，能叫懒吗？这叫借鉴前人优秀的经验！~~



#### 伸展树(Splay Tree)

对于一个二叉查找树来说，如果存在一个节点需要N次操作才能访问，那么如果M次连续这个结点的话（根据程序的访问局部性），就会非常耗时，即使是AVL树，也可能存在连续访问最深节点的情况。解决这个问题的方法是，每访问一次节点，就对这个节点进行一次AVL树中的旋转操作，以提高它的高度（降低它的深度）。

一个简单的想法就是使用AVL树中的单旋转，每访问一次，进行一次单旋转，但是这样会使其他某个节点变得很深。

于是我们使用展开（splaying）的操作，类似AVL中的双旋转。但是要分两种情况（假设访问的是X）：

- 之字形（zig-zag case），与AVL的双旋转没有差别
- 一字型（zig-zig case），把左边的树变到右边（或者右边到左边）

<img src=".\pic\chapter4_1.JPG" alt="chapter4_1" style="zoom:15%;" />



如果访问的节点X的父节点是根节点的话（没有祖父节点），那么就只用进行一次单旋转。



这里没有找到我觉得比较好的blog，就找到两个还不差的来凑一下数（无意冒犯）

> 1. https://blog.csdn.net/PacosonSWJTU/article/details/50525435?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task
>
> 2. https://blog.csdn.net/jtyj55454/article/details/84890936?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task
>
> 第一个也是从我看的这本书里面总结的



### B树

平衡二叉树已经可以很好的减少访问次数了（查找的复杂度为O(logN)），但是对于磁盘来说，这个访问次数还是很多，因为存放于磁盘上的数据一般是大量的（即N很大），而外设的速度对于CPU来说很慢很慢，所以这很浪费时间。

提高存储系统的数据查找速度，其本质是降低树的高度，而降低树的高度，自然而然就想到让树的每一层容纳更多的节点，这样树就变得“矮胖”了，增加非叶子节点的分叉数量即可实现这一目的。于是有大佬就提出了B树，B树是一种多叉平衡树，是平衡二叉树的延申。

以下引述书中的定义：

> 阶为M的B树（B-tree）是一颗具有下列特性的M叉树：
>
> 1. 数据项存储在树叶上。
> 2. 非叶节点存储最多M-1个关键字以指示搜索的方向：关键字i代表子树i+1中的最小的数据项。
> 3. 树的根要么是一片树叶，要么其儿子数在2到M之间（即根不能只有一个儿子）。
> 4. 除根外，所有非叶节点的儿子数在[M/2]（取M/2的上限）和M之间。
> 5. 所有的树叶都在相同的深度上 ，并且每片树叶拥有的数据项其个数在[L/2]（取M/2的上限）和L之间，L的确定稍后描述。

<img src=".\pic\chapter4_2.JPG" alt="chapter4_2" style="zoom:20%;" />

以上是一个典型的5阶B树，最下面一层的是叶子节点，其中包含的是数据项。前面两层的节点中，数字代表的是该节点保存的关键字，数字之间的空隙相当于指针，指向其子树。第i个关键字保存的是第i+1个子树中数据的最小值（对于根节点来说这样的说法也是对的）。

现在就该讨论讨论B树的插入和删除问题了。

**插入：**由于每个叶子节点所能能存储的数据项存在最大的数量（L）限制，所以当要插入的值的理论位置放不下时（例如在上面这个B树中按序插入57、55），那么我们就可以把其父结点中指向该叶子节点的指针“**分裂**”成两个（其实只是新增一个叶子节点，并使该父节点指向新的叶子节点）。这是在其父节点的叶子指针并没有满时的操作，如果父节点已经不能新增子节点时（例如向上图中插入40时），首先还是会像之前一样新增一个子节点（现在理论上 有6个孩子了），由于没地方放了，之后就会向该叶子节点的祖父节点（在这里就是根节点）“申请”新增一个子节点，于是根节点就拥有了5个子节点。然后将原节点的后三个子节点放到根节点新增的子结点中，如下图：

<img src=".\pic\chapter4_3.JPG" alt="chapter4_3" style="zoom:18%;" />

**总结一下**，插入的原则就是：不够就“分裂”，父节点满了就向祖父节点申请分裂 ，祖父节点不够了继续向上一级申请分裂，当根节点也没有空间的话，就新增一个与当前根节点平级的节点，然后再新增一个根节点指向两个节点（还要注意分配新的根节点的两个子节点的儿子数）。这种做法，平均每经过L/2次不需要分裂的插入操作才会进行一次分裂操作。

**删除：**与插入相对，删除节点的原则就是**“合并”**，当一个叶子节点的数据项由于被删除而导致数目少于[L/2]个时，就会与附近的还有足够空间的节点合并，若因合并导致父节点的孩子树少于[M/2]时，那么父节点就会向它临近的兄弟节点**借一个**“孩子”来（或者与兄弟节点合并也是可能的），如果导致临近的兄弟节点也不满足最少孩子的要求时，那么再向其他兄弟节点借（或者合并）。一个例子如下图：

<img src=".\pic\chapter4_4.JPG" alt="chapter4_4" style="zoom:20%;" />



**整体总结一下：**保证B树在执行插入和删除操作之后仍然满足B树的定义的操作是**分裂**和**合并**，无论什么情况，总是可以通过这两个操作调整B树的结构来使之满足要求。



这里有两个讲得很不错的blog，漫画图解B-树和B+树（与本书所讲的B树稍微有点差别，算是课外知识吧）

> 1. https://www.sohu.com/a/154640931_478315
>
> 2. https://blog.csdn.net/qq_35571554/article/details/82759668?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

这里还有个还不错的：

> https://blog.csdn.net/wxx17353227396/article/details/92431808?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task



### 4.8 STL中的set和map

这里我只简述以下set和map的一些我觉得特殊的/要注意的地方。

#### 集合容器set

set的insert方法返回的是一个pair，具体类型为`pair<iterator, bool>`，这是由于set是一个不允许重复元的集合容器，返回的结果除了要反应插入成功还是失败，还返回了一个指向插入点的iterator，如果插入成功，那么iterator指向的就是刚刚插入成功的元素，如果因为要插入的的项已经存在而导致失败，那么返回的就是原来已经存在的元素的iterator，这样方便了我们对该项的后续操作（修改or删除），不需要再次查找。

#### 映射容器map

对一个map使用`[]`运算符的时候，如果map中存在该关键词，那么就会直接返回相应的`pair<KeyType, ValueType>`；如果不存在，那么就会向该map中新插入一个用默认值初始化Value的pair元素，如果该调用语句后面接了赋值号，那么 接着就会像这个新插入的元素赋值。借助这种机制，我们可以直接往map中添加新元素而不用使用 insert函数。但是这种机制有时候会非常尴尬，因为我们有时候只是想看看map中是否存在该关键字及其值，而不想在不存在的时候插入该关键字的元素。这时候就需要调用map的find函数来完成我们想要的操作了，借助书上的一个例子：

```C++
map<string, double> salaries;

salaries["Pat"] = 75000.00;
cout<< salaries["Pat"]	<< endl;	//输出结果为 75000.00
cout<< salaries["Jan"]	<< endl;	//输出结果为 0.0

map<string, double>::const_iterator itr;
itr = salaries.find("Chris");
if(itr == salaries.end())
    cout<<"Not an employee of this company!"<<end;
else
    cout<<itr->second<<endl;
```



#### 实现（P142）

> C++要求set和map以对数最坏情形时间支持基本的insert、erase和find操作，因此，基础的实现方法就是平衡二叉树。但是一般说来，我们并不使用AVL树，而经常使用一些自顶向下的红黑树，它们将在12.2节讨论。

在具体的实现方案中，本书还提到了一个名为“**线索树（threaded tree）**”的树，线索树应用于许多STL中。它的思想是利用原本二叉查找树中节点的nullptr指针，如果一个节点的左孩子指针为nullptr，那么就将这个指针指向该节点的中序前驱元（inorder predecessor），如果一个结点的右孩子指针为nullptr，那么就将这个指针指向该节点的中序后继元（inorder successor），这些附加的链就叫做线索（thread）。



#### 使用多个map的示例

在本书的这一小节，我最大的收获就是学到了、感受到了分而治之的“威力”。

对于一个非常大的集合来说，要处理该集合中的每一个元素（各个元素之间需要相互比较时，或者需要多层for循环的时候），最简单、直接的方法就是不做任何处理，直接干，不管三七二十一，见到要遍历处理的就直接嵌套多层for循环。而往往这样直白的方法效率是最低的。

我们可以思考一下是否能对原集合进行一定的分类处理，然后再分别对每类的集合遍历处理。本书的这一节就是一步一步地深化分类，分得越来越细致，从而逐渐提高效率的。

其实从数学角度也可以证明，假如原集合有100个元素，直接嵌套两层循环的话，那么需要循环100x99=9900次。如果将100个元素分成两类，每类50个元素，那么总共只需循环2x50x49=4900次，如果继续分类的话，总的次数会越来越少。这也让我联想到了学习数字信号处理时的*快速傅里叶算法*（这个算法的原理与我这里简述的差不多，感兴趣的可以去查查），也正是因为这个算法，才让傅里叶变换得以在计算机上能发挥实际作用。



## 第五章 散列

散列（hashing），~~顾名思义就是散开的列表（这是我自己造的说法2333）~~,“理想的散列表数据结构只不过是一个包含一些项（item）的具有固定大小的数组”。

散列的插入、删除、查找都依赖于其数据项中的某个部分，称为关键字。关键字可以是一个整数、字符串等等。三列中的数据现项可以只是一个关键字，也可以是还包含其他的信息的结构体/类。

如何决定数据项插入散列中的位置，是散列区别于其他数据结构的关键。散列是通过一个**散列函数**，将一个数据项的关键字映射为不同的存储位置来完成插入、删除、查找操作的，理想情况散列函数能将不同的关键字映射为唯一的一个位置，但是just理想情况，实际情况中难免会出现不同关键字映射到同一位置的**冲突（collision）**情况，我们只能尽量选择一个使映射更少频率发生冲突的散列函数，因此我们的散列数据结构还需要解决冲突的策略（具体方法后面会简要介绍）。

散列函数是一个……函数，只不过我们在这里输入的是关键字，返回的是在该散列表中存储的位置。一般来说，散列函数是非线性的，否则散列跟直接使用数组按序存储也就没什么区别了……因此散列中的数据没有顺序可言。散列函数的具体实现一般就是对关键字进行一定的数学运算，例如：（对整数关键字）取模、（对字符关键字）取ASCII码加和然后取模。~~这里肯定不是只有取模这一种方法……不要误会，只是因为取模是最常见的实现方法~~。

我们对散列函数有两个期望：1. 尽量少发生冲突，2. 尽量使数据分布均匀。当然，这两点除了与散列函数有关，还与散列表（数组）的大小有关。

**如何减少发生冲突、尽量使数据分布均匀？**

首先，散列函数一般有（对于整数/字符关键字来说）：

- 直接取模
- 加和后取模
- 计算多项式值后取模

（不要打我……其实想想也是，如果真的要想出一种一一映射，且映射均匀的数学函数并不容易，我觉得都可以让专业的数学家来做这件事了，而我们的目的只是“实用就行”，所以干脆直接取模）

对谁取模呢？当然是对散列表的大小取模。所以上面才说与散列表的大小有关，一般来说，散列表大小为素数最好，因为能减少取模后出现的重复结果，也能使分布均匀（我觉得）。



**如何解决冲突？**

总体分为两种方案：

- 使用链表（分离链接法）
- 不使用链表（探测法）



~~先写到这吧……~~







## 第六章 优先队列（堆）

### ADT模型

顾名思义，优先队列就是元素存在优先级的队列，操作系统调度进程就会用到优先队列，外设处理事务一般也会用到优先队列（eg：打印机）。

优先队列的基本模型就是一个队列，包括入队（enqueue）和出队（dequeue）操作，不过优先队列的出队顺序是根据优先级而定的，简单的实例中，优先级可以由元素关键字的大小来决定，eg：如果是整数的话，越小的优先级越高。

书中给的入队和出队操作分别对应为insert和deleteMin，从deleteMin就可以看出它的出队是有特定的顺序/优先级的。



### 简单实现

可以考虑的实现有：

- 链表
- 二叉查找树
- 平衡二叉树

这些方法都各有优缺点。例如，无序链表的入队可以达到O(1)的复杂度，但是出队可就是O(N)了，因为要遍历链表查找最小元素。排序的链表需要每次入队时进行一次排序操作O(N)，不过出队就为O(1)了。

二叉查找树的插入和删除虽然平均复杂度为O(logN)，但是其删除是有特点的，即要么一直删除最左下的节点，要么一直删除最右下的节点，会使二叉查找树变得非常不平衡。虽然可以使用平衡二叉树，但是有些小题大做，因为堆不需要它们的许多操作。



### 二叉堆

我们的实现方法是二叉堆（binary heap）,简称堆，具体就是一个[完全二叉树](https://www.jianshu.com/p/6a30657bf894)，即节点的插入遵循先插入左孩子，再插入右孩子的规律，只有当一层节点被填满了，才开始填下一层。



不过，完全二叉树只是我们对二叉堆的抽象理解，实际上实现我们采用一种更高效的结构：数组。









## 第九章 图论算法



图的表示：邻接矩阵、邻接表。前者适合稠密的图，后者适合稀疏的图。





## 附录

### 编程时遇到的问题

C++类中的const函数不能调用非const函数是众所周知的，但是最近我发现const函数在使用类中非const的数据成员时会将该成员转换成const之后再使用，也就是在该const函数中，使用到的数据成员都是const类型的。