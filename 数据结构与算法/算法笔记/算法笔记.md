# 算法笔记

## Ch2

int的范围大致在在$(-2\times 10^9,2\times 10^9)$以内，也就是十亿级别以内的数据都可以用int。



printf使用格式化浮点输出`%.mf`，他的规则是“四舍六入五成双”，具体规则是四舍六入很好理解，五成双的意思是，如果5后面没有其他的数字（或为0），那么就要看5前面最后一个被保留的数的奇偶了，如果是奇数，那么就进一，凑成偶数，如果是偶数则直接舍去；如果5后面有不为0的数，那么直接进一。

> https://cloud.tencent.com/developer/article/1410254



memset是按照字节赋值的。

## Ch3 入门篇



#### PAT B1032

收获：我们创造的数组一般要超过题目所给的最大值一点，否则题目测试的数据很可能就是临界值，然后数组就会爆掉。这道题就是，一开始我给N的值就是100000，提交后最后一个测试点不通过，最后查看书上答案，发现它的N为100010，改了之后就能通过了。

PS：我觉得我的方法比书上的要高效一点。



#### PAT B1036

收获：注意题目给的变量的边界条件，不注意的话很可能会导致错误。

## Ch4 入门篇——算法初步

### 4.1 排序

#### PAT A1025

收获：

排名的一般方法——分数不同排名不同，分数相同的排名相同但是也占用一个排位。书P102

- 实现：1. 结构体自带排名属性。2. 结构体不带排名属性

PS：注意sort函数的前两个参数是地址，所以对于数组元素来说要加取址符，如果是直接用数组名加减就不用了。



#### Codeup 4.1 C

忘了字符串数组不能直接用`==`和`!=`。



#### PAT A1062

https://pintia.cn/problem-sets/994805342720868352/problems/994805410555346944

这题遇到的一个主要问题就是，sort的排序函数（或者是operator<）该怎么写，这里讲一下我个人思考的踩的坑吧。

因为看到题目说不同类的考生都是按照总分排序，同时又要兼顾类别的次序，于是我的想法就是如下的比较方法：

```c++
bool cmp(Student a, Student b){
	if (a.total!=b.total)
    {
        return a.total > b.total && a.type <= b.type;
    }else if (a.vScore!=b.vScore)
    {
        return (a.vScore > b.vScore && a.type <= b.type);
    }else
    {
        return strcmp(a.id, b.id) <= 0;
    }
}
```

其中`total`是总分，`vScore`是德分，`tScore`是才分，`type`是考生类别, `id`是是考号。

信心满满地提交，结果报错，想了很久也不知道为什么会错，还拿两个例子来作比较：

```
first.id: 10000001
first.vScore: 64
first.tScore: 90
first.total: 154
first.type: 4

second.id: 10000002
second.vScore: 90
second.tScore: 60
second.total: 150
second.type: 2
```

`cmp(first, second)`的结果是0，我寻思没错啊，debug到sort函数内部后，发现sort函数把这两个数比较了两次，一次是`cmp(first, second)`，一次是`cmp(second, first)`，具体与sort的实现方式有关，于是我发现这两次比较之后都交换了顺序，所以导致最终没有交换，自己一实验，发现确实，`cmp(second, first)`的结果也是0，也是就知道错误在哪了，这种写法不满足数学层面的比较，数学上如果a<b为假，那么b<a肯定要为真（除了等于的情况）。



正确的写法如下：

```c
bool cmp(Student a, Student b){
    if (a.type!=b.type)
    {
        return a.type<=b.type;
    }else if (a.total!=b.total)
    {
        return a.total > b.total;
    }else if (a.vScore!=b.vScore)
    {
        return (a.vScore > b.vScore;
    }else
    {
        return strcmp(a.id, b.id) <= 0;
    }
}
```

**只有每次比较一个数据，才能保证数学层面的正确。**





### 4.3 递归

#### [Codeup 4.3 C][http://codeup.hustoj.com/problem.php?cid=100000583&pid=2]

思路来源：

https://blog.csdn.net/qq_40725780/article/details/104071456

里面第二个深度搜索的思路是真滴nb，tql

把选择物品当作走路，从第一个开始走起，有两种选法，选或不选，就像一条分叉的路，于是整个选择的过程就可以看成一个二叉树，这个二叉树的高度为n（就是输入的总物品数）。对这个二叉树进行深度优先搜索，在搜索一条路径的过程中能达到sum==40的目标就返回1，即一种选法；若走到底sum还是不能等于40，那么说明这条路上没有满足条件的选法。





### 4.4 贪心

#### Codeup4.4 A

思路就是每一步都找的是范围最小的区间，首先要把所有区间排个序，两种排序方法，要么按照右端点从小到大排，要么按照左端点从大到小排。如果右/左端点相等，那么就按照左/右端点从大/小到小/大排序。

然后，以按照右端点从小到大排为例，我们选择每一个（除了第一个）左端点大于上一个区间右端点的区间，这样就能做到不重叠并且区间最多。

具体可以看书的第122页



#### Codeup4.4 C

http://codeup.cn/problem.php?cid=100000584&pid=2

在这个题耗了一天，主要的问题是，贪心的策略，我们在输入的加油站数组最后再将目的地作为一个实例插入（距离为D，价格为0）。

我们将每到一个加油站作为一步（一次循环），如果达到了最后一个实例（目的地实例），就等于达到了目的地。每到达一个加油站，我们的贪心选择策略是：从当前加油站开始遍历，只遍历后面在加满油的情况下能达到的加油站。如果遍历到的加油站的价格比当前加油站的价格低，则立即停止遍历，同时把该加油站作为下一个目的站点，同时在当前站点加的油量只需要刚好到达下一个站点。如果后面能达到的加油站的价格都比当前站点的高，那么在这些高个子中挑矮个子（价格最低的，即使还是比当前的高）作为下一个目的站点，同时在当前站点加满油。直到达到最后一个站点。

同时还要注意价格的计算，是与油耗相关的。



> 参考：https://blog.csdn.net/joyceyang_999/article/details/82730818



### 4.5 二分

二分法的本质，就是对一个**单调函数**求根（不需要严格单调），如果不是单调函数，就用不了二分法。





P134的思考题，

https://blog.csdn.net/a845717607/article/details/79079862

https://www.cnblogs.com/beiyan/p/8312801.html



这里写一下对书上4.5.1 P127二分法模板的理解，以lower_bound的功能（找出第一个大于等于x的位置）为例，同样，假设arr是递增的序列。

主要是5个点的写法：

```c++
int solution(int arr[], int left, int right, int x)	//Point 0
{
    int mid;
    while (left < right)		//Point 1
    {
        mid = (left+right)/2;
        // if (arr[mid] == x) return mid;	//这个是普通二分查找需要加上的语句，同时最后的return也需要改为return -1
        if (arr[mid] >= x)		//Point 2
            right = mid;		//Point 3
        else
            left = mid+1;			//Point 4
    }
    return left;				//Point 5
}
```

下面写的好像有点问题，请结合下面的链接一起理解：

> https://zhuanlan.zhihu.com/p/141480088
>
> https://zhuanlan.zhihu.com/p/308605122

***Point1*** 这里到底是写`left<right`还是`left+1<right`还是`left<=right`取决于你对这个函数的left和right所定义的区间是什么。

即，如果你定义最后的结果位置为`[left, right]`所夹出来的位置时，那么结果应该是`left==right`，才能确定一个位置，因此循环的条件是`while (left < right)`，当`left==right`时就退出循环，此时**Point5**处的返回值为left或者right都行。

如果你定义最后的结果位置为`(left, right]`所夹出来的位置时，那么结果就应该是`left+1==right`，所以while的循环条件应该为`while (left+1 < right)`，当`left+1==right`时就退出循环，此时**Point5**处的返回值应该为right，因为right是闭。

PS：其实你也可以把结果位置定义为`[left, right)`夹出来的位置，那么循环条件应该也是`left+1 < right`，只不过Point 5处返回的值应该是left了。

至于循环条件为`left<=right`，则是最普通的二分查找元素x但是不存在的情况，若满足了退出条件，那么就判定为未找到。

***Pont2*** 这里的if条件跟据该函数的功能调整，例如，如果你想找的是第一个大于等于x的元素位置，那么这里就写`arr[mid] >= x`，如果是第一个大于x的位置，那么就是`arr[mid] > x`（其实也可以把if的条件取反，只要if和else后面跟的语句也交换一下位置就行）。

***Point3*** 这里应该写成`right=mid`还是`right=mid-1`，取决于即函数的功能，需要考虑临界情况，如果是普通的二分查找，那么应该是`right=mid-1`，因为前面的`if (arr[mid] == x)`已经过滤掉相等的情况了，所以可以到mid的前一个。如果功能是第一个大于等于x或第一个大于x的话，都应该写成`right=mid`，因为是从小到大排的，**你并不能确定`arr[mid]`是否是第一个大于等于/大于x的**，假设mid就是第一个，那么写成`right=mid-1`则会造成逻辑错误，所以为了“保险起见”，只能写成`right=mid`。

***Point4*** 这里应该写成`left=mid`还是`left=mid+1`，也需要跟据你定义的结果区间来判断，如果是`(left, right]`，那么就应该是`left=mid`，因为**你不能确定+1位置的元素是否满足条件，如果满足，那么就会把这个元素排除了（因为是开区间），得到错误的结果。如果你的结果区间的左端点定义为**闭区间，则可以写成`left=mid+1`。

> **!!!!!! -------------Important--------------!!!!!!**
>
> 这里的Point3和Point4写法的理解或许有错，跟据https://blog.csdn.net/weixin_43914593/article/details/112424722这个blog中的题来看，left和right的更新与mid的取整方式有关。
>
> 如果mid是向左端点取整`mid = left+(right-left)/2` ，那么left的更新方式就应该是`left=mid+1`，因为如果是`left=mid`，那么当left和right相差1的时候，mid永远等于left，同时，如果此时的while条件是（left<right），那么就会陷入到死循环中，解决的方法有两个：1. left=mid+1。2. while(left+1<right)。
>
> 如果mid是向右端点取整`mid = left+(right-left+1)/2` ，那么right的更新方式就应该是right=mid-1，理由类比上一段。
>
> ！！！这两个原则的前提条件是while的循环条件是`left<right`！！！
>
> 如果循环条件是`left+1<right`，那么说明我们规定的区间是`(left, right]`或者`[left, right)`。
>
> 那么`left = mid`和`right = mid`就可以同时出现。
>
> `left`和`right`的初始值也要满足你区间的定义。假设我们要找的是第一个大于等于x的位置，如果你的区间是`(left, right]`，那么`left`初始值就应该为`-1`，`right`则应该为`n`；如果你的区间是`[left, right]`，那么`left`初始值就应该为`0`，`right`则应该为`n`。

***Point5*** 这里返回的结果也是根据你定义的结果区间来判断的，如果是`[left, right]`，则返回left、right都行，如果是`(left, right]`，则返回right，如果是`[left, right)`，则应返回left。



#### PAT A1010

https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536

**这个题非常坑：**

这个题虽然表面上只有36个字符，你以为的进制只能最大只有36进制，但是其实可以远大于36进制，不过转换的方法还是一样，该题的进制范围最大可达INT_MAX（即2^31-1），所以在求解过程中——转换为10进制的时候，可能会溢出，即使是long long类型的，也撑不住这么大的基数啊！。所以需要在转换的时候判断溢出，但是已知进制的那个序列默认已知进制的数据在转换时不会爆long long，但是我们需要确定的那个就不确定了。

**PS：为了保险起见，处理过程相关的变量最好都写成LL(long long)类型，防止溢出。**



从这个题中可以学习到的一些技巧：

1. 当涉及到两个对象选择，并且分别需要写不同处理情况的代码的时候，可以把这两个对象转换为一个固定的情况。例如这道题：如果指定的是N1的进制，需要求N2的进制，则直接进行后面的代码；如果已知N2的进制，需要求N1的进制，那么我们可以把这两个字符串交换一下，然后继续执行后面的代码。这样的好处是后面的处理逻辑就可以只写一种情况了，看着清爽，结构也简洁。
2. 经典的空间换时间策略。这里的字符串转换为10进制策略是将36个字符对应的十进制大小存储到一个hash数组中，之后再转换的时候直接取出来就行，而不用每次都计算。
3. 可以利用已知条件，缩小搜索的范围。即，所需要求的radix的最小值是字符串（N2）最大值加一，而最大值是已知进制字符序列（N1）转换为10进制后的值+1，因为超过过这个值后，N2转换为10进制后的值肯定大于N1的值。





## Ch5 入门篇——数学问题

### 5.7 扩展欧几里得算法

欧几里得算法也是我们中国所说的辗转相除法，最原始的用法是用来计算最大公约数的，在本节中，我们把它应用到了一种特殊的方程、同余式以及逆元的求解。

一、

扩展欧几里得算法就是要求这么一个方程：$ax+by=gcd(a,b)$，其中a、b已知且不为0，gcd(a, b)为a、b的最大公约数，我们需要求该方程的关于x、y的一组整数解。



二、

进一步扩展，可以用来求解方程：$ax+by=c$，这个c可以是任意整数，这个方程可以看作是上面一个方程左右两边同时除以gcd(a, b)，再同时乘以c。得到如下方程：$a\frac{cx}{gcd}+b\frac{cy}{gcd}=c$。假设上面第一种方程的一组解是$(x_0, y_0)$，那么这里的一组解就是$(\frac{cx_0}{gcd}, \frac{cy_0}{gcd})$。存在这个解的前提条件是$c\%gcd(a,b)==0$。



三、

同余式$ax$的求解，这个式子可以扩展为$ax-c=my$，进一步得到$ax+my=c$，即转换为了上一种情况的求解，不过我们只在乎x。解存在的条件也是$c\%gcd(a,m)==0$。

