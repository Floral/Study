# 算法笔记

## Ch2

int的范围大致在在$(-2\times 10^9,2\times 10^9)$以内，也就是十亿级别以内的数据都可以用int。



printf使用格式化浮点输出`%.mf`，他的规则是“四舍六入五成双”，具体规则是四舍六入很好理解，五成双的意思是，如果5后面没有其他的数字（或为0），那么就要看5前面最后一个被保留的数的奇偶了，如果是奇数，那么就进一，凑成偶数，如果是偶数则直接舍去；如果5后面有不为0的数，那么直接进一。

> https://cloud.tencent.com/developer/article/1410254



memset是按照字节赋值的。

## Ch3 入门篇



#### PAT B1032

收获：我们创造的数组一般要超过题目所给的最大值一点，否则题目测试的数据很可能就是临界值，然后数组就会爆掉。这道题就是，一开始我给N的值就是100000，提交后最后一个测试点不通过，最后查看书上答案，发现它的N为100010，改了之后就能通过了。

PS：我觉得我的方法比书上的要高效一点。



#### PAT B1036

收获：注意题目给的变量的边界条件，不注意的话很可能会导致错误。





## Ch4 入门篇——算法初步

### 4.1 排序

#### PAT A1025

收获：

排名的一般方法——分数不同排名不同，分数相同的排名相同但是也占用一个排位。书P102

- 实现：1. 结构体自带排名属性。2. 结构体不带排名属性

PS：注意sort函数的前两个参数是地址，所以对于数组元素来说要加取址符，如果是直接用数组名加减就不用了。



#### Codeup 4.1 C

忘了字符串数组不能直接用`==`和`!=`。



#### PAT A1062

https://pintia.cn/problem-sets/994805342720868352/problems/994805410555346944

这题遇到的一个主要问题就是，sort的排序函数（或者是operator<）该怎么写，这里讲一下我个人思考的踩的坑吧。

因为看到题目说不同类的考生都是按照总分排序，同时又要兼顾类别的次序，于是我的想法就是如下的比较方法：

```c++
bool cmp(Student a, Student b){
	if (a.total!=b.total)
    {
        return a.total > b.total && a.type <= b.type;
    }else if (a.vScore!=b.vScore)
    {
        return (a.vScore > b.vScore && a.type <= b.type);
    }else
    {
        return strcmp(a.id, b.id) <= 0;
    }
}
```

其中`total`是总分，`vScore`是德分，`tScore`是才分，`type`是考生类别, `id`是是考号。

信心满满地提交，结果报错，想了很久也不知道为什么会错，还拿两个例子来作比较：

```
first.id: 10000001
first.vScore: 64
first.tScore: 90
first.total: 154
first.type: 4

second.id: 10000002
second.vScore: 90
second.tScore: 60
second.total: 150
second.type: 2
```

`cmp(first, second)`的结果是0，我寻思没错啊，debug到sort函数内部后，发现sort函数把这两个数比较了两次，一次是`cmp(first, second)`，一次是`cmp(second, first)`，具体与sort的实现方式有关，于是我发现这两次比较之后都交换了顺序，所以导致最终没有交换，自己一实验，发现确实，`cmp(second, first)`的结果也是0，也是就知道错误在哪了，这种写法不满足数学层面的比较，数学上如果a<b为假，那么b<a肯定要为真（除了等于的情况）。



正确的写法如下：

```c
bool cmp(Student a, Student b){
    if (a.type!=b.type)
    {
        return a.type<=b.type;
    }else if (a.total!=b.total)
    {
        return a.total > b.total;
    }else if (a.vScore!=b.vScore)
    {
        return (a.vScore > b.vScore;
    }else
    {
        return strcmp(a.id, b.id) <= 0;
    }
}
```

**只有每次比较一个数据，才能保证数学层面的正确。**



#### [Codeup 4.3 C][http://codeup.hustoj.com/problem.php?cid=100000583&pid=2]

思路来源：

https://blog.csdn.net/qq_40725780/article/details/104071456

里面第二个深度搜索的思路是真滴nb，tql

把选择物品当作走路，从第一个开始走起，有两种选法，选或不选，就像一条分叉的路，于是整个选择的过程就可以看成一个二叉树，这个二叉树的高度为n（就是输入的总物品数）。对这个二叉树进行深度优先搜索，在搜索一条路径的过程中能达到sum==40的目标就返回1，即一种选法；若走到底sum还是不能等于40，那么说明这条路上没有满足条件的选法。