# 算法竞赛入门经典

## 第二章

### 2.4 算法竞赛中的输入输出框架

#### 标准输入常用循环：

```c++
while(~scanf("%d",&x))//这里的参数个数可自定
{
    //...
}
```



#### 重定向方法freopen

- `freopen`函数

  利用该方法可以将标准输入流从键盘指向文件，例如：

​	`freopen("data.in","r",stdin)`，将data.in文件中的内容读取到stdin——标准输入流中，之后在任何地方使用`scanf`，就不用通过键盘输入，而是直接接收data.in文件中的数据。

​	同理`freopen("data.out","w",stdout)`，则是将标准输出重定向至data.out文件，之后使用任何输出到stdout的函数（例如printf），就会将结果输出到data.out文件。



#### 非重定向读取文件fopen

​	使用fopen首先要定义一个文件指针变量，然后将fopen的返回值赋值给它，然后利用fscanf和fprintf进行书剑的读取和输出，下面直接给出一个实例：

```c++
//其余固定部分省略，只写main函数内的部分代码

	FILE *fin,*fout;
	fin=fopen("data.in","rb");
	fout=fopen("data.out","wb");
	int x;
	fscanf(fin,"%d",&x);
	fprintf(fout,"This is fprintf,x is : %d",x);
	fclose(fin);
	fclose(fout);
	//上面这两句可不要掉了
```



### 小技巧总结

#### 习题2-4

本题的输入有一个很大的数65536，它的平方超过了int所表示的最大范围，我们可以使用unsigned int或者将平方改成连除，这样就避免了平方导致的溢出



#### 题目2

```c++
for(double i=0;i!=10;i+=0.1)
{
    printf("%.1f\n",i);
}
```

这种写法会无限循环下去，因为计算机中的浮点型(float和double)都有一定的误差，不能精确地加到10



## 第三章 数组和字符串

### 3.1

很大的数组尽量放在main函数外部，若放在main函数内部则是局部变量。而程序的局部变量是存储在栈中，栈的大小是从程序运行一开始就固定了的，而且容量较小，全局变量则是存储在堆中，程序的堆空间可根据程序需求调整，同时容量很大。



> 学会使用string.h库
>
> 例如：
>
> - 用memset来初始化数组/字符串

#### P40 蛇形填数

这个题，我最初的思路是在一个大的for循环中通过if来判断转弯的时刻，填入的数字由大的for循环控制，但是这样很有难度。buyaodiaole

看了一下答案，它的思路是在一个大的循环中嵌套四个小的循环，分别控制矩阵“指针”的下左上右，同时填入的数字在每个小循环中依次递增，大循环每循环一遍，矩阵就会被填上一圈——一个完整的周期。

我的思路误区就是`把填入数字的增加限制在了最外层循环中`。

### 3.2

#### 竖式问题

这个问题中用到了`sprintf`和`strchr`这两个函数

- `sprintf`是把输出输出到字符串里

- `strchr`是在一个字符串中查找单个字符



#### Uva272

由于scanf不能读取空格、换行、TAB，所以这里我们要使用新的函数：

- `fgetc()与getchar()`

`fgetc(fin)`,fin是之前提到过的FILE指针，fgetc的作用是从fin文件流中读取一个字符，任何字符,返回的是int值，可以直接强制转换为char类型。但是要注意检查返回值是不是EOF，若不是再转。

`fgetc(stdin)`等效于另一个函数`getchar()`

- `fgets()与gets()`zhuanzhuan

`fgets(buf,maxn,fin)`，是从fin中读取完整的一行，遇到'\n’就停止。其中buf的声明为buf[maxn]。这个函数读取不超过maxn-1个字符，然后在末尾加上'\0'

`fgets()`由于不会限制读取字符串的大小，可能会造成缓冲区溢出漏洞，在C11标准中已被删去。



#### UVa10082

- 此题技巧

若用switch判断所有情况，太麻烦了，这里采用`常量数组`的技巧。

- 注意这题有个坑

最后输入的换行符`\n`也会被getchar接收并输出，所以要考虑输入为`\n`的情况，要求是仍然输出换行符，我之前做的时候只考虑了空格。最好还是像树上的那种做法，效率比较高。向大佬Orz。



#### UVa401

- 这一题要注意strlen(s)返回的是s的实际长度，不包括结尾的`\0`。

- 用到了ctype.h里的`isalpha(ch)`，用于判断一个字符是否是字母。
- 注意运用char-char的技巧，这样得出来的是两个字符的ascii码之差，可以用来得到前一个字符相对后一个字符的相对位置（下标）。
- 还有一点就是这里用于返回结果的字符数组的下标运用到了二进制编码的技巧，值得学习。



#### UVa340



## 第四章 函数和递归

前面的两个小问题：**组合数**和**素数判定**的两个小技巧值得学习。

同时，判定素数（2）中，通过+0.5再调用floor函数来四舍五入很有意思（不过我想为什么不能+0.5后再直接赋值给m呢？应该也能四舍五入吧）。



### 调用栈！

在运行程序的过程中，计算机内存中有一段被称作“调用栈（Call Stack)”的部分。调用栈描述的是函数之间的调用关系，它由多个栈帧（Stack Frame）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的返回地址和局部变量，因此能在函数执行完毕后找到正确的返回地址并且保证每个函数内的局部变量不变。



### 指针易犯的错误

一个没有初始化的指针最好不要随便用，

例如：

```c
int *t;
*t=123;
```

由于t没有初始化，t的值是一个随机的，*t=123就是将123赋值到这个随机地址上，如果这个随机地址能被写入，运行就“没有问题”，但是可能会造成其他程序或数据的错误，如果这个随机地址不能写入，那么程序就会崩溃。



### 把数组作为参数和返回值

- 直接把形参声明为数组的话，不能得到该数组的大小，应该再加一个参数n来传递数组大小。例如：

  `int sum(int *a,int n){}`

  > int *a等价于int a[]

- 还可以直接传入数组的起始指针和结尾指针(左开右闭)

  `int sum(int *start,int *end){}`

### 把函数作为函数的参数

C语言的stdlib.h库中有一个函数qsort——快速排序，它的声明如下：

`void qsort(void *base,size_t num,size_t size,int (*comparator)(const void *,const void *));`

这里的最后一个参数就是函数指针，它指向的函数应该是这样的格式：

`int cmp(const void *,const void *){...}`，这里的`const void *`是一个“万能指针”，能被强制转换成任意类型的指针。

这种函数指针在以后非常有用，在第五章会有详细介绍。



### 递归

递归就是自己调用自己，不过也分两种，一种是直接递归，另一种是间接递归。顾名思义直接递归就是在函数内部直接调用自己，间接递归是在函数内部调用其它函数，而其它函数又调用了原来的函数。

递归的一个缺点就是，在递归的次数太多时，会创建很多栈帧，调用栈所处的**堆栈段**就会溢出（Stack Overflow）

> 同时，栈的溢出不一定是栈太多了，也可能是栈帧中局部变量太大了，所以在之前我们说过建议把很大的局部变量放在main函数之外。

堆栈段的大小上限可以设置，Linux系统下可以通过ulimit命令来查看和修改各种段的限制；Windows系统中栈的大小是储存在可执行文件中的，因此在编译时指定参数即可设置站的大小，例如`gcc -Wl,--stack=16777216`，这样栈的大小就变为16MB。

