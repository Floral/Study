# 自己动手写CPU

## 第一章 处理器与MIPS

### 指令集架构ISA（Instruction Set Architecture）

ISA将编程所需了解的硬件信息从硬件系统中抽象出来。从软件人员的角度看，ISA包括一套指令集和一些寄存器。ISA只是描述了CPU应该支持的每条指令是做什么事的，即指令的功能。简单地说，ISA就是提供给汇编程序员的最底层硬件的接口。

### 微架构（Microarchitecture）

微架构是ISA的一个具体实现。ISA好比设计规范，微架构则是具体实现。用编程里的概念类比，ISA就是接口（所能实现的各种功能），微架构就是实现功能的具体方式（采用的不同的算法），因此，同样的ISA，不同的微架构，会带来不同的性能。

- ISA主要分为CISC和RISC。
- CISC目前主流只有x86
- RISC主流包括ARM、SPARC、POWER、MIPS



其他博主的blog：

https://blog.csdn.net/qq_42914528/article/details/81779727



## 第四章 第一条指令ori的实现

**本章关键词：流水线、MIPS编译环境**

首先要做的就是搭建一个流水线结构。所谓流水线，在电路上的结构就是组合逻辑和时序逻辑电路级联，并没有想象中的那么复杂（还有一种结构是寄存器的输入端和输出端存在回路，被称为状态机）。

本书的CPU采取五级流水线结构，分别为：取指、译码、执行、访存、回写。

其中，译码阶段所要做的除了把机器码解释为不同的指令，还要承担取得操作数的工作，即从regs中（或指令中的立即数）取得执行阶段所需要的两个操作数（无论是否有一个操作数为立即数，都会把两个操作数分别转化为为reg1_o、reg2_o）。

不同阶段模块中通过中间模块连接（例如：if_id.v、id_ex.v等），这些模块所做的事几乎都是把输入数据按原样传递给下一个阶段，为什么要有这些模块呢？主要原因是将各个阶段的模块分离，并且严格按照时钟传送数据。

可以看到，流水线的各个阶段的敏感信号都是`*`（除了pc_reg取指令模块），即always块内的所有输入信号（相当于定义了一个组合逻辑电路）。而中间的过度模块中always的敏感信号都是`posedge clk`，即时钟的上升沿（相当于定义了时序逻辑电路）。这就保证了五级流水线中各个阶段的数据每个时钟周期就流向下一阶段，即“流水线”工作方式。

> 读取reg的电路是组合电路，即输入一有变化就立即反馈，这也保证了译码阶段及时取得操作数。

### 4.4 MIPS编译环境

本章简单的介绍了MIPS汇编程序编译链接的过程。

首先，由于我们写的是MIPS架构的CPU，用到的编译器也是MIPS的汇编器、链接器等。这些编译工具也都是在MIPS架构的CPU和系统环境下运行的。因此我们首先就是要取得这个环境。

直接在我们自己的PC机上装的Ubuntu/Linux或者Win10中的WSL都是不能运行该编译环境的（会报类似“二进制文件格式错误”的错，因为这个编译工具本身就是在MIPS架构下编译得到的，它的二进制机器。语言我们的PC机“看不懂”），因为现在的个人PC机基本上都是X86架构的CPU了（如果你用的是龙芯，请忽视这句话），系统也是分CPU架构的，大部分的Linux目前也是基于X86的，也可以去各个发行版的官网上找其他架构的版本。于是我们首先需要一个基于MIPS开发的Linux系统，本书采用的是OpenRISC版本的Ubuntu，目前书上给出的网站已经访问不了，官网上也下不了这个版本的Ubuntu，但是万能的网友当然会有“存货”的啦，直接搜`OpenRISC_Ubuntu_2011-12-15.vdi.bz2`这个关键词，应该是能搜到的（本人通过404网站搜的，度娘没有试过），或者直接去各种搜百度网盘资源的网站搜就行。然后下载virtual box虚拟机安装，具体步骤书上有，百度也行。

然后就是下载MIPS编译工具链了，这个可以在某Hub上搜到（CSDN的要积分）。下载完成后通过共享文件夹在虚拟机中可以运行了。

编译的过程如下：

1. 写MIPS的汇编程序
2. 使用`mips-sde-elf-as`指令将汇编程序编译成目标文件（Object），为链接做准备。这里的`.o`格式文件是ELF（Executable and Linkable Format），ELF文件有三种类型，这一步得到的是一个Relocatable类型的，其中包含着描述text段、data段、bss段等的描述信息，例如：段起始地址、长度等。
3. 编写链接描述文件，链接描述脚本描述了输入文件的各个Section如何映射到输出文件的各个Section中，并控制输出文件中Section和符号的内存布局。
4. 使用`mips-sde-elf-ld`指令将`.o`文件和链接描述脚本一起链接得到可执行文件`.om`（也属于ELF文件）。
5. 上一步得到的`.om`文件是一个ELF的可执行文件，其格式与我们需要加载到rom中的格式有很大不同，因此还需要使用 `mips-sde-elf-objcopy`将`.om`文件转化为二进制文件`.bin`。然后通过一个小程序进一步转换成我们需要的`.data`文件。

总结一下就是：编译、链接、转换格式。这里我们使用了好几个命令，这时为了可以重复使用，我们可以编写一个**Makefile**。来一次完成所有的工作。所以Makefile的本质就是把一个程序从编译到链接到转换格式所需要在terminal中输入的命令集中到一个文件中。Makefile的具体语法请自行搜索或看书上的简单介绍。

## 第五章 逻辑、位移操作与空指令的实现

**本章关键词：数据相关、数据前推**

#### 数据相关问题

数据相关问题包括：RAW(Read After Write)、WAR(Write After Read)、WAW(Write After Write)。

由于本书的CPU分为五级流水线，在译码阶段读寄存器，在回写阶段才会写寄存器，因此不存在WAW相关和WAR相关。

解决RAW的方法有：

- 插入暂停周期
- 编译器调度，即编译器可以检测到相关性问题并且调准执行执行的顺序。
- 数据前推，即将执行阶段得到的结果直接发送到译码阶段，而不需要等到回写阶段。

本书OpenMIPS采用数据前推的方法解决RAW（Read After Write）的问题。具体的实现就是在id阶段增加两个**数据选择器（MUX）**，根据执行阶段和访存阶段反馈回来的值和信号具体确定是哪两个数据输出到ex阶段。

译码阶段输出的Aluop和Alusel是为了方便执行阶段执行操作的判断。

无论是寄存器位移版本（sllv、srav、srlv）还是立即数位移版本（sll、sra、srl），最终都是通过reg1_o和reg2_o输出两个操作数给id_ex.v至ex.v。

对任意一条指令而言，译码阶段工作的主要内容是：确**定要读取的寄存器的情况、要执行的运算和要写入的目的寄存器**三方面的信息。



## 第六章 移动指令的实现

**本章关键词：特殊寄存器、数据相关**

本章要实现的移动操作指令需要先新增**HI、LO两个特殊寄存器**，独立于regfile，位于回写阶段。

由于本章实现的移动操作指令造成的**数据相关的问题**包括普通寄存器regfile和特殊寄存器HI、LO的，前者已经在第五章解决了，因此我们在这里只需增加解决HI、LO两个寄存器的数据相关问题。这里我们的设计是：**译码阶段并不直接读取HI、LO的数值，而是在执行阶段才读取**，所以**新增的MUX放在执行阶段**，数据进入ALU之前。在哪个阶段加MUX，就要在修改哪个阶段的代码（虽然听着是个废话），数据通路是通过修改顶层文件openmips来实现的，顶层文件的本质就是按照数据流图连线。





## 第七章 算术操作指令的实现

**本章关键词：流水线暂停、试商法、有限状态机**



本章所要实现的算术操作指令可以分为三类：

1. 简单算术操作指令

   包括加法、减法、比较、乘法等指令（不包括除法），该类指令与前面所实现的思路差不多。这些指令在流水线的执行阶段都只需要一个时钟周期。

2. 乘累加、乘累减

   正如其名，该类指令包括乘和加/减两种操作，因此执行阶段需要更长的时间来运行，如果我们将这两个操作都放在一个时钟周期中，那么一个时钟周期的时间就要增加，那么整个CPU的频率就会下降，从而导致流水线的其他阶段的执行速度也减慢了。

3. 除法指令

   包括有符号除法（div）和无符号除法（divu），OpenMIPS采用的是试商法完成除法运算，对于32位的除法，流水线执行阶段至少需要32个时钟周期。



### 第一类指令的实现

基本与前面章节的思路一致，没什么大问题。



> PS：这里遇到的一个小问题就是括号的位置了。。。详见ex.v中248行。注意&&比||的优先级要高，因此括号的位置会影响结果。同时摸索了仿真调试的技巧，遇到问题，首先定位是哪里、哪个模块出了问题。
>
> 首先，可以在仿真器里显示各个可疑模块的输入和输出（本次我只测试了id.v和ex.v模块）。看有没有异常的信号，如果有，那么就可以判断错误的代码在对应的模块了。
>
> 然后，在该模块中找到会影响异常输出值的所有代码，显示中间值的信号图，依次排除。 
>
> > PPS：要注意的是，我们一般发现出错的地方是寄存器的值，由于我们采用了五级流水线的结构，实际出错的地方会出现在寄存器值错误的前几个周期，如果看的是执行阶段，那么就是提前3个时钟周期，因为到达回写阶段后，写入regfile还会增加一个时钟周期。





### 7.5 流水线暂停机制的设计与实现

因为本章要实现的后面几种指令在执行阶段需要多个时钟周期，所以我们需要暂停流水线。

为了实现暂停，我们新增一个**CTRL模块**，用于接收暂停请求信号和发送暂停信号。由于只可能在译码和执行阶段需要多个周期，所以只有译码和执行两个阶段可以发送暂停请求。当一个阶段请求暂停时，这个阶段之前的流水线都得暂停，之后的可以继续执行。另外，译码和执行这两个阶段不需要接受暂停信号，且接受暂停的都是各个模块之间的过度模块和pc_reg.v（因为他们才受时钟周期的控制）。同时，为了保存MADD、MSUB、MADDU、MSUBU指令执行阶段的第一个时钟周期的中间结果，还要在ex.v和ex_mem.v上增加两个输入和输出端口，分别用于保存乘法结果和指示第几个时钟周期。





### 7.11 除法指令实现思路

由于实现除法的算法比较复杂，所以我们这里新增一个div.v模块专门用来做除法运算。OpenMIPS采用的是**试商法**，也就是我们小学学除法的时候用的**短除法**。由于OpenMIPS的寄存器是32位的，要从最高位开始试，所以最少要**32个时钟周期**。div模块具体的实现是一个**有限状态机**，它有四种状态：DivFree、DivByZero、DivOn、DivEnd。

ex.v模块中添加控制div.v模块的部分，包括除法所需要的数据和是否开始的标志，同时ex.v也要接收div.v的输出。

其他地方都与之前实现过的指令类似，就不多说了。

要说明的一点是，顶层文件的div.v模块实例化中的annul_i信号目前没有变化，始终为1’b0，因为现在没有要取消除法指令的状况。在之后的异常处理中会有。







## 第八章 转移指令的实现

**本章关键词：控制相关、延迟槽、转移判断**



由于采用了流水线结构，转移指令会导致**控制相关**问题，控制相关是指流水线中的分支指令或其他需要改写PC值的指令造成的相关。由于改写了PC值，会导致在流水线中的后面几条指令无效（本处理器是两条），需要重新取指。

为了减少时钟周期的浪费，我们可以采用**延迟槽**机制，规定转移指令后面的指令位置为“延迟槽”，延迟槽中的指令被称为延迟指令，延迟指令总是被执行（本质是因为在转移指令在译码的时候，由于流水线的原因，下一条指令已经被取出来了），与转移发生与否没有关系，于是就节省了一个时钟周期。剩余的一个时钟周期通过在**译码阶段**进行**转移判断**来节省，如果位于译码阶段的是转移指令，且满足转移条件，那么**译码阶段直接将转移的目的地址传送给PC模块**，这样就不会读取转移指令后面的第二条指令了。这里PC模块新增了一种取值的可能性，在本章之前，有两种可能：1. 正常+4，2. 由于流水线暂停而保持不变。本章新增了 第3种，转移的目的地址。因此要在PC模块的MUX中新增一种可能，这种可能的前提是流水线没有暂停。

本章的ex.v暂时没有用到`is_in_delayslot_i`这个信号，这会在异常处理中用到。



> 延迟槽后面的指令为什么一定执行却没有逻辑错误呢？
>
> 因为一个高级语言的程序经过编译器编译成汇编语言后（或者是汇编语言编译成机器语言），编译器会重新排列语句的顺序来优化执行效率。在这里编译器将一个肯定会执行的语句放在转移指令的后面，就能节省掉一个时钟周期。（这也是为什么我们在编写汇编测试程序的时候要加上一句`.set noreorder`，这是为了不让编译器对程序进行优化和改动）在这里膜拜一下写编译器的大大们！





## 第九章 加载存储指令的实现

**本章关键词：地址对齐与非对齐、大端模式**



由于本书所搭建的“计算机”采用的是哈佛结构，即程序存储器与数据存储器是分开的，本章实现的数据加载/存储指令是指**CPU内通用寄存器与数据存储器之间的数据交互**，也就是属于流水线中访存阶段的操作了。

MIPS32指令集架构中定义的加载存储指令共有14条：

- 8条加载指令：lb、lbu、lh、lhu、ll、lw、lwl、lwr
- 6条存储指令：sb、sc、sh、sw、swl、swr

这些指令中，l（第一个l）代表load，b代表byte，h代表half-word，w代表word，其中ll、sc比较特别，lwl、lwr、swl、swr的工作方式有些难理解，这4条指令是**非对齐**加载/存储指令，其他的涉及到多字节加载/存储的指令都有**地址对齐**的要求。

> OpenMIPS处理器是按照字节寻址的，并且是**大端模式**，即高有效位数据保存在低地址。

### lwl、lwr、swl、swr指令

lwl、lwr分别是向左加载、向右加载的意思。

lwl具体的作用：将该指令指定的 加载地址（可以是非对齐的）所在的 对齐的字 的最高地址（也就是最低有效位，图中画出的是最右端），向左数到该指令所直接指定的地址，将这一段所包括的字节数据，加载到目的寄存器的高有效位，即按照大端模式从高到低排列。

<img src=".\pic\chapter9_1.png" alt="image-20200206144250790" style="zoom: 33%;" />

具体看本书上的这个例子，我们算出来指令中指定的加载地址是5，也就是非对齐的地址，它所在的是第二个对齐的字（地址范围是4-7），从这个子的最高地址7向左开始数，直到遇到指定的加载地址5，这一段包括了5、6、7三个字节的地址，然后我们将这三个字节的数据按照原来的大端顺序放入目的寄存器\$1的高位，即低三个字节（如果是两个字节数据则只按序放入低两个字节）。

lwr的方式是从指令指定的 加载地址 所在的 对齐的字 的最低地址（也就是最高有效位，图中画出的是最左端）开始，从左向右数到指定的加载地址，然后按序加载到指定寄存器的低有效位，按图中所画的就是靠右边了。

与非对齐加载对应的就是非对齐存储了，有两条指令swl、swr。具体工作方式的基本上就是将上述的加载过程反过来（具体请看书上的例子自行体会）。

这4个非对齐的加载/存储指令的目的就是为了简便地向非对齐地址加载/存储字。如果使用其他常规的对齐指令，那么还需要位移指令、逻辑或指令的辅助，都需要5条指令来完成，而使用这4个非对齐指令只需要2条指令就能完成。



### 修改id.v

这里我们只需要增加对应新增的加载存储指令的情况就行了，只需输出该指令的寄存器读写情况（与之前的一般指令一致）。不过值得注意的是，对于lwl、lwr指令来说，除了需要获取基址寄存器的值，还需要获取写入的目的寄存器的值，因为这两条指令是写入部分的值，而不是整个字的值，因此需要原寄存器的值与写入值组合得到整个字的值。

同时，id模块新增了一个inst_o输出端口，用于传递指令到ex模块来计算访存阶段最终访问的地址。

### 修改id_ex.v与ex.v

id_ex.v新增inst_i与inst_o用于连接过渡。

ex中接收inst_i，新增aluop_o、mem_addr_o、reg2_o输出，并传递到mem.v。其中mem_addr_o是加载存储指令要访问的地址。reg2_o是存储指令要存储的值或者是lwl、lwr指令要加载到的目的寄存器的原始值。

### 修改mem.v

本章重点修改的地方就是mem.v和data_ram.v了。mem.v与data_ram.v（数据存储器）相连接，用于访问（读/写）数据存储器。mem.v新增加载存储指令对应的情况。

mem.v新增的用于控制data_ram的输出包括mem_data_o、mem_addr_o、mem_we_o、mem_sel_o、mem_ce_o。依次是：要写入的数据、要写入的地址、是否要写入、字节选择信号、存储器使能信号。

另外，由于data_ram的读写总是针对一个对齐后的字（可以看作不考虑mem_addr_o的最低两位的值），所以我们在mem阶段就要通过mem_addr_i的值来设置mem_sel_o的值。

### data_ram.v

这里的data_ram模块是由4个单字节的存储器组成一个32位的存储器的。且读数据和写数据输入的地址都会被转换成该地址所在的 字的首地址（通过除以4来实现，具体是取addr的[`DataMemNumLog2:2]部分）。这样是参考了Wishbone总线的相关规范，使得在后期添加Wishbone总线的时候容易一些。

<img src=".\pic\chapter9_2.JPG" alt="chapter9_2" style="zoom: 20%;" />



### 9.5 测试程序

这里的测试程序有一点坑，那就是**load相关问题**。在测试程序第三阶段的后半部分，有连续的3个加载指令（lw、lwl、lwr），如果运行会导致结果与预期的不一样。这是因为load相关问题，有前面所讲的可知，加载存储指令是在mem阶段读取到该写入到通用寄存器中的值，而lwl、lwr读取目的寄存器的值是在译码阶段，因此如果有指令就会导致结果与预期不同（其他load指令也会读取基址寄存器的值，如果前一条也是加载指令并且影响想了它的值，那么也会造成错误）。

有一些写坑的是作者在这之前并没有提到过这个问题……直到9.10小节才提出，并且是用beq紧接lw指令来做例子的……（可能是作者疏忽了吧）。本菜鸡在这里折腾了几个小时，用ModelSim看信号找bug找到怀疑人生……。





## 附录

### 关于verilog中always的并行性

一个module里面的不同always块只要满足条件就会执行。如果多个always块的敏感信号条件相同，那么就是并行的。

如果两个并行的always块中的信号是相关的，那么其执行时会取得其需要的值是前一刻的值，具体还是看一个例子吧。

https://blog.csdn.net/jiangbeicaizi000/article/details/52093945

同时，`always @(*)` 是**一种描述组合逻辑的方式**。它相当于把always块内的所有输入信号都添加到了敏感信号列表里，这里说的输入信号，就是always块内“位于赋值符号右边”的信号（个人认为，如有异议，欢迎提出讨论）。

可以参考：https://zhuanlan.zhihu.com/p/72078544

现在，我们再来看本书的流水线结构，其各个阶段内部的模块都是组合逻辑电路来完成的，连接各个阶段的模块都是时序逻辑电路。并且是串连起来的，因此是流水线模式。



**其他关于always的blog：**

https://blog.csdn.net/phenixyf/article/details/46364193