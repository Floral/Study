# 自己动手写CPU

## 第一章 处理器与MIPS

### 指令集架构ISA（Instruction Set Architecture）

ISA将编程所需了解的硬件信息从硬件系统中抽象出来。从软件人员的角度看，ISA包括一套指令集和一些寄存器。ISA只是描述了CPU应该支持的每条指令是做什么事的，即指令的功能。简单地说，ISA就是提供给汇编程序员的最底层硬件的接口。

### 微架构（Microarchitecture）

微架构是ISA的一个具体实现。ISA好比设计规范，微架构则是具体实现。用编程里的概念类比，ISA就是接口（所能实现的各种功能），微架构就是实现功能的具体方式（采用的不同的算法），因此，同样的ISA，不同的微架构，会带来不同的性能。

- ISA主要分为CISC和RISC。
- CISC目前主流只有x86
- RISC主流包括ARM、SPARC、POWER、MIPS



其他博主的blog：

https://blog.csdn.net/qq_42914528/article/details/81779727



## 第四章 第一条指令ori的实现

**本章关键词：流水线、MIPS编译环境**

首先要做的就是搭建一个流水线结构。所谓流水线，在电路上的结构就是组合逻辑和时序逻辑电路级联，并没有想象中的那么复杂（还有一种结构是寄存器的输入端和输出端存在回路，被称为状态机）。

本书的CPU采取五级流水线结构，分别为：取指、译码、执行、访存、回写。

其中，译码阶段所要做的除了把机器码解释为不同的指令，还要承担取得操作数的工作，即从regs中（或指令中的立即数）取得执行阶段所需要的两个操作数（无论是否有一个操作数为立即数，都会把两个操作数分别转化为为reg1_o、reg2_o）。

不同阶段模块中通过中间模块连接（例如：if_id.v、id_ex.v等），这些模块所做的事几乎都是把输入数据按原样传递给下一个阶段，为什么要有这些模块呢？主要原因是将各个阶段的模块分离，并且严格按照时钟传送数据。

可以看到，流水线的各个阶段的敏感信号都是`*`（除了pc_reg取指令模块），即always块内的所有输入信号（相当于定义了一个组合逻辑电路）。而中间的过度模块中always的敏感信号都是`posedge clk`，即时钟的上升沿（相当于定义了时序逻辑电路）。这就保证了五级流水线中各个阶段的数据每个时钟周期就流向下一阶段，即“流水线”工作方式。

> 读取reg的电路是组合电路，即输入一有变化就立即反馈，这也保证了译码阶段及时取得操作数。

### 4.4 MIPS编译环境

本章简单的介绍了MIPS汇编程序编译链接的过程。

首先，由于我们写的是MIPS架构的CPU，用到的编译器也是MIPS的汇编器、链接器等。这些编译工具也都是在MIPS架构的CPU和系统环境下运行的。因此我们首先就是要取得这个环境。

直接在我们自己的PC机上装的Ubuntu/Linux或者Win10中的WSL都是不能运行该编译环境的（会报类似“二进制文件格式错误”的错，因为这个编译工具本身就是在MIPS架构下编译得到的，它的二进制机器。语言我们的PC机“看不懂”），因为现在的个人PC机基本上都是X86架构的CPU了（如果你用的是龙芯，请忽视这句话），系统也是分CPU架构的，大部分的Linux目前也是基于X86的，也可以去各个发行版的官网上找其他架构的版本。于是我们首先需要一个基于MIPS开发的Linux系统，本书采用的是OpenRISC版本的Ubuntu，目前书上给出的网站已经访问不了，官网上也下不了这个版本的Ubuntu，但是万能的网友当然会有“存货”的啦，直接搜`OpenRISC_Ubuntu_2011-12-15.vdi.bz2`这个关键词，应该是能搜到的（本人通过404网站搜的，度娘没有试过），或者直接去各种搜百度网盘资源的网站搜就行。然后下载virtual box虚拟机安装，具体步骤书上有，百度也行。

然后就是下载MIPS编译工具链了，这个可以在某Hub上搜到（CSDN的要积分）。下载完成后通过共享文件夹在虚拟机中可以运行了。

编译的过程如下：

1. 写MIPS的汇编程序
2. 使用`mips-sde-elf-as`指令将汇编程序编译成目标文件（Object），为链接做准备。这里的`.o`格式文件是ELF（Executable and Linkable Format），ELF文件有三种类型，这一步得到的是一个Relocatable类型的，其中包含着描述text段、data段、bss段等的描述信息，例如：段起始地址、长度等。
3. 编写链接描述文件，链接描述脚本描述了输入文件的各个Section如何映射到输出文件的各个Section中，并控制输出文件中Section和符号的内存布局。
4. 使用`mips-sde-elf-ld`指令将`.o`文件和链接描述脚本一起链接得到可执行文件`.om`（也属于ELF文件）。
5. 上一步得到的`.om`文件是一个ELF的可执行文件，其格式与我们需要加载到rom中的格式有很大不同，因此还需要使用 `mips-sde-elf-objcopy`将`.om`文件转化为二进制文件`.bin`。然后通过一个小程序进一步转换成我们需要的`.data`文件。

总结一下就是：编译、链接、转换格式。这里我们使用了好几个命令，这时为了可以重复使用，我们可以编写一个**Makefile**。来一次完成所有的工作。所以Makefile的本质就是把一个程序从编译到链接到转换格式所需要在terminal中输入的命令集中到一个文件中。Makefile的具体语法请自行搜索或看书上的简单介绍。

## 第五章 逻辑、位移操作与空指令的实现

**本章关键词：数据相关、数据前推**

#### 数据相关问题

数据相关问题包括：RAW(Read After Write)、WAR(Write After Read)、WAW(Write After Write)。

由于本书的CPU分为五级流水线，在译码阶段读寄存器，在回写阶段才会写寄存器，因此不存在WAW相关和WAR相关。

解决RAW的方法有：

- 插入暂停周期
- 编译器调度，即编译器可以检测到相关性问题并且调准执行执行的顺序。
- 数据前推，即将执行阶段得到的结果直接发送到译码阶段，而不需要等到回写阶段。

本书OpenMIPS采用数据前推的方法解决RAW（Read After Write）的问题，这是因为本章的逻辑、位移指令所要**写入寄存器的结果在执行阶段就能得到**（这是使用数据前推的前提，第九章的load相关就不行了）。具体的实现就是在id阶段增加两个**数据选择器（MUX）**，根据执行阶段和访存阶段反馈回来的值和信号具体确定是哪两个数据输出到ex阶段。

译码阶段输出的Aluop和Alusel是为了方便执行阶段执行操作的判断。

无论是寄存器位移版本（sllv、srav、srlv）还是立即数位移版本（sll、sra、srl），最终都是通过reg1_o和reg2_o输出两个操作数给id_ex.v至ex.v。

对任意一条指令而言，译码阶段工作的主要内容是：确**定要读取的寄存器的情况、要执行的运算和要写入的目的寄存器**三方面的信息。



## 第六章 移动指令的实现

**本章关键词：特殊寄存器、数据相关**

本章实现的移动指令是让数据在CPU内部的寄存器之间相互移动的指令，与后面的加载/存储指令不一样。

本章要实现的移动操作指令需要先新增**HI、LO两个特殊寄存器**，独立于regfile，位于回写阶段。

由于本章实现的移动操作指令造成的**数据相关的问题**包括普通寄存器regfile和特殊寄存器HI、LO的，前者已经在第五章解决了，因此我们在这里只需增加解决HI、LO两个寄存器的数据相关问题。这里我们的设计是：**译码阶段并不直接读取HI、LO的数值，而是在执行阶段才读取**，所以**新增的MUX放在执行阶段**，数据进入ALU之前。在哪个阶段加MUX，就要在修改哪个阶段的代码（虽然听着是个废话），数据通路是通过修改顶层文件openmips来实现的，顶层文件的本质就是按照数据流图连线。





## 第七章 算术操作指令的实现

**本章关键词：流水线暂停、试商法、有限状态机**



本章所要实现的算术操作指令可以分为三类：

1. 简单算术操作指令

   包括加法、减法、比较、乘法等指令（不包括除法），该类指令与前面所实现的思路差不多。这些指令在流水线的执行阶段都只需要一个时钟周期。

2. 乘累加、乘累减

   正如其名，该类指令包括乘和加/减两种操作，因此执行阶段需要更长的时间来运行，如果我们将这两个操作都放在一个时钟周期中，那么一个时钟周期的时间就要增加，那么整个CPU的频率就会下降，从而导致流水线的其他阶段的执行速度也减慢了。

3. 除法指令

   包括有符号除法（div）和无符号除法（divu），OpenMIPS采用的是试商法完成除法运算，对于32位的除法，流水线执行阶段至少需要32个时钟周期。



### 第一类指令的实现

基本与前面章节的思路一致，没什么大问题。



> PS：这里遇到的一个小问题就是括号的位置了。。。详见ex.v中248行。注意&&比||的优先级要高，因此括号的位置会影响结果。同时摸索了仿真调试的技巧，遇到问题，首先定位是哪里、哪个模块出了问题。
>
> 首先，可以在仿真器里显示各个可疑模块的输入和输出（本次我只测试了id.v和ex.v模块）。看有没有异常的信号，如果有，那么就可以判断错误的代码在对应的模块了。
>
> 然后，在该模块中找到会影响异常输出值的所有代码，显示中间值的信号图，依次排除。 
>
> > PPS：要注意的是，我们一般发现出错的地方是寄存器的值，由于我们采用了五级流水线的结构，实际出错的地方会出现在寄存器值错误的前几个周期，如果看的是执行阶段，那么就是提前3个时钟周期，因为到达回写阶段后，写入regfile还会增加一个时钟周期。





### 7.5 流水线暂停机制的设计与实现

因为本章要实现的后面几种指令在执行阶段需要多个时钟周期，当这些指令执行的时候其后面的指令不能进入执行阶段，需要暂停，所以我们需要暂停流水线。

为了实现暂停，我们新增一个**CTRL模块**，用于接收暂停请求信号和发送暂停信号。由于只可能在译码和执行阶段需要多个周期，所以只有译码和执行两个阶段可以发送暂停请求。当一个阶段请求暂停时，这个阶段之前的流水线都得暂停，之后的可以继续执行。另外，译码和执行这两个阶段不需要接受暂停信号，且接受暂停的都是各个模块之间的过度模块和pc_reg.v（因为他们才受时钟周期的控制）。同时，为了保存MADD、MSUB、MADDU、MSUBU指令执行阶段的第一个时钟周期的中间结果，还要在ex.v和ex_mem.v上增加两个输入和输出端口，分别用于保存乘法结果和指示第几个时钟周期。





### 7.11 除法指令实现思路

由于实现除法的算法比较复杂，所以我们这里新增一个div.v模块专门用来做除法运算。OpenMIPS采用的是**试商法**，也就是我们小学学除法的时候用的**短除法**。由于OpenMIPS的寄存器是32位的，要从最高位开始试，所以最少要**32个时钟周期**。div模块具体的实现是一个**有限状态机**，它有四种状态：DivFree、DivByZero、DivOn、DivEnd。

ex.v模块中添加控制div.v模块的部分，包括除法所需要的数据和是否开始的标志，同时ex.v也要接收div.v的输出。

其他地方都与之前实现过的指令类似，就不多说了。

要说明的一点是，顶层文件的div.v模块实例化中的annul_i信号目前没有变化，始终为1’b0，因为现在没有要取消除法指令的状况。在之后的异常处理中会有。



## 第八章 转移指令的实现

**本章关键词：控制相关、延迟槽、转移判断**



由于采用了流水线结构，转移指令会导致**控制相关**问题，控制相关是指流水线中的分支指令或其他需要改写PC值的指令造成的相关。由于改写了PC值，会导致在流水线中的后面几条指令无效（本处理器是两条），需要重新取指。

为了减少时钟周期的浪费，我们可以采用**延迟槽**机制，规定转移指令后面的指令位置为“延迟槽”，延迟槽中的指令被称为延迟指令，延迟指令总是被执行（本质是因为在转移指令在译码的时候，由于流水线的原因，下一条指令已经被取出来了），与转移发生与否没有关系，于是就节省了一个时钟周期。剩余的一个时钟周期通过在**译码阶段**进行**转移判断**来节省，如果位于译码阶段的是转移指令，且满足转移条件，那么**译码阶段直接将转移的目的地址传送给PC模块**，这样就不会读取转移指令后面的第二条指令了。这里PC模块新增了一种取值的可能性，在本章之前，有两种可能：1. 正常+4，2. 由于流水线暂停而保持不变。本章新增了 第3种，转移的目的地址。因此要在PC模块的MUX中新增一种可能，这种可能的前提是流水线没有暂停。

本章的ex.v暂时没有用到`is_in_delayslot_i`这个信号，这会在异常处理中用到。



> 延迟槽后面的指令为什么一定执行却没有逻辑错误呢？
>
> 因为一个高级语言的程序经过编译器编译成汇编语言后（或者是汇编语言编译成机器语言），编译器会重新排列语句的顺序来优化执行效率。在这里编译器将一个肯定会执行的语句放在转移指令的后面，就能节省掉一个时钟周期。（这也是为什么我们在编写汇编测试程序的时候要加上一句`.set noreorder`，这是为了不让编译器对程序进行优化和改动）在这里膜拜一下写编译器的大大们！





## 第九章 加载存储指令的实现

**本章关键词：地址对齐与非对齐、load相关问题、信号量机制、数据相关**



由于本书所搭建的“计算机”采用的是哈佛结构，即程序存储器与数据存储器是分开的，本章实现的数据加载/存储指令是指**CPU内通用寄存器与数据存储器之间的数据交互**，也就是属于流水线中访存阶段的操作了。

MIPS32指令集架构中定义的加载存储指令共有14条：

- 8条加载指令：lb、lbu、lh、lhu、ll、lw、lwl、lwr
- 6条存储指令：sb、sc、sh、sw、swl、swr

指令格式以lb为例：`lb rt,offset(base)`，其中rt是加载的目的寄存器，base是基址寄存器，offset是偏移量。其他指令类似。

这些指令中，l（第一个l）代表load，b代表byte，h代表half-word，w代表word，其中ll、sc比较特别，lwl、lwr、swl、swr的工作方式有些难理解，这4条指令是**非对齐**加载/存储指令，其他的涉及到多字节加载/存储的指令都有**地址对齐**的要求。

> OpenMIPS处理器是按照字节寻址的，并且是**大端模式**，即高有效位数据保存在低地址。

### lwl、lwr、swl、swr指令

lwl、lwr分别是向左加载、向右加载的意思。

lwl具体的作用：将该指令指定的 加载地址（可以是非对齐的）所在的 对齐的字 的最高地址（也就是最低有效位，图中画出的是最右端），向左数到该指令所直接指定的地址，将这一段所包括的字节数据，加载到目的寄存器的高有效位，即按照大端模式从高到低排列。

<img src=".\pic\chapter9_1.png" alt="image-20200206144250790" style="zoom: 33%;" />

具体看本书上的这个例子，我们算出来指令中指定的加载地址是5，也就是非对齐的地址，它所在的是第二个对齐的字（地址范围是4-7），从这个子的最高地址7向左开始数，直到遇到指定的加载地址5，这一段包括了5、6、7三个字节的地址，然后我们将这三个字节的数据按照原来的大端顺序放入目的寄存器\$1的高位，即低三个字节（如果是两个字节数据则只按序放入低两个字节）。

lwr的方式是从指令指定的 加载地址 所在的 对齐的字 的最低地址（也就是最高有效位，图中画出的是最左端）开始，从左向右数到指定的加载地址，然后按序加载到指定寄存器的低有效位，按图中所画的就是靠右边了。

与非对齐加载对应的就是非对齐存储了，有两条指令swl、swr。具体工作方式的基本上就是将上述的加载过程反过来（具体请看书上的例子自行体会）。

这4个非对齐的加载/存储指令的目的就是为了简便地向非对齐地址加载/存储字。如果使用其他常规的对齐指令，那么还需要位移指令、逻辑或指令的辅助，都需要5条指令来完成，而使用这4个非对齐指令只需要2条指令就能完成。



### 修改id.v

这里我们只需要增加对应新增的加载存储指令的情况就行了，只需输出该指令的寄存器读写情况（与之前的一般指令一致）。不过值得注意的是，对于lwl、lwr指令来说，除了需要获取基址寄存器的值，还需要获取写入的目的寄存器的值，因为这两条指令是写入部分的值，而不是整个字的值，因此需要原寄存器的值与写入值组合得到整个字的值。

同时，id模块新增了一个inst_o输出端口，用于传递指令到ex模块来计算访存阶段最终访问的地址。

### 修改id_ex.v与ex.v

id_ex.v新增inst_i与inst_o用于连接过渡。

ex中接收inst_i，新增aluop_o、mem_addr_o、reg2_o输出，并传递到mem.v。其中mem_addr_o是加载存储指令要访问的地址。reg2_o是存储指令要存储的值或者是lwl、lwr指令要加载到的目的寄存器的原始值。

### 修改mem.v

本章重点修改的地方就是mem.v和data_ram.v了。mem.v与data_ram.v（数据存储器）相连接，用于访问（读/写）数据存储器。mem.v新增加载存储指令对应的情况。本章的加载存储指令都是在访存阶段“执行”（读写data_ram）的。

mem.v新增的用于控制data_ram的输出包括mem_data_o、mem_addr_o、mem_we_o、mem_sel_o、mem_ce_o。依次是：要写入的数据、要写入的地址、是否要写入、字节选择信号、存储器使能信号。

另外，由于**data_ram的读写总是针对一个对齐后的字**（可以看作**不考虑mem_addr_o的最低两位的值**），所以我们在mem阶段就要通过mem_addr_i的值来设置mem_sel_o的值。

### data_ram.v

这里的data_ram模块是由4个单字节的存储器组成一个32位的存储器的。且读数据和写数据输入的地址都会被转换成该地址所在的 字的首地址（通过除以4来实现，具体是取addr的[`DataMemNumLog2:2]部分）。这样是参考了Wishbone总线的相关规范，使得在后期添加Wishbone总线的时候容易一些。

<img src=".\pic\chapter9_2.JPG" alt="chapter9_2" style="zoom: 20%;" />

> 与通用寄存器regfile一样，读取数据的部分是组合电路，写入数据的部分是时序电路。



### 9.5 测试程序

这里的测试程序有一点坑，那就是**load相关问题**。在测试程序第三阶段的后半部分，有连续的3个加载指令（lw、lwl、lwr），如果运行会导致结果与预期的不一样。这是因为load相关问题，有前面所讲的可知，加载存储指令是在mem阶段读取到该写入到通用寄存器中的值，而lwl、lwr读取目的寄存器的值是在译码阶段，因此如果有指令就会导致结果与预期不同（其他load指令也会读取基址寄存器的值，如果前一条也是加载指令并且影响想了它的值，那么也会造成错误）。

有一些写坑的是作者在这之前并没有提到过这个问题……直到9.10小节才提出，并且是用beq紧接lw指令来做例子的……（可能是作者疏忽了吧）。本菜鸡在这里折腾了几个小时，用ModelSim看信号找bug找到怀疑人生，还以为是哪里抄错了代码……。

由于这个相关问题是在mem阶段才读取到新的要加载的值，但是在id阶段已经读取了原始值，当前一条指令处于mem阶段时，后一条指令已经处于执行阶段了，所以数据前推的方法也不能解决。因此我们需要**在id模块新增一个判断当前指令与前一条指令是否存在load相关的部分**，如果存在相关，则暂停一个时钟周期，延长译码阶段，然后再将访存阶段的最新数据前推到译码阶段。具体实现请查看本书Chapter9_1中id.v模块新增的判断代码以及本书9.10小节。



### 9.6 链接加载指令ll、条件存储指令sc说明

ll、sc是MIPS32指令集中用来实现**信号量机制**的加载存储指令。

什么是信号量呢？

在**多线程系统**中，需要RMW（Read-Modify-Write）操作序列保证对某个资源的独占性，RMW操作序列的含义是，读取内存某个地址的数据，读取的数据经过修改，然后再保存回内存原地址，这个过程不能有任何干扰。因此需要建立一个临界区域（Critical Region），临界区域中完成的操作通常称为**原子操作**（类比原子不可分割，在化学反应中。。。），原子操作不被打扰。操作系统建立临界区域的方式通常是信号量机制，如下：

```
wait(semaphore);
//原子操作
//...
signal(semaphore);
```

其中，semaphore就是一个信号量，为1表示信号量使用中，为0表示信号量空闲。进行原子操作前，使用wait函数查询semaphore的值，如果为1，则等待，否则，将其置为1并开始执行原子操作。操作结束后，signal函数将semaphore置为0，这样其他线程就可以执行原子操作了。

需要注意的是，wait函数执行的也是一个原子操作，是一种“先检测后设置”操作（test-and-set operation），这种操作一般不希望被外部设备中断，也不希望被其他线程打断，很多处理器都有专门的指令用来实现“先检测后设置”操作。

MIPS32架构采用特殊的方式实现信号量机制，对原子操作，MIPS32架构并不保证它一定是原子性的（也就是不保证一定不会被打扰），也就是允许检测和设置在没有原子性保证的情况下运行，但只在它确实是原子的且运行了的时候才让“设置”生效。MIPS32架构采用链接加载指令ll、条件来实现这种信号量机制。

> 本小节以上内容摘抄自《自己动手写CPU》

ll指令的操作是加载一个字，同时设置处理器内部的一个链接状态位*LLbit*为1。一般在程序中，ll指令执行完毕后会进行一定的操作（如：修改加载得到的数据），然后执行sc指令，sc的功能是判断*LLbit*的值是否为1，如果为1就执行存储操作，并且设置rt为1，表示成功；如果为0，那么不修改内存，同时设置rt为0，表示失败。

为什么*LLbit*的值会变呢？这是因为在包括ll和sc指令的RMW中，若受到了干扰，CPU就会设置*LLbit*为0，这种干扰有两种情况：

1. 在ll、sc指令之间产生异常，从而进行异常处理例程，或者发生线程切换，导致RMW序列受干扰
2. 在多处理器的系统中，另一个CPU改写了RMW要操作的内存空间

对于本OpenMIPS CPU而言，只存在第一种情况。

我们可以利用ll与sc来编写一个之前介绍的wait函数，具体请见书P269。

小结一下一对ll与sc的功能就是判断一段RMW序列是否被打扰（我的理解。。。欢迎打脸）。

### 9.7 ll、sc的实现思路

很明显，我们需要在回写阶段增加一个LLbit寄存器，同时由于sc指令要在访存阶段读取LLbit的值来判断是否执行存储的操作，这里又出现了一个数据相关的问题，不过这次我们可以通过数据前推来解决。即，将mem_wb.v的连接LLbit的输出接入到mem.v中。其余部分属于正常操作。



### 9.10 load相关问题

这个问题在本笔记9.5节中讲解过。







## 第十章 协处理器访问指令的实现

**本章关键词：协处理器、异常控制、中断控制**

### 协处理器简介

本章实现的是MIPS32的一个协处理器CP0，用于**系统控制**。

协处理器，顾名思义，就是协助CPU做某些事情的处理器，它们有着自己的独立寄存器。

MIPS32架构定义了4个协处理器，从CP0到CP3。CP1和CP3是专门用来做浮点运算的，CP2被保留用于特定实现。这三个都是可选的，CP0是必须的。

CP0的具体功能包括：

- 配置CPU工作状态。例如：切换MSB和LSB
- 高速缓存控制
- 异常控制
- 存储管理单元控制
- 其他。例如：时钟、时间计数器、奇偶校验错误检测

由于本书实现的是一个简单的OpenMIPS处理器，所以我们主要实现的是异常控制以及中断控制。我们需要实现的有7个寄存器：

| 寄存器助记符/名称         | 功能描述                                                     |
| ------------------------- | ------------------------------------------------------------ |
| Count（可读写）           | 处理器计数周期                                               |
| Compare（可读写）         | 定时中断控制                                                 |
| Status（可读写）          | 处理器状态和**控制寄存器**，包括决定CPU特权等级，使能哪些**中断**等字段 |
| Cause（部分可写，均可读） | 保存上一次异常原因                                           |
| EPC（可读写）             | 保存上一次异常时的程序计数器                                 |
| PRId（只读）              | 处理器标志和版本                                             |
| Config（只读）            | 配置处理器，用来设置CPU的参数                                |

详见书本or百度（原谅我的懒。。。）

### 10.4 协处理器访问指令

MIPS32架构的CPU访问协处理器CP0中的寄存器只通过两个指令就行了：1. MTC0（写） 2. MFC0（读）。命名类似于MTHI、MFHI、MTLO、MTLO指令。功能也相当，这两个指令本质上也是移动指令。

格式：`mtc0 rt,rd`和`mfc0 rt,rd`。



### 10.5 协处理器访问指令实现思路

实现思路与MFHI、MTHI这些指令差不多。同时，也要在回写阶段新增一个CP0模块（本质上相当于是一个寄存器模块，类似HI和LO）。

这里也会出现数据相关的问题，但是我们是在执行阶段决定要写入CP0的值，所以可以采用数据前推的方法来解决，这里就不多说了。



> 本章的OpenMIPS CPU新增了int_i和timer_int_o两个接口，但是还没用到，具体在下一章异常处理会用到。CP0的各个寄存器的直接输出端口暂时也没有用到。





## 第十一章 异常相关指令的实现

**本章关键词：异常处理、精确异常、延迟槽指令判断、处理器工作模式**

### 11.1 MIPS32架构种定义的异常类型

MIPS32定义了许多异常，并将其分为24个优先级（详情请自行看书or搜索）。

本书的OpenMIPS处理器支队其中的6种异常情况进行处理，分别是：

- 硬件复位
- 中断（包含软中断、硬中断）
- syscall系统调用指令
- 无效指令
- 溢出
- 自陷指令

异常的处理方法就与汇编/单片机中所学的中断处理差不多，即异常发生后，CPU会根据异常情况，转到对应的异常处理程序去（如果是中断，则需要考虑是否被屏蔽），处理结束后再返回到异常发生前的状态继续执行。

这6种异常中，硬件复位算是一种比较特殊的异常，它不需要记录返回点的状态（即保护现场），OpenMIPS的硬件复位就是将所有寄存器清零，从地址0x0处开始取指执行。



### 11.2 精确异常

精确异常这个词简单来说就是：发生异常时，CPU要精确地定位到按指令执行的逻辑顺序的第一个发生异常的指令的位置，而不是单纯地按照流水线中各个阶段所报告异常的早晚。也就是说，我们在考虑异常发生的早晚时，是以一整条指令为单位来查找到底是哪一个指令先发生了异常，而不是看流水线中的各个阶段。下面以书上的一个例子来说明：

<img src=".\pic\chapter11_1.JPG" alt="chapter11_1" style="zoom: 20%;" />

这个例子中，第2条指令的异常在译码阶段就发生，而第1条指令的异常在访存阶段才发生，从时间上来说，是第2条指令先触发异常，但是从整条指令的逻辑顺序来看，是第1条指令首先发生异常，所以在设置异常返回地址（即处理完异常后返回的地址）的时候应设置为第1条指令所在的地址。也可以说，为了实现精确异常，要求异常发生的顺序与指令的顺序相同。

对于一个实现精确异常的处理器来说，当一条指令发生异常时，在这条指令之前的所有指令都必须正常地执行完成，但是该指令及其后面的所有在流水线中的指令都需要暂时取消执行，待处理完异常之后返回到该指令处重新开始执行。

为了解决上面这个例子的问题，在大多数CPU中通常是设计一个特殊的流水线阶段，专门用于处理异常。在该阶段之前发生的异常，我们仅仅做标记，表示该指令发生了异常，而不立即做出异常处理的请求。直到该指令执行到了流水线中专门处理异常的阶段，才开始真正处理异常，这样就保证了“按指令执行的顺序处理异常，而不是按异常发生的顺序处理异常”。

**在本书实现的时候，我们将该异常处理阶段整合到了访存阶段，即在访存阶段检查该指令是否发生了异常并处理。**



### 11.3 异常处理过程

书上的一张图即可解释：

<img src=".\pic\chapter11_2.JPG" alt="chapter11_2" style="zoom:20%;" />

其中EXL是是否处于异常级的标志，为1表示正在处理异常，为0则正常。

其中EPC保存的是发生异常时的PC值，即异常 返回地址。可以看到，如果发生异常的指令位于延迟槽中，则EPC保存的是该指令的前一条指令的PC值。**这是为什么呢**？

这是因为，引入延迟槽后，处理器执行转移指令的顺序是：转移指令—>延迟槽指令—>转移目标地址的指令。

如果EPC保存的是延迟槽指令的地址，那么在处理完异常后返回，之后的指令执行顺序就是：延迟槽指令—>延迟操指令的下一条指令。这样可能会造成逻辑错误。

所以我们要重新执行一遍转移指令来判断是否需要转移。

其中的异常处理例程入口地址就是我们在汇编语言/单片机中所学的中断向量。



### 11.4 异常相关指令介绍

MIPS32指令集架构中定义的异常相关指令包括：自陷指令、系统调用指令syscall、异常返回指令eret。

#### 自陷指令

MIPS32的自陷指令包括两种，包含立即数的和不包含立即数的。其功能就是**判断操作数是否满足条件，若满足则引发自陷异常**。可以用在判断是否该抛出异常的情况。

具体指令请看书or自行搜索。

#### 系统调用指令syscall

其指令格式就是`syscall`。没有任何参数。

MIPS32架构定义了处理器的两种工作模式：**用户模式、内核模式**。前一种是受限模式，有一些操作不能进行，大多用于用户的应用程序。后者主要用于异常处理和具有优先权的操作系统函数，包括管理协处理器CP0和I/O等。用户模式下的程序为了执行一些在内核模式才能进行的操作，可以调用syscall指令，引发系统调用异常，进入异常处理例程，从而进入内核模式。用户模式、内核模式的状态标记是CP0中Status寄存器的UM字段。

不过本书实现的的OpenMIPS处理器不区分用户模式、内核模式，所以没有用到Status中的UM字段。

但是为了兼容MIPS32指令集架构，还是实现了syscall指令。

#### 异常返回指令eret

用法：`eret`。

功能：使PC值变成EPC所储存的值，同时设置Status的EXL字段为0，表示不再处于异常级。



### 11.5 异常处理实现思路

在11.2的最后一句，我们说明了本书实现的大体方法。即在译码和执行阶段检查是否是各个阶段所可能发生的异常，在访存阶段检查是否发生了异常，并请求异常处理。

请求异常处理的其实就是修改PC值为异常处理例程的入口地址。所以我们要在PC的MUX中新增一路信号，该校信号来自访存阶段的异常判断部分。该部分会查询CP0中相关寄存器的值（例如Status），来判断是否要进行异常处理。如果要进行异常处理，则需要清除掉除了回写阶段的其他所有流水线阶段的信息，即为了保证“精确异常”，同时修改CP0中相关寄存器的值。如果是eret指令，除了设置PC值为EPC的值，也需要清除除回写阶段外的全部信息，修改CP0相关寄存器的值。

清除流水线我们是通过CTRL模块来实现的，即flush信号，其连接的是各个时序电路，即各个阶段之间的连接模块，还包括pc_reg模块和LLbit寄存器（因为异常也表示ll、sc中间的指令受到了干扰）。

> 流水线各个阶段需要收集的异常信息如下：
>
> - 译码阶段：判断是否是系统调用异常、是否是返回指令、无效指令
> - 执行阶段：是否有自陷异常、溢出异常
> - 访存阶段：检查是否有中断发生









## 第十二章 实践版OpenMIPS处理器设计与实现

**本章关键词：总线结构、控制器、Wishbone总线、总线接口**

### 总线

前面11章，我们实现了教学版的OpenMIPS处理器，其SOPC结构如下：

<img src="E:\Documents\Study_Notes\自己动手写CPU\pic\教学版OpenMIPS的最小SOPC结构.jpg" alt="教学版OpenMIPS的最小SOPC结构" style="zoom: 33%;" />

其ROM和RAM都位于FPGA内部，但是在实际的应用中，由于ROM和RAM的需求都比较大，以至于不可能集成在FPGA中了（实际的ROM使用的是Flash，RAM是SDRAM），于是我们需要向OpenMIPS添加对应外部设备的控制器，例如：Flash控制器和SDRAM控制器。

<img src="E:\Documents\Study_Notes\自己动手写CPU\pic\实用化OpenMIPS的最小SOPC结构.jpg" alt="实用化OpenMIPS的最小SOPC结构" style="zoom:33%;" />

很容易发现，我们每次为OpenMIPS添加外部设备，都需要在OpenMIPS内部添加相应的**控制器**，这很麻烦，不符合人类“懒”的天性，于是懒懒的人类便想出了总线这一方案。熟悉PC的人知道，主板上面有PCI（Peripheral Component Interconnect），其就是PCI总线的接口，中文名为外部控制器接口，许多设备即插即用（内存，网卡等）。借鉴这种结构，本章也要为我们的OpenMIPS加上总线结构，加上总线后，我们只需在OpenMIPS上添加两个（哈佛结构的原因）与总线相连的接口即可“一劳永逸”，两个接口分别为：**指令总线接口、数据总线接口**。添加外部设备时，当然还是需要控制器啦，但是这次我们可以使用已有的开源的IP核，为了方便连接，许多公司的IP核遵守相同的总线规范（总线规范定义了IP核之间的通用接口）。控制器的一端与总线相连，另一端与外设相连，即构成了通信通路，如下图。

<img src="E:\Documents\Study_Notes\自己动手写CPU\pic\使用总线的OpenMIPS的最小SOPC结构.jpg" alt="使用总线的OpenMIPS的最小SOPC结构" style="zoom:33%;" />

> IP核（Intellectual Property core）是一段具有特定电路功能的硬件描述语言程序，该程序与集成电路工艺无关，可以移植到不同的半导体工艺中去生产集成电路芯片。
>
> 关于IP核相关的科普blog：https://blog.csdn.net/Reborn_Lee/article/details/82756284



### Wishbon总线

总线规范也分为多种，分别由不同公司提出。本书采用的是Silicore公司提出的Wishbone，其是免费开源的。

Wishbone总线接口有多种连接方式：**点对点、数据流、共享总线、交叉互联**等。我们首先介绍点对点的方式，该方式包括一个主设备和一个从设备，它是最基本的方式，其接口与其他方式相同，示意图如下：

<img src="E:\Documents\Study_Notes\自己动手写CPU\pic\chapter12_1.JPG" alt="chapter12_1" style="zoom: 10%;" />



其中，以`_I`结尾的是输入信号，以`_O`结尾的是输出信号。

CLK、RST、WE（Write Enable）、ADR（Address）这些相信大家都很熟悉了，SEL是数据总线选择信号，用于选择32的字中的某些字节，与mem中的sel一样，DAT代表的是data，是数据总线。CYC是总线周期信号，其有效的时候代表一个主设备请求总线使用权或正在使用总线，但是不一定正在进行**总线操作**（也就是是否正在做实事，有可能是“占着茅坑不拉shi”）。是否在进行总线操作取决于STO信号（选通信号），只有选通信号有效时，ADR、DAT、SEL才有意义，同时只有在CYC信号有效的时候，其他信号（除CYC外的）所有信号才有意义。CYC有效时，表示进入了一个总线周期，**一个总线周期可能需要多个时钟周期**。ACK信号有效时表示操作的成功，属于操作结束信号，操作结束信号还包括ERR（错误）、RTY（重试），只不过这里我们只用到了ACK。TAGN是标签信号，用户可以利用标签信号传递自定义的信息。

总线操作有：单次读/写操作、块读/写操作等等。首先以CYC的有效标志一个总线周期的开始，继而由STO的有效标志一个总线操作的开始，CYC和STO也可以同时有效，表示总线周期开始的同时发起一次总线操作。



### 实践版OpenMIPS处理器接口

先出教学版和实践版的接口图：

<img src="E:\Documents\Study_Notes\自己动手写CPU\pic\chapter12_2.JPG" alt="chapter12_2" style="zoom:10%;" />

<img src="E:\Documents\Study_Notes\自己动手写CPU\pic\chapter12_3.JPG" alt="chapter12_3" style="zoom:10%;" />

从这两张图可以看出，我们将原本IF阶段、MEM阶段与ROM和RAM直接相连的输入输出都换成了wishbone的标准接口形式，其中iwishbone代表的是instruction wishbone，dwishbone代表的是data wishbone，分别是IF、MEM阶段的输出。

在OpenMIPS内部，实现思路是使PC模块和MEM模块分别与标准的Wishbone总线接口模块相连，再连接至外部总线，结构简图如下：

<img src="E:\Documents\Study_Notes\自己动手写CPU\pic\chapter12_4.JPG" alt="chapter12_4" style="zoom:10%;" />



具体实现如下：

<img src="E:\Documents\Study_Notes\自己动手写CPU\pic\chapter12_5.JPG" alt="chapter12_5" style="zoom:15%;" />

由于Wishbone总线接口都是有规范的，所以我们只需写好一个模块，然后实例化多个就行了。

由图可以看出，ctrl模块新增了if阶段和mem阶段的中断请求，这是由于添加了Wishbone总线接口后，取指和访存阶段所需要花的时间会多于一个时钟周期，在指令和MEM数据没有取到的时候，需要请求暂停流水线。

Wishbone总线接口的具体实现是一个有限状态机，同时包含给处理器接口赋值的组合电路，具体请看代码或书。

修改CTRL模块的时候，**需要注意的一点**就是，在取指阶段请求暂停时，除了要暂停PC和取指，也需要暂停译码阶段，这是因为考虑一种特殊情况：如果在请求暂停时，译码阶段的指令是一个转移指令，那么取指阶段将要取到的指令就是延迟槽指令，如果不暂停译码阶段，那么CPU的IF阶段就会插入一个NOP指令（详见if_id.v代码），导致译码阶段错误地将NOP指令识别为延迟槽指令，从而导致出错。







## 第十三章 基于实践版OpenMIPS的小型SOPC

由于一个SOPC上包括多个模块，同时可能不止一个主设备和从设备，因此点对点的总线就不适合了。允许多个主设备访问多个从设备的方式有共享总线和交叉互联。

- **共享总线**的意思是多个主设备与一个或多个从设备的通信通路共享，同一时间只能有一对主从设备进行通信，否则会冲突。当主设备需要访问从设备的时候，它会向**仲裁器**申请总线占有权，当被允许后才开始通信，通信结束后释放总线。（其中仲裁器的作用是当有多个主设备同时访问从设备的时候，决定哪个设备先占用总线）
- **交叉互联**，当一个主设备要访问一个从设备的时候，先向仲裁器申请，仲裁器查看该从设备是否处于空闲状态，如果是，则允许通信，否则需要等待，这个方式与共享总线不一样的是允许同一时间有多对主从设备进行通信（只要访问的不是相同的从设备就行）。

学过计算机网络的同学，可以将其类比为集线器（共享总线）和交换机（交叉互联）。

本章建立小型SOPC的方式是交叉互联的方式。

<img src="E:\Documents\Study_Notes\自己动手写CPU\pic\chapter13_1.JPG" alt="chapter13_1" style="zoom:15%;" />

其中实际的Wishbone总线采用的是开源的WB_CONMAX模块，这是一个Wishbone总线互联矩阵，采用的是交叉互联的方式，具体结构图如下：

<img src="E:\Documents\Study_Notes\自己动手写CPU\pic\chapter13_2.JPG" alt="chapter13_2" style="zoom:15%;" />

其中：

- UART，全称Universal Asynchronous Receiver/Transmitter，中文名通用异步收发器，它的作用是将并行的数据转换成串行发送，或者把接收到的串行数据转变为并行数据。
- GPIO，全称General Purpose Input/Output，是以位为单位进行数字输入输出的I/O接口。
- Flash分为NAND和NOR两种类型，前者以“块”为基本单位进行访问，后者以“字”为进本单位进行访问，因而程序可以直接在后者中运行，而不用复制到RAM中，因此本次采用的是NOR Flash。







## 全书（前12章）小结

本书的前11章是教学版的OpenMIPS CPU设计过程，后面的章节是实践版的设计和实物的实验。对于本书的名字《自己动手写CPU》来说，我认为前12章就已经完成了任务。后面部分的实验需要DE2开发板的支持，所以暂时做不了。

当初看这本书的目的是进一步了解计算机组成与体系结构，因为上学期上了一门《计算机组成与体系结构》的课，感觉学得很模糊，于是想着干脆通过自己写一个CPU来增强一下对计算机的理解。网上推荐的书有《自己动手写CPU》和《CPU自制入门》，比较了一下感觉前者更适合我，便开始着手看了。

看完这本书的首要感想是，原来**CPU并没有那么神秘！**

<!--more -->

在这里我想讲一下两方面的收获：

1. CPU的结构与设计
2. 计算机组成与体系结构

**首先说一说我之前对CPU的一些好奇和疑惑：**

以前的我只知道CPU是按照时钟的频率的工作的，但是不知道为什么要由时钟来控制，以及如何控制，同时也会想，既然是按照时钟来工作，那为什么不“无限制”提高频率以加快CPU的处理速度呢？

看完本书后，我知道了这些问题的答案。

首先，为什么要有时钟？是为了保证CPU内部的正常秩序，“到了什么时间就做什么事”，没有一个良好的秩序，一个团队的效率是不可能高的，甚至乱作一团，导致不能工作。

那么，时钟是如何控制（组织）CPU内部的工作的呢？时钟会产生一个周期信号，我们可以规定在信号的每一个上升沿or下降沿开始执行一个操作，CPU中的不同模块能同时进行操作，但CPU中的一个模块在同一个时刻只能做一件事，这样就能保证各个模块之间不冲突，各个功能正常执行。

那么是不是一直提高时钟的频率，就能一直无限制地提高CPU的执行速度呢？显然是不可能的，如果真是这样的话那么为啥CPU厂商自己不大幅提高时钟频率呢。第一个事实是由于CPU电路中的信号是有延迟的，一个操作的结果不可能立刻反映在输出电路上，如果无限制提高时钟频率，那么会导致“运算”跟不上时钟，从而导致CPU内部的秩序又消失了，变得混乱。第二就是由于电路中电子的运动是要消耗能量的，执行地越快，单位时间内消耗的能量就越多，发热量就越大，散热就会跟不上，从而导致内部电路“失效”，电脑蓝屏、死机or自动关机。

By the way，时钟频率并不是唯一决定处理器性能的东西，这也就是为什么AMD的主频一般没有同级别的Intel家的主频高，但是性能却不相上下甚至超过Intel的原因（AMD YES！）。



### CPU的结构及设计

CPU的本质就是一个只会“解释指令”，并且死板地执行指令的莫得感情的机器，有一个比喻说得好：硬件是计算机的躯体，OS才是灵魂。它的主要结构（或者说最基本的结构）包括译码器、ALU以及各种寄存器。

我们会给具体指令集中的指令规定固定的格式，以便让译码器理解代码，其实原理很简单，CPU译码的过程相当于就是查字典，在规定的有限的指令集内找到与输入的机器码相匹配的情况，并执行相应的操作。

ALU（Arithmetic Logic Unit）的中文名是算术逻辑单元，顾名思义，主要是执行算术/逻辑操作的单元，计算机的各种“计算”都是在这里完成的。

寄存器是用来保存运算的输入数据、中间结果and结果的存储单元，其位于CPU内部，访问速度最快（在计算机体系中）。但也有一些特殊的寄存器并不用于计算，比如PC（Program Counter）程序计数器，它的值是下一个将要取到的指令的地址。

前面说过CPU中的各个模块按照时钟来运行的，为了进一步提高效率，人们使用了流水线结构，类似于工厂众多的流水线，将一条指令（商品）的执行过程分为多个步骤（或阶段），每一个步骤由一个专门的模块来负责，这个模块的任务就是接收从上一个阶段传来数据，经过它自己的处理后，再传递给下一个模块。

本书的Open MIPS CPU采用的是**五级流水线**，将一条指令分为五个步骤：取指、译码、执行、访存（RAM）、回写（寄存器）。具体实现流水线的方式就是通过组合电路和时序电路的组合级联而，由组合电路完成具体的操作，由时序电路完成按照时钟传递数据的任务，以保证指令的有序执行。

同时，由于采用了流水线结构，也会相应地带来**相邻指令间**的相关问题（具体见笔记第五、八、九章），简单来说就是：假如一条指令的结果是在最后一个流水线阶段才写入的，此时流水线的前几个阶段已经在处理后面几条指令了，如果这几条指令需要的结果正好是该指令将要写入的（但是还没写入），那么就会产生相关问题。对应的解决方案在笔记中也介绍过，简单来说有：数据前推、暂停流水线、编译器调度（不属于CPU的能力范围）。其中数据前推就是在流水线中新增一些从流水线后面几个阶段到前面几个阶段的数据反馈回路，然流水线的前几个阶段提前获取前面指令的结果。暂停流水线是通过新增ctrl模块实现的。

在运行过程中，CPU难免会遇到一些出错的情况（例如：溢出，除数是0等），这就需要一个异常处理机制了。为了实现精确异常，采用的策略是在前面几个流水线阶段检测异常但不立即操作，在一个固定的流水线阶段统一请求异常处理。

至于协处理器，就是辅助CPU的处理器，其中包含一些特殊寄存器，辅助CPU的判断/异常处理，有的协处理器也能帮助CPU完成一部分计算工作（例如：浮点运算协处理器）。



### 计算机组成与体系结构

什么是计算机体系结构？那本黑皮书《计算机组成与体系结构（性能设计）》中定义为

> 计算机体系结构是程序员所看到的计算机的属性，即概念性结构与功能特性

对于不同层次的程序员来说，他们看到的计算机的属性也不相同。例如，对现在的许多高级语言程序员来说，他们看到的计算机的属性大多数是操作系统（OS）提供的，而对于OS程序员来说，他们看到的体系结构就是ISA（或许还有其他我目前不知道的…）提供的。

至于计算机组成，就是由五个经典的部分组成：输入、输出、存储器、数据通路（运算器）、控制器。后面两个部分组成CPU，通过本书的前11章，我们也实现了这两个部分。

首先，任何一个ISA都会提供给底层程序员几个类别的指令，本书实现的Open MIPS就包括了：逻辑指令、位移指令、（数据）移动指令（寄存器之间相互移动）、算术指令、转移指令、加载存储指令（寄存器与ram和rom之间移动）、协处理器访问指令、异常相关指令。ISA所提供的指令类别需要保证通过不同指令的组合就能完成任何程序的任何逻辑，现在同一个类（RISC或CISC）中的不同ISA的指令类别应该大同小异了。

具体的指令设计可是一个大学问，这需要考虑到指令有哪些格式，什么样功能的指令是必要的，什么是冗余的，如何设计执行过程的方法才能提升指令的执行效率。当然，这些都是那些专门设计指令集的大佬们干的事，本书实现的Open MIPS仅仅是把现有的开源指令集拿来实现（并且还是简化版的）。

不同的指令执行所需要的时间也不一定一样，在Open MIPS中，大部分指令执行阶段都只需要一个时钟周期，少部分需要两到三个，最花时间的是除法指令，它需要至少32个时钟周期，这是由除法本身的算法（试商法）决定的。

实现同一个功能可以由多种不同的指令组合完成，如何提高程序的执行效率，也就可以通过寻找所需最短时间的指令组合来实现，这个过程是由编译器（无论是高级语言编译器还是汇编器）实现的。实现这个我想并不容易，否则编译原理也就不会是CS系学生的噩梦了（顺便膜拜一波写编译器的大佬们）。**同时这也给我们编写高级语言程序的时候一些启示**：了解一些高级语言语句的汇编实现是有用的，因为这可以让我们判断哪一种实现方法更有效率（所需的时钟周期更少）/汇编语句更少（节省内存空间），这是让我们编写出更好的程序的一种技巧（个人观点）。**举个栗子**，调用函数操作的汇编语言实现一般都是跳转指令配合标签，同时会用到栈（将调用前的寄存器值压入栈），如果使用递归的话，就会多次调用函数，多次将寄存器的值压入栈，如果递归深度太深，那么栈就可能溢出，导致程序错误，同时相比非递归函数，这个压入栈的操作会被执行很多次，就浪费了时间，同时也浪费了空间。这也是为什么一般不轻易采用递归结构的原因，当然，对于现代的CPU/PC机来说，我们平时写的那些递归的深度及操作复杂度都不是太大的问题（因为执行速度够快而浪费的时间可以接受，因内存够大而导致栈空间的浪费可以接受，不过这个栈的大小是有限度的，因而也可能溢出，但也可以手动设置栈的大小）。

> 在《计算机组成与体系结构（性能设计）》中，还讲到过指令发射策略，本质上是一种改变指令执行顺序来提高执行效率的过程（前提是程序逻辑不变），不过这里我看地有些似懂非懂……也就不详细说了。

为了方便CPU与外部设备的交互，我们采用了总线的结构，具体原因在十二章的笔记中有说过，进一步总结就是，为了**减少**不同功能模块之间的**耦合**，因此通过一个中间模块（在这里就是总线）来使需要连接的模块的接口标准化，使模块之间的互联逻辑变得清晰，易于维护修改。



### 最后

总的来说，这本书所实现的CPU很简单，内容也不是很多（就是代码多了点），与当今时代个人PC机的CPU差别挺大的，有许多高级设计并没有使用到（这也是为了降低难度），例如：超标量流水线、指令发射、指令预测等等。对这些感兴趣的话可以看看上面提到的那本黑皮书，不过说实话。。。中文翻译得确实不是很流畅，有些地方不慢慢地多读多想不易理解（当然，这也与知识本身的难度有关）。

话说回来，看这本书的收获也挺多，可以算是入了CPU和计算机硬件的门，我想，如果是先看完本书之后再去看那本黑皮书或者《计算机组成与设计（硬件/软件接口）》（该书正好就是用MIPS指令集来做例子的）也是极好的，能帮助理解其中的许多概念（流水线、延迟槽、相关性问题、异常处理等等），也不会像我当初上课时那样摸不着头脑了。

PS：建议看本书之前最好有数电基础。



## 附录

### 关于verilog中always的并行性

一个module里面的不同always块只要满足条件就会执行。如果多个always块的敏感信号条件相同，那么就是并行的。

如果两个并行的always块中的信号是相关的，那么其执行时会取得其需要的值是前一刻的值，具体还是看一个例子吧。

https://blog.csdn.net/jiangbeicaizi000/article/details/52093945

同时，`always @(*)` 是**一种描述组合逻辑的方式**。它相当于把always块内的所有输入信号都添加到了敏感信号列表里，这里说的输入信号，就是always块内“位于赋值符号右边”的信号（个人认为，如有异议，欢迎提出讨论）。

可以参考：https://zhuanlan.zhihu.com/p/72078544

现在，我们再来看本书的流水线结构，其各个阶段内部的模块都是组合逻辑电路来完成的，连接各个阶段的模块都是时序逻辑电路。并且是串连起来的，因此是流水线模式。



**其他关于always的blog：**

https://blog.csdn.net/phenixyf/article/details/46364193