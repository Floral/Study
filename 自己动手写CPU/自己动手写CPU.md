# 自己动手写CPU

## 第一章

### 指令集架构ISA（Instruction Set Architecture）

ISA将编程所需了解的硬件信息从硬件系统中抽象出来。从软件人员的角度看，ISA包括一套指令集和一些寄存器。
简单地说，ISA就是提供给汇编程序员的最底层硬件的接口。

### 微架构（Microarchitecture）

微架构是ISA的一个具体实现。ISA好比设计规范，微架构则是具体实现。用编程里的概念类比，ISA就是接口（所能实现的各种功能），微架构就是实现功能的具体方式（采用的不同的算法），因此，同样的ISA，不同的微架构，会带来不同的性能。

- ISA主要分为CISC和RISC。
- CISC目前主流只有x86
- RISC主流包括ARM、SPARC、POWER、MIPS



其他博主的blog：

https://blog.csdn.net/qq_42914528/article/details/81779727



## 第四章

首先要做的就是搭建一个流水线结构。所谓流水线，在电路上的结构就是组合逻辑和时序逻辑电路级联，并没有想象中的那么复杂（还有一种结构是寄存器的输入端和输出端存在回路，被称为状态机）。

本书的CPU采取五级流水线结构，分别为：取指、译码、执行、访存、回写。

其中，译码阶段所要做的除了把机器码解释为不同的指令，还要承担取得操作数的工作，即从regs中（或指令中的立即数）取得执行阶段所需要的两个操作数（无论是否有一个操作数为立即数，都会把两个操作数分别转化为为reg1_o、reg2_o）。

不同阶段模块中通过中间模块连接（例如：if_id.v、id_ex.v等），这些模块所做的事几乎都是把输入数据按原样传递给下一个阶段，为什么要有这些模块呢？主要原因是将各个阶段的模块分离，并且严格按照时钟传送数据。

可以看到，流水线的各个阶段的敏感信号都是`*`（除了pc_reg取指令模块），即所有输入信号。而中间的过度模块中always的敏感信号都是`posedge clk`，即时钟的上升沿。这就保证了五级流水线中各个阶段的数据每个时钟周期就流向下一阶段，即“流水线”工作方式。

> 读取reg的电路是组合电路，即输入一有变化就立即反馈，这也保证了译码阶段及时取得操作数。

### 4.4 MIPS编译环境

本章简单的介绍了MIPS汇编程序编译链接的过程。

首先，由于我们写的是MIPS架构的CPU，用到的编译器也是MIPS的汇编器、链接器等。这些编译工具也都是在MIPS架构的CPU和系统环境下运行的。因此我们首先就是要取得这个环境。

直接在我们自己的PC机上装的Ubuntu/Linux或者Win10中的WSL都是不能运行该编译环境的（会报类似“二进制文件格式错误”的错，因为这个编译工具本身就是在MIPS架构下编译得到的，它的二进制机器。语言我们的PC机“看不懂”），因为现在的个人PC机基本上都是X86架构的CPU了（如果你用的是龙芯，请忽视这句话），系统也是分CPU架构的，大部分的Linux目前也是基于X86的，也可以去各个发行版的官网上找其他架构的版本。于是我们首先需要一个基于MIPS开发的Linux系统，本书采用的是OpenRISC版本的Ubuntu，目前书上给出的网站已经访问不了，官网上也下不了这个版本的Ubuntu，但是万能的网友当然会有“存货”的啦，直接搜`OpenRISC_Ubuntu_2011-12-15.vdi.bz2`这个关键词，应该是能搜到的（本人通过404网站搜的，度娘没有试过），或者直接去各种搜百度网盘资源的网站搜就行。然后下载virtual box虚拟机安装，具体步骤书上有，百度也行。

然后就是下载MIPS编译工具链了，这个可以在某Hub上搜到（CSDN的要积分）。下载完成后通过共享文件夹在虚拟机中可以运行了。

编译的过程如下：

1. 写MIPS的汇编程序
2. 使用`mips-sde-elf-as`指令将汇编程序编译成目标文件（Object），为链接做准备。这里的`.o`格式文件是ELF（Executable and Linkable Format），ELF文件有三种类型，这一步得到的是一个Relocatable类型的，其中包含着描述text段、data段、bss段等的描述信息，例如：段起始地址、长度等。
3. 编写链接描述文件，链接描述脚本描述了输入文件的各个Section如何映射到输出文件的各个Section中，并控制输出文件中Section和符号的内存布局。
4. 使用`mips-sde-elf-ld`指令将`.o`文件和链接描述脚本一起链接得到可执行文件`.om`（也属于ELF文件）。
5. 上一步得到的`.om`文件是一个ELF的可执行文件，其格式与我们需要加载到rom中的格式有很大不同，因此还需要使用 `mips-sde-elf-objcopy`将`.om`文件转化为二进制文件`.bin`。然后通过一个小程序进一步转换成我们需要的`.data`文件。

总结一下就是：编译、链接、转换格式。这里我们使用了好几个命令，这时为了可以重复使用，我们可以编写一个**Makefile**。来一次完成所有的工作。所以Makefile的本质就是把一个程序从编译到链接到转换格式所需要在terminal中输入的命令集中到一个文件中。Makefile的具体语法请自行搜索或看书上的简单介绍。

## 第五章

#### 数据相关问题

数据相关问题包括：RAW(Read After Write)、WAR(Write After Read)、WAW(Write After Write)。

由于本书的CPU分为五级流水线，在译码阶段读寄存器，在回写阶段才会写寄存器，因此不存在WAW相关和WAR相关。

解决RAW的方法有：

- 插入暂停周期
- 编译器调度，即编译器可以检测到相关性问题并且调准执行执行的顺序。
- 数据前推，即将执行阶段得到的结果直接发送到译码阶段，而不需要等到回写阶段。

本书OpenMIPS采用数据前推的方法解决RAW（Read After Write）的问题。具体的实现就是在id阶段增加两个**数据选择器（MUX）**，根据执行阶段和访存阶段反馈回来的值和信号具体确定是哪两个数据输出到ex阶段。

译码阶段输出的Aluop和Alusel是为了方便执行阶段执行操作的判断。

无论是寄存器位移版本（sllv、srav、srlv）还是立即数位移版本（sll、sra、srl），最终都是通过reg1_o和reg2_o输出两个操作数给id_ex.v至ex.v。

对任意一条指令而言，译码工作的主要内容是：确**定要读取的寄存器的情况、要执行的运算和要写入的目的寄存器**三方面的信息。



## 第六章

本章要实现的移动操作指令需要先新增HI、LO两个特殊寄存器，独立于regfile，位于回写阶段。

由于本章实现的移动操作指令造成的数据相关的问题包括普通寄存器regfile和特殊寄存器HI、LO的，前者已经在第五章解决了，因此我们在这里只需增加解决HI、LO两个寄存器的数据相关问题。这里我们的设计是：译码阶段并不直接读取HI、LO的数值，而是在执行阶段才读取，所以新增的MUX放在执行阶段，数据进入ALU之前。在哪个阶段加MUX，就要在修改哪个阶段的代码（虽然听着是个废话），数据通路是通过修改顶层文件openmips来实现的，顶层文件的本质就是按照数据流图连线。





## 第七章 算术操作指令的实现

本章所要实现的算术操作指令可以分为三类：

1. 简单算术操作指令

   包括加法、减法、比较、乘法等指令（不包括除法），该类指令与前面所实现的思路差不多。这些指令在流水线的执行阶段都只需要一个时钟周期。

2. 乘累加、乘累减

   正如其名，该类指令包括乘和加/减两种操作，因此执行阶段需要更长的时间来运行，如果我们将这两个操作都放在一个时钟周期中，那么一个时钟周期的时间就要增加，那么整个CPU的频率就会下降，从而导致流水线的其他阶段的执行速度也减慢了。

3. 除法指令

   包括有符号除法（div）和无符号除法（divu），OpenMIPS采用的是试商法完成除法运算，对于32位的除法，流水线执行阶段至少需要32个时钟周期。





### 第一类指令的实现

基本与前面章节的思路一致，没什么大问题。



> PS：这里遇到的一个小问题就是括号的位置了。。。详见ex.v中248行。注意&&比||的优先级要高，因此括号的位置会影响结果。同时摸索了仿真调试的技巧，遇到问题，首先定位是哪里、哪个模块出了问题。
>
> 首先，可以在仿真器里显示各个可疑模块的输入和输出（本次我只测试了id.v和ex.v模块）。看有没有异常的信号，如果有，那么就可以判断错误的代码在对应的模块了。
>
> 然后，在该模块中找到会影响异常输出值的所有代码，显示中间值的信号图，依次排除。 
>
> > PPS：要注意的是，我们一般发现出错的地方是寄存器的值，由于我们采用了五级流水线的结构，实际出错的地方会出现在寄存器值错误的前几个周期，如果看的是执行阶段，那么就是提前3个时钟周期，因为到达回写阶段后，写入regfile还会增加一个时钟周期。