# 自己动手写CPU

## 第一章

### 指令集架构ISA（Instruction Set Architecture）

ISA将编程所需了解的硬件信息从硬件系统中抽象出来。从软件人员的角度看，ISA包括一套指令集和一些寄存器。ISA只是描述了CPU应该支持的每条指令是做什么事的，即指令的功能。简单地说，ISA就是提供给汇编程序员的最底层硬件的接口。

### 微架构（Microarchitecture）

微架构是ISA的一个具体实现。ISA好比设计规范，微架构则是具体实现。用编程里的概念类比，ISA就是接口（所能实现的各种功能），微架构就是实现功能的具体方式（采用的不同的算法），因此，同样的ISA，不同的微架构，会带来不同的性能。

- ISA主要分为CISC和RISC。
- CISC目前主流只有x86
- RISC主流包括ARM、SPARC、POWER、MIPS



其他博主的blog：

https://blog.csdn.net/qq_42914528/article/details/81779727



## 第四章

首先要做的就是搭建一个流水线结构。所谓流水线，在电路上的结构就是组合逻辑和时序逻辑电路级联，并没有想象中的那么复杂（还有一种结构是寄存器的输入端和输出端存在回路，被称为状态机）。

本书的CPU采取五级流水线结构，分别为：取指、译码、执行、访存、回写。

其中，译码阶段所要做的除了把机器码解释为不同的指令，还要承担取得操作数的工作，即从regs中（或指令中的立即数）取得执行阶段所需要的两个操作数（无论是否有一个操作数为立即数，都会把两个操作数分别转化为为reg1_o、reg2_o）。

不同阶段模块中通过中间模块连接（例如：if_id.v、id_ex.v等），这些模块所做的事几乎都是把输入数据按原样传递给下一个阶段，为什么要有这些模块呢？主要原因是将各个阶段的模块分离，并且严格按照时钟传送数据。

可以看到，流水线的各个阶段的敏感信号都是`*`（除了pc_reg取指令模块），即所有输入信号。而中间的过度模块中always的敏感信号都是`posedge clk`，即时钟的上升沿。这就保证了五级流水线中各个阶段的数据每个时钟周期就流向下一阶段，即“流水线”工作方式。

> 读取reg的电路是组合电路，即输入一有变化就立即反馈，这也保证了译码阶段及时取得操作数。

### 4.4 MIPS编译环境

本章简单的介绍了MIPS汇编程序编译链接的过程。

首先，由于我们写的是MIPS架构的CPU，用到的编译器也是MIPS的汇编器、链接器等。这些编译工具也都是在MIPS架构的CPU和系统环境下运行的。因此我们首先就是要取得这个环境。

直接在我们自己的PC机上装的Ubuntu/Linux或者Win10中的WSL都是不能运行该编译环境的（会报类似“二进制文件格式错误”的错，因为这个编译工具本身就是在MIPS架构下编译得到的，它的二进制机器。语言我们的PC机“看不懂”），因为现在的个人PC机基本上都是X86架构的CPU了（如果你用的是龙芯，请忽视这句话），系统也是分CPU架构的，大部分的Linux目前也是基于X86的，也可以去各个发行版的官网上找其他架构的版本。于是我们首先需要一个基于MIPS开发的Linux系统，本书采用的是OpenRISC版本的Ubuntu，目前书上给出的网站已经访问不了，官网上也下不了这个版本的Ubuntu，但是万能的网友当然会有“存货”的啦，直接搜`OpenRISC_Ubuntu_2011-12-15.vdi.bz2`这个关键词，应该是能搜到的（本人通过404网站搜的，度娘没有试过），或者直接去各种搜百度网盘资源的网站搜就行。然后下载virtual box虚拟机安装，具体步骤书上有，百度也行。

然后就是下载MIPS编译工具链了，这个可以在某Hub上搜到（CSDN的要积分）。下载完成后通过共享文件夹在虚拟机中可以运行了。

编译的过程如下：

1. 写MIPS的汇编程序
2. 使用`mips-sde-elf-as`指令将汇编程序编译成目标文件（Object），为链接做准备。这里的`.o`格式文件是ELF（Executable and Linkable Format），ELF文件有三种类型，这一步得到的是一个Relocatable类型的，其中包含着描述text段、data段、bss段等的描述信息，例如：段起始地址、长度等。
3. 编写链接描述文件，链接描述脚本描述了输入文件的各个Section如何映射到输出文件的各个Section中，并控制输出文件中Section和符号的内存布局。
4. 使用`mips-sde-elf-ld`指令将`.o`文件和链接描述脚本一起链接得到可执行文件`.om`（也属于ELF文件）。
5. 上一步得到的`.om`文件是一个ELF的可执行文件，其格式与我们需要加载到rom中的格式有很大不同，因此还需要使用 `mips-sde-elf-objcopy`将`.om`文件转化为二进制文件`.bin`。然后通过一个小程序进一步转换成我们需要的`.data`文件。

总结一下就是：编译、链接、转换格式。这里我们使用了好几个命令，这时为了可以重复使用，我们可以编写一个**Makefile**。来一次完成所有的工作。所以Makefile的本质就是把一个程序从编译到链接到转换格式所需要在terminal中输入的命令集中到一个文件中。Makefile的具体语法请自行搜索或看书上的简单介绍。

## 第五章

#### 数据相关问题

数据相关问题包括：RAW(Read After Write)、WAR(Write After Read)、WAW(Write After Write)。

由于本书的CPU分为五级流水线，在译码阶段读寄存器，在回写阶段才会写寄存器，因此不存在WAW相关和WAR相关。

解决RAW的方法有：

- 插入暂停周期
- 编译器调度，即编译器可以检测到相关性问题并且调准执行执行的顺序。
- 数据前推，即将执行阶段得到的结果直接发送到译码阶段，而不需要等到回写阶段。

本书OpenMIPS采用数据前推的方法解决RAW（Read After Write）的问题。具体的实现就是在id阶段增加两个**数据选择器（MUX）**，根据执行阶段和访存阶段反馈回来的值和信号具体确定是哪两个数据输出到ex阶段。

译码阶段输出的Aluop和Alusel是为了方便执行阶段执行操作的判断。

无论是寄存器位移版本（sllv、srav、srlv）还是立即数位移版本（sll、sra、srl），最终都是通过reg1_o和reg2_o输出两个操作数给id_ex.v至ex.v。

对任意一条指令而言，译码工作的主要内容是：确**定要读取的寄存器的情况、要执行的运算和要写入的目的寄存器**三方面的信息。



## 第六章

本章要实现的移动操作指令需要先新增**HI、LO两个特殊寄存器**，独立于regfile，位于回写阶段。

由于本章实现的移动操作指令造成的数据相关的问题包括普通寄存器regfile和特殊寄存器HI、LO的，前者已经在第五章解决了，因此我们在这里只需增加解决HI、LO两个寄存器的数据相关问题。这里我们的设计是：**译码阶段并不直接读取HI、LO的数值，而是在执行阶段才读取**，所以**新增的MUX放在执行阶段**，数据进入ALU之前。在哪个阶段加MUX，就要在修改哪个阶段的代码（虽然听着是个废话），数据通路是通过修改顶层文件openmips来实现的，顶层文件的本质就是按照数据流图连线。





## 第七章 算术操作指令的实现

本章所要实现的算术操作指令可以分为三类：

1. 简单算术操作指令

   包括加法、减法、比较、乘法等指令（不包括除法），该类指令与前面所实现的思路差不多。这些指令在流水线的执行阶段都只需要一个时钟周期。

2. 乘累加、乘累减

   正如其名，该类指令包括乘和加/减两种操作，因此执行阶段需要更长的时间来运行，如果我们将这两个操作都放在一个时钟周期中，那么一个时钟周期的时间就要增加，那么整个CPU的频率就会下降，从而导致流水线的其他阶段的执行速度也减慢了。

3. 除法指令

   包括有符号除法（div）和无符号除法（divu），OpenMIPS采用的是试商法完成除法运算，对于32位的除法，流水线执行阶段至少需要32个时钟周期。





### 第一类指令的实现

基本与前面章节的思路一致，没什么大问题。



> PS：这里遇到的一个小问题就是括号的位置了。。。详见ex.v中248行。注意&&比||的优先级要高，因此括号的位置会影响结果。同时摸索了仿真调试的技巧，遇到问题，首先定位是哪里、哪个模块出了问题。
>
> 首先，可以在仿真器里显示各个可疑模块的输入和输出（本次我只测试了id.v和ex.v模块）。看有没有异常的信号，如果有，那么就可以判断错误的代码在对应的模块了。
>
> 然后，在该模块中找到会影响异常输出值的所有代码，显示中间值的信号图，依次排除。 
>
> > PPS：要注意的是，我们一般发现出错的地方是寄存器的值，由于我们采用了五级流水线的结构，实际出错的地方会出现在寄存器值错误的前几个周期，如果看的是执行阶段，那么就是提前3个时钟周期，因为到达回写阶段后，写入regfile还会增加一个时钟周期。





### 7.5 流水线暂停机制的设计与实现

因为本章要实现的后面几种指令在执行阶段需要多个时钟周期，所以我们需要暂停流水线。

为了实现暂停，我们新增一个**CTRL模块**，用于接收暂停请求信号和发送暂停信号。由于只可能在译码和执行阶段需要多个周期，所以只有译码和执行两个阶段可以发送暂停请求。当一个阶段请求暂停时，这个阶段之前的流水线都得暂停，之后的可以继续执行。另外，译码和执行这两个阶段不需要接受暂停信号，且接受暂停的都是各个模块之间的过度模块和pc_reg.v（因为他们才受时钟周期的控制）。同时，为了保存MADD、MSUB、MADDU、MSUBU指令执行阶段的第一个时钟周期的中间结果，还要在ex.v和ex_mem.v上增加两个输入和输出端口，分别用于保存乘法结果和指示第几个时钟周期。





### 7.11 除法指令实现思路

由于实现除法的算法比较复杂，所以我们这里新增一个div.v模块专门用来做除法运算。OpenMIPS采用的是**试商法**，也就是我们小学学除法的时候用的**短除法**。由于OpenMIPS的寄存器是32位的，要从最高位开始试，所以最少要**32个时钟周期**。div模块具体的实现是一个**有限状态机**，它有四种状态：DivFree、DivByZero、DivOn、DivEnd。

ex.v模块中添加控制div.v模块的部分，包括除法所需要的数据和是否开始的标志，同时ex.v也要接收div.v的输出。

其他地方都与之前实现过的指令类似，就不多说了。

要说明的一点是，顶层文件的div.v模块实例化中的annul_i信号目前没有变化，始终为1’b0，因为现在没有要取消除法指令的状况。在之后的异常处理中会有。













## 附录

### 关于verilog中always的并行性

一个module里面的不同always块只要满足条件就会执行。如果多个always块的敏感信号条件相同，那么就是并行的。

如果两个并行的always块中的信号是相关的，那么其执行时会取得其需要的值是前一刻的值，具体还是看一个例子吧。

https://blog.csdn.net/jiangbeicaizi000/article/details/52093945

同时，`always @(*)` 是**一种描述组合逻辑的方式**。它相当于把always块内的所有输入信号都添加到了敏感信号列表里，这里说的输入信号，就是always块内“位于赋值符号右边”的信号（个人认为，如有异议，欢迎提出讨论）。

可以参考：https://zhuanlan.zhihu.com/p/72078544

现在，我们再来看本书的流水线结构，其各个阶段内部的模块都是组合逻辑电路来完成的，连接各个阶段的模块都是时序逻辑电路。并且是串连起来的，因此是流水线模式。



**其他关于always的blog：**

https://blog.csdn.net/phenixyf/article/details/46364193